/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/*
 * Copyright 2018-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable } from '@angular/core';
import { FnService } from '../util/fn.service';
import { LogService } from '../log.service';
import * as gds from './glyphdata.service';
import * as d3 from 'd3';
import { SvgUtilService } from './svgutil.service';
import * as i0 from "@angular/core";
import * as i1 from "../util/fn.service";
import * as i2 from "../log.service";
import * as i3 from "./svgutil.service";
// constants
/** @type {?} */
var msgGS = 'GlyphService.';
/** @type {?} */
var rg = 'registerGlyphs(): ';
/** @type {?} */
var rgs = 'registerGlyphSet(): ';
/**
 * ONOS GUI -- SVG -- Glyph Service
 */
var GlyphService = /** @class */ (function () {
    function GlyphService(fs, log, sus) {
        this.fs = fs;
        this.log = log;
        this.sus = sus;
        // internal state
        this.glyphs = d3.map();
        this.clear();
        this.init();
        this.api = {
            registerGlyphs: this.registerGlyphs,
            registerGlyphSet: this.registerGlyphSet,
            ids: this.ids,
            glyph: this.glyph,
            glyphDefined: this.glyphDefined,
            loadDefs: this.loadDefs,
            addGlyph: this.addGlyph,
        };
        this.log.debug('GlyphService constructed');
    }
    /**
     * @param {?} msg
     * @return {?}
     */
    GlyphService.prototype.warn = /**
     * @param {?} msg
     * @return {?}
     */
    function (msg) {
        this.log.warn(msgGS + msg);
    };
    /**
     * @param {?} key
     * @param {?} value
     * @param {?} vbox
     * @param {?} overwrite
     * @param {?} dups
     * @return {?}
     */
    GlyphService.prototype.addToMap = /**
     * @param {?} key
     * @param {?} value
     * @param {?} vbox
     * @param {?} overwrite
     * @param {?} dups
     * @return {?}
     */
    function (key, value, vbox, overwrite, dups) {
        if (!overwrite && this.glyphs.get(key)) {
            dups.push(key);
        }
        else {
            this.glyphs.set(key, { id: key, vb: vbox, d: value });
        }
    };
    /**
     * @param {?} dups
     * @param {?} which
     * @return {?}
     */
    GlyphService.prototype.reportDups = /**
     * @param {?} dups
     * @param {?} which
     * @return {?}
     */
    function (dups, which) {
        var _this = this;
        /** @type {?} */
        var ok = (dups.length === 0);
        /** @type {?} */
        var msg = 'ID collision: ';
        if (!ok) {
            dups.forEach(function (id) {
                _this.warn(which + msg + '"' + id + '"');
            });
        }
        return ok;
    };
    /**
     * @param {?} missing
     * @param {?} which
     * @return {?}
     */
    GlyphService.prototype.reportMissVb = /**
     * @param {?} missing
     * @param {?} which
     * @return {?}
     */
    function (missing, which) {
        var _this = this;
        /** @type {?} */
        var ok = (missing.length === 0);
        /** @type {?} */
        var msg = 'Missing viewbox property: ';
        if (!ok) {
            missing.forEach(function (vbk) {
                _this.warn(which + msg + '"' + vbk + '"');
            });
        }
        return ok;
    };
    /**
     * @return {?}
     */
    GlyphService.prototype.clear = /**
     * @return {?}
     */
    function () {
        // start with a fresh map
        this.glyphs = d3.map();
    };
    /**
     * @return {?}
     */
    GlyphService.prototype.init = /**
     * @return {?}
     */
    function () {
        this.log.info('Registering glyphs');
        this.registerGlyphs(gds.logos);
        this.registerGlyphSet(gds.glyphDataSet);
        this.registerGlyphSet(gds.badgeDataSet);
        this.registerGlyphs(gds.spriteData);
        this.registerGlyphSet(gds.mojoDataSet);
        this.registerGlyphs(gds.extraGlyphs);
    };
    /**
     * @param {?} data
     * @param {?=} overwrite
     * @return {?}
     */
    GlyphService.prototype.registerGlyphs = /**
     * @param {?} data
     * @param {?=} overwrite
     * @return {?}
     */
    function (data, overwrite) {
        if (overwrite === void 0) { overwrite = false; }
        var e_1, _a;
        /** @type {?} */
        var dups = [];
        /** @type {?} */
        var missvb = [];
        try {
            for (var _b = tslib_1.__values(data.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = tslib_1.__read(_c.value, 2), key = _d[0], value = _d[1];
                /** @type {?} */
                var vbk = '_' + key;
                /** @type {?} */
                var vb = data.get(vbk);
                if (key[0] !== '_') {
                    if (!vb) {
                        missvb.push(vbk);
                        continue;
                    }
                    this.addToMap(key, value, vb, overwrite, dups);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return this.reportDups(dups, rg) && this.reportMissVb(missvb, rg);
    };
    /**
     * @param {?} data
     * @param {?=} overwrite
     * @return {?}
     */
    GlyphService.prototype.registerGlyphSet = /**
     * @param {?} data
     * @param {?=} overwrite
     * @return {?}
     */
    function (data, overwrite) {
        if (overwrite === void 0) { overwrite = false; }
        var e_2, _a;
        /** @type {?} */
        var dups = [];
        /** @type {?} */
        var vb = data.get('_viewbox');
        if (!vb) {
            this.warn(rgs + 'no "_viewbox" property found');
            return false;
        }
        try {
            for (var _b = tslib_1.__values(data.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = tslib_1.__read(_c.value, 2), key = _d[0], value = _d[1];
                //        angular.forEach(data, function (value, key) {
                if (key[0] !== '_') {
                    this.addToMap(key, value, vb, overwrite, dups);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return this.reportDups(dups, rgs);
    };
    /**
     * @return {?}
     */
    GlyphService.prototype.ids = /**
     * @return {?}
     */
    function () {
        return this.glyphs.keys();
    };
    /**
     * @param {?} id
     * @return {?}
     */
    GlyphService.prototype.glyph = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return this.glyphs.get(id);
    };
    /**
     * @param {?} id
     * @return {?}
     */
    GlyphService.prototype.glyphDefined = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return this.glyphs.has(id);
    };
    /**
     * Load definitions of a glyph
     *
     * Note: defs should be a D3 selection of a single <defs> element
     */
    /**
     * Load definitions of a glyph
     *
     * Note: defs should be a D3 selection of a single <defs> element
     * @param {?} defs
     * @param {?} glyphIds
     * @param {?} noClear
     * @return {?}
     */
    GlyphService.prototype.loadDefs = /**
     * Load definitions of a glyph
     *
     * Note: defs should be a D3 selection of a single <defs> element
     * @param {?} defs
     * @param {?} glyphIds
     * @param {?} noClear
     * @return {?}
     */
    function (defs, glyphIds, noClear) {
        var _this = this;
        /** @type {?} */
        var list = this.fs.isA(glyphIds) || this.ids();
        if (!noClear) {
            // remove all existing content
            defs.html(null);
        }
        // load up the requested glyphs
        list.forEach(function (id) {
            /** @type {?} */
            var g = _this.glyph(id);
            if (g) {
                if (noClear) {
                    // quick exit if symbol is already present
                    // TODO: check if this should be a continue or break instead
                    if (defs.select('symbol#' + g.id).size() > 0) {
                        return;
                    }
                }
                defs.append('symbol')
                    .attr('id', g.id)
                    .attr('viewBox', g.vb)
                    .append('path')
                    .attr('d', g.d);
            }
        });
    };
    /**
     * @param {?} elem
     * @param {?} glyphId
     * @param {?} size
     * @param {?} overlay
     * @param {?} trans
     * @return {?}
     */
    GlyphService.prototype.addGlyph = /**
     * @param {?} elem
     * @param {?} glyphId
     * @param {?} size
     * @param {?} overlay
     * @param {?} trans
     * @return {?}
     */
    function (elem, glyphId, size, overlay, trans) {
        /** @type {?} */
        var sz = size || 40;
        /** @type {?} */
        var ovr = !!overlay;
        /** @type {?} */
        var xns = this.fs.isA(trans);
        /** @type {?} */
        var glyphUse = elem
            .append('use')
            .attr('width', sz)
            .attr('height', sz)
            .attr('class', 'glyph')
            .attr('xlink:href', '#' + glyphId)
            .classed('overlay', ovr);
        if (xns) {
            glyphUse.attr('transform', this.sus.translate(trans));
        }
        return glyphUse;
    };
    GlyphService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] },
    ];
    /** @nocollapse */
    GlyphService.ctorParameters = function () { return [
        { type: FnService },
        { type: LogService },
        { type: SvgUtilService }
    ]; };
    /** @nocollapse */ GlyphService.ngInjectableDef = i0.defineInjectable({ factory: function GlyphService_Factory() { return new GlyphService(i0.inject(i1.FnService), i0.inject(i2.LogService), i0.inject(i3.SvgUtilService)); }, token: GlyphService, providedIn: "root" });
    return GlyphService;
}());
export { GlyphService };
if (false) {
    /** @type {?} */
    GlyphService.prototype.glyphs;
    /** @type {?} */
    GlyphService.prototype.api;
    /** @type {?} */
    GlyphService.prototype.fs;
    /** @type {?} */
    GlyphService.prototype.log;
    /** @type {?} */
    GlyphService.prototype.sus;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2x5cGguc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2d1aTItZnctbGliLyIsInNvdXJjZXMiOlsibGliL3N2Zy9nbHlwaC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDL0MsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzVDLE9BQU8sS0FBSyxHQUFHLE1BQU0scUJBQXFCLENBQUM7QUFDM0MsT0FBTyxLQUFLLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDekIsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDOzs7Ozs7O0lBRzdDLEtBQUssR0FBRyxlQUFlOztJQUN2QixFQUFFLEdBQUcsb0JBQW9COztJQUN6QixHQUFHLEdBQUcsc0JBQXNCOzs7O0FBS2xDO0lBUUksc0JBQ1ksRUFBYSxFQUViLEdBQWUsRUFDZixHQUFtQjtRQUhuQixPQUFFLEdBQUYsRUFBRSxDQUFXO1FBRWIsUUFBRyxHQUFILEdBQUcsQ0FBWTtRQUNmLFFBQUcsR0FBSCxHQUFHLENBQWdCOztRQVAvQixXQUFNLEdBQUcsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBU2QsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2IsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ1osSUFBSSxDQUFDLEdBQUcsR0FBRztZQUNQLGNBQWMsRUFBRSxJQUFJLENBQUMsY0FBYztZQUNuQyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsZ0JBQWdCO1lBQ3ZDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRztZQUNiLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztZQUNqQixZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVk7WUFDL0IsUUFBUSxFQUFFLElBQUks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QUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUN6RDtRQUVELE9BQU8sUUFBUSxDQUFDO0lBQ3BCLENBQUM7O2dCQW5MSixVQUFVLFNBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25COzs7O2dCQWhCUSxTQUFTO2dCQUNULFVBQVU7Z0JBR1YsY0FBYzs7O3VCQXBCdkI7Q0FrTkMsQUFwTEQsSUFvTEM7U0FqTFksWUFBWTs7O0lBRXJCLDhCQUFrQjs7SUFDbEIsMkJBQVk7O0lBR1IsMEJBQXFCOztJQUVyQiwyQkFBdUI7O0lBQ3ZCLDJCQUEyQiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAxOC1wcmVzZW50IE9wZW4gTmV0d29ya2luZyBGb3VuZGF0aW9uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGblNlcnZpY2UgfSBmcm9tICcuLi91dGlsL2ZuLnNlcnZpY2UnO1xuaW1wb3J0IHsgTG9nU2VydmljZSB9IGZyb20gJy4uL2xvZy5zZXJ2aWNlJztcbmltcG9ydCAqIGFzIGdkcyBmcm9tICcuL2dseXBoZGF0YS5zZXJ2aWNlJztcbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbmltcG9ydCB7IFN2Z1V0aWxTZXJ2aWNlIH0gZnJvbSAnLi9zdmd1dGlsLnNlcnZpY2UnO1xuXG4vLyBjb25zdGFudHNcbmNvbnN0IG1zZ0dTID0gJ0dseXBoU2VydmljZS4nO1xuY29uc3QgcmcgPSAncmVnaXN0ZXJHbHlwaHMoKTogJztcbmNvbnN0IHJncyA9ICdyZWdpc3RlckdseXBoU2V0KCk6ICc7XG5cbi8qKlxuICogT05PUyBHVUkgLS0gU1ZHIC0tIEdseXBoIFNlcnZpY2VcbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIEdseXBoU2VydmljZSB7XG4gICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICBnbHlwaHMgPSBkMy5tYXAoKTtcbiAgICBhcGk6IE9iamVjdDtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGZzOiBGblNlcnZpY2UsXG4gICAgICAgIC8vICAgICAgICBwcml2YXRlIGdkOiBHbHlwaERhdGFTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIGxvZzogTG9nU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBzdXM6IFN2Z1V0aWxTZXJ2aWNlXG4gICAgKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHRoaXMuYXBpID0ge1xuICAgICAgICAgICAgcmVnaXN0ZXJHbHlwaHM6IHRoaXMucmVnaXN0ZXJHbHlwaHMsXG4gICAgICAgICAgICByZWdpc3RlckdseXBoU2V0OiB0aGlzLnJlZ2lzdGVyR2x5cGhTZXQsXG4gICAgICAgICAgICBpZHM6IHRoaXMuaWRzLFxuICAgICAgICAgICAgZ2x5cGg6IHRoaXMuZ2x5cGgsXG4gICAgICAgICAgICBnbHlwaERlZmluZWQ6IHRoaXMuZ2x5cGhEZWZpbmVkLFxuICAgICAgICAgICAgbG9hZERlZnM6IHRoaXMubG9hZERlZnMsXG4gICAgICAgICAgICBhZGRHbHlwaDogdGhpcy5hZGRHbHlwaCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ0dseXBoU2VydmljZSBjb25zdHJ1Y3RlZCcpO1xuICAgIH1cblxuICAgIHdhcm4obXNnOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2cud2Fybihtc2dHUyArIG1zZyk7XG4gICAgfVxuXG4gICAgYWRkVG9NYXAoa2V5LCB2YWx1ZSwgdmJveCwgb3ZlcndyaXRlOiBib29sZWFuLCBkdXBzKSB7XG4gICAgICAgIGlmICghb3ZlcndyaXRlICYmIHRoaXMuZ2x5cGhzLmdldChrZXkpKSB7XG4gICAgICAgICAgICBkdXBzLnB1c2goa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhzLnNldChrZXksIHsgaWQ6IGtleSwgdmI6IHZib3gsIGQ6IHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVwb3J0RHVwcyhkdXBzOiBzdHJpbmdbXSwgd2hpY2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBvazogYm9vbGVhbiA9IChkdXBzLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIGNvbnN0IG1zZyA9ICdJRCBjb2xsaXNpb246ICc7XG5cbiAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgZHVwcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud2Fybih3aGljaCArIG1zZyArICdcIicgKyBpZCArICdcIicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9rO1xuICAgIH1cblxuICAgIHJlcG9ydE1pc3NWYihtaXNzaW5nOiBzdHJpbmdbXSwgd2hpY2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBvazogYm9vbGVhbiA9IChtaXNzaW5nLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIGNvbnN0IG1zZyA9ICdNaXNzaW5nIHZpZXdib3ggcHJvcGVydHk6ICc7XG5cbiAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgbWlzc2luZy5mb3JFYWNoKCh2YmspID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndhcm4od2hpY2ggKyBtc2cgKyAnXCInICsgdmJrICsgJ1wiJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2s7XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIC8vIHN0YXJ0IHdpdGggYSBmcmVzaCBtYXBcbiAgICAgICAgdGhpcy5nbHlwaHMgPSBkMy5tYXAoKTtcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKCdSZWdpc3RlcmluZyBnbHlwaHMnKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckdseXBocyhnZHMubG9nb3MpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyR2x5cGhTZXQoZ2RzLmdseXBoRGF0YVNldCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJHbHlwaFNldChnZHMuYmFkZ2VEYXRhU2V0KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckdseXBocyhnZHMuc3ByaXRlRGF0YSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJHbHlwaFNldChnZHMubW9qb0RhdGFTZXQpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyR2x5cGhzKGdkcy5leHRyYUdseXBocyk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJHbHlwaHMoZGF0YTogTWFwPHN0cmluZywgc3RyaW5nPiwgb3ZlcndyaXRlOiBib29sZWFuID0gZmFsc2UpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZHVwczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgY29uc3QgbWlzc3ZiOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBkYXRhLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdmJrID0gJ18nICsga2V5O1xuICAgICAgICAgICAgY29uc3QgdmIgPSBkYXRhLmdldCh2YmspO1xuXG4gICAgICAgICAgICBpZiAoa2V5WzBdICE9PSAnXycpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pc3N2Yi5wdXNoKHZiayk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRvTWFwKGtleSwgdmFsdWUsIHZiLCBvdmVyd3JpdGUsIGR1cHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcG9ydER1cHMoZHVwcywgcmcpICYmIHRoaXMucmVwb3J0TWlzc1ZiKG1pc3N2YiwgcmcpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyR2x5cGhTZXQoZGF0YTogTWFwPHN0cmluZywgc3RyaW5nPiwgb3ZlcndyaXRlOiBib29sZWFuID0gZmFsc2UpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZHVwczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgY29uc3QgdmI6IHN0cmluZyA9IGRhdGEuZ2V0KCdfdmlld2JveCcpO1xuXG4gICAgICAgIGlmICghdmIpIHtcbiAgICAgICAgICAgIHRoaXMud2FybihyZ3MgKyAnbm8gXCJfdmlld2JveFwiIHByb3BlcnR5IGZvdW5kJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBkYXRhLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgLy8gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChkYXRhLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gJ18nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUb01hcChrZXksIHZhbHVlLCB2Yiwgb3ZlcndyaXRlLCBkdXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXBvcnREdXBzKGR1cHMsIHJncyk7XG4gICAgfVxuXG4gICAgaWRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbHlwaHMua2V5cygpO1xuICAgIH1cblxuICAgIGdseXBoKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdseXBocy5nZXQoaWQpO1xuICAgIH1cblxuICAgIGdseXBoRGVmaW5lZChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbHlwaHMuaGFzKGlkKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIExvYWQgZGVmaW5pdGlvbnMgb2YgYSBnbHlwaFxuICAgICAqXG4gICAgICogTm90ZTogZGVmcyBzaG91bGQgYmUgYSBEMyBzZWxlY3Rpb24gb2YgYSBzaW5nbGUgPGRlZnM+IGVsZW1lbnRcbiAgICAgKi9cbiAgICBsb2FkRGVmcyhkZWZzLCBnbHlwaElkczogc3RyaW5nW10sIG5vQ2xlYXI6IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMuZnMuaXNBKGdseXBoSWRzKSB8fCB0aGlzLmlkcygpO1xuXG4gICAgICAgIGlmICghbm9DbGVhcikge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBleGlzdGluZyBjb250ZW50XG4gICAgICAgICAgICBkZWZzLmh0bWwobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsb2FkIHVwIHRoZSByZXF1ZXN0ZWQgZ2x5cGhzXG4gICAgICAgIGxpc3QuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGcgPSB0aGlzLmdseXBoKGlkKTtcbiAgICAgICAgICAgIGlmIChnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vQ2xlYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcXVpY2sgZXhpdCBpZiBzeW1ib2wgaXMgYWxyZWFkeSBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIHRoaXMgc2hvdWxkIGJlIGEgY29udGludWUgb3IgYnJlYWsgaW5zdGVhZFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmcy5zZWxlY3QoJ3N5bWJvbCMnICsgZy5pZCkuc2l6ZSgpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZnMuYXBwZW5kKCdzeW1ib2wnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCBnLmlkKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndmlld0JveCcsIGcudmIpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZCcsIGcuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZEdseXBoKGVsZW06IGFueSwgZ2x5cGhJZDogc3RyaW5nLCBzaXplOiBudW1iZXIsIG92ZXJsYXk6IGFueSwgdHJhbnM6IGFueSkge1xuICAgICAgICBjb25zdCBzeiA9IHNpemUgfHwgNDA7XG4gICAgICAgIGNvbnN0IG92ciA9ICEhb3ZlcmxheTtcbiAgICAgICAgY29uc3QgeG5zID0gdGhpcy5mcy5pc0EodHJhbnMpO1xuXG4gICAgICAgIGNvbnN0IGdseXBoVXNlID0gZWxlbVxuICAgICAgICAgICAgLmFwcGVuZCgndXNlJylcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHN6KVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHN6KVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2dseXBoJylcbiAgICAgICAgICAgIC5hdHRyKCd4bGluazpocmVmJywgJyMnICsgZ2x5cGhJZClcbiAgICAgICAgICAgIC5jbGFzc2VkKCdvdmVybGF5Jywgb3ZyKTtcblxuICAgICAgICBpZiAoeG5zKSB7XG4gICAgICAgICAgICBnbHlwaFVzZS5hdHRyKCd0cmFuc2Zvcm0nLCB0aGlzLnN1cy50cmFuc2xhdGUodHJhbnMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbHlwaFVzZTtcbiAgICB9XG59XG4iXX0=