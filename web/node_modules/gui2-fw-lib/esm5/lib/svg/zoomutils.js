/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/*
 * Copyright 2019-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
var LONGITUDE_EXTENT = 180;
/** @type {?} */
var LATITUDE_EXTENT = 75;
/** @type {?} */
var GRID_EXTENT_X = 2000;
/** @type {?} */
var GRID_EXTENT_Y = 1000;
/** @type {?} */
var GRID_DIAGONAL = 2236;
// 2236 is the length of the diagonal of the 2000x1000 box
/** @type {?} */
var GRID_CENTRE_X = 500;
/** @type {?} */
var GRID_CENTRE_Y = 500;
/**
 * A model of the map bounds bottom left to top right in lat and long
 * @record
 */
export function MapBounds() { }
if (false) {
    /** @type {?} */
    MapBounds.prototype.lngMin;
    /** @type {?} */
    MapBounds.prototype.latMin;
    /** @type {?} */
    MapBounds.prototype.lngMax;
    /** @type {?} */
    MapBounds.prototype.latMax;
}
/**
 * model of the topo2CurrentRegion Loc part of the MetaUi below
 * @record
 */
export function LocMeta() { }
if (false) {
    /** @type {?} */
    LocMeta.prototype.lng;
    /** @type {?} */
    LocMeta.prototype.lat;
}
/**
 * model of the topo2CurrentRegion MetaUi from Device below
 * @record
 */
export function MetaUi() { }
if (false) {
    /** @type {?} */
    MetaUi.prototype.equivLoc;
    /** @type {?} */
    MetaUi.prototype.x;
    /** @type {?} */
    MetaUi.prototype.y;
}
/**
 * Model of the Zoom preferences
 * @record
 */
export function TopoZoomPrefs() { }
if (false) {
    /** @type {?} */
    TopoZoomPrefs.prototype.tx;
    /** @type {?} */
    TopoZoomPrefs.prototype.ty;
    /** @type {?} */
    TopoZoomPrefs.prototype.sc;
}
/**
 * Utility class with static functions for scaling maps
 *
 * This is left as a class, so that the functions are loaded only as needed
 */
var /**
 * Utility class with static functions for scaling maps
 *
 * This is left as a class, so that the functions are loaded only as needed
 */
ZoomUtils = /** @class */ (function () {
    function ZoomUtils() {
    }
    /**
     * @param {?} location
     * @return {?}
     */
    ZoomUtils.convertGeoToCanvas = /**
     * @param {?} location
     * @return {?}
     */
    function (location) {
        /** @type {?} */
        var calcX = (LONGITUDE_EXTENT + location.lng) / (LONGITUDE_EXTENT * 2) * GRID_EXTENT_X - GRID_CENTRE_X;
        /** @type {?} */
        var calcY = (LATITUDE_EXTENT - location.lat) / (LATITUDE_EXTENT * 2) * GRID_EXTENT_Y;
        return (/** @type {?} */ ({
            x: calcX,
            y: calcY,
            equivLoc: {
                lat: location.lat,
                lng: location.lng
            }
        }));
    };
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    ZoomUtils.convertXYtoGeo = /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    function (x, y) {
        /** @type {?} */
        var calcLong = (x + GRID_CENTRE_X) * 2 * LONGITUDE_EXTENT / GRID_EXTENT_X - LONGITUDE_EXTENT;
        /** @type {?} */
        var calcLat = -(y * 2 * LATITUDE_EXTENT / GRID_EXTENT_Y - LATITUDE_EXTENT);
        return (/** @type {?} */ ({
            x: x,
            y: y,
            equivLoc: (/** @type {?} */ ({
                lat: (calcLat === -0) ? 0 : calcLat,
                lng: calcLong
            }))
        }));
    };
    /**
     * This converts the bounds of a map loaded from a TopoGson file that has been
     * converted in to a GEOJson format by d3
     *
     * The bounds are in latitude and longitude from bottom left (min) to top right (max)
     *
     * First they are converted in to SVG viewbox coordinates 0,0 top left 1000x1000
     *
     * The the zoom level is calculated by scaling to the grid diagonal
     *
     * Finally the translation is calculated by applying the zoom first, and then
     * translating on the zoomed coordinate system
     * @param mapBounds - the bounding box of the chosen map in lat and long
     * @param log The LogService
     */
    /**
     * This converts the bounds of a map loaded from a TopoGson file that has been
     * converted in to a GEOJson format by d3
     *
     * The bounds are in latitude and longitude from bottom left (min) to top right (max)
     *
     * First they are converted in to SVG viewbox coordinates 0,0 top left 1000x1000
     *
     * The the zoom level is calculated by scaling to the grid diagonal
     *
     * Finally the translation is calculated by applying the zoom first, and then
     * translating on the zoomed coordinate system
     * @param {?} mapBounds - the bounding box of the chosen map in lat and long
     * @param {?=} log The LogService
     * @return {?}
     */
    ZoomUtils.convertBoundsToZoomLevel = /**
     * This converts the bounds of a map loaded from a TopoGson file that has been
     * converted in to a GEOJson format by d3
     *
     * The bounds are in latitude and longitude from bottom left (min) to top right (max)
     *
     * First they are converted in to SVG viewbox coordinates 0,0 top left 1000x1000
     *
     * The the zoom level is calculated by scaling to the grid diagonal
     *
     * Finally the translation is calculated by applying the zoom first, and then
     * translating on the zoomed coordinate system
     * @param {?} mapBounds - the bounding box of the chosen map in lat and long
     * @param {?=} log The LogService
     * @return {?}
     */
    function (mapBounds, log) {
        /** @type {?} */
        var min = this.convertGeoToCanvas((/** @type {?} */ ({
            lng: mapBounds.lngMin,
            lat: mapBounds.latMin
        })));
        /** @type {?} */
        var max = this.convertGeoToCanvas((/** @type {?} */ ({
            lng: mapBounds.lngMax,
            lat: mapBounds.latMax
        })));
        /** @type {?} */
        var diagonal = Math.sqrt(Math.pow(max.x - min.x, 2) + Math.pow(max.y - min.y, 2));
        /** @type {?} */
        var centreX = (max.x - min.x) / 2 + min.x;
        /** @type {?} */
        var centreY = (max.y - min.y) / 2 + min.y;
        // Zoom works from the top left of the 1000x1000 viewbox
        // The scale is applied first and then the translate is on the scaled coordinates
        /** @type {?} */
        var zoomscale = 0.5 * GRID_DIAGONAL / ((diagonal < 100) ? 100 : diagonal);
        // Don't divide by zero
        /** @type {?} */
        var zoomx = -centreX * zoomscale + GRID_CENTRE_X;
        /** @type {?} */
        var zoomy = -centreY * zoomscale + GRID_CENTRE_Y;
        // log.debug('MapBounds', mapBounds, 'XYMin', min, 'XYMax', max, 'Diag', diagonal,
        //     'Centre', centreX, centreY, 'translate', zoomx, zoomy, 'Scale', zoomscale);
        return (/** @type {?} */ ({ tx: zoomx, ty: zoomy, sc: zoomscale }));
    };
    /**
     * Calculate Zoom settings to fit the 1000x1000 grid in to the available window height
     * less the banner height
     *
     * Scaling always happens from the top left 0,0
     * If the height is greater than the width then no scaling is required - grid will
     * need to fill the SVG canvas
     * @param bannerHeight - the top band of the screen for the mast
     * @param innerWidth - the actual width of the screen
     * @param innerHeight - the actual height of the screen
     * @return Zoom settings - scale and translate
     */
    /**
     * Calculate Zoom settings to fit the 1000x1000 grid in to the available window height
     * less the banner height
     *
     * Scaling always happens from the top left 0,0
     * If the height is greater than the width then no scaling is required - grid will
     * need to fill the SVG canvas
     * @param {?} bannerHeight - the top band of the screen for the mast
     * @param {?} innerWidth - the actual width of the screen
     * @param {?} innerHeight - the actual height of the screen
     * @return {?} Zoom settings - scale and translate
     */
    ZoomUtils.zoomToWindowSize = /**
     * Calculate Zoom settings to fit the 1000x1000 grid in to the available window height
     * less the banner height
     *
     * Scaling always happens from the top left 0,0
     * If the height is greater than the width then no scaling is required - grid will
     * need to fill the SVG canvas
     * @param {?} bannerHeight - the top band of the screen for the mast
     * @param {?} innerWidth - the actual width of the screen
     * @param {?} innerHeight - the actual height of the screen
     * @return {?} Zoom settings - scale and translate
     */
    function (bannerHeight, innerWidth, innerHeight) {
        /** @type {?} */
        var newHeight = innerHeight - bannerHeight;
        if (newHeight > innerWidth) {
            return (/** @type {?} */ ({
                sc: 1.0,
                tx: 0,
                ty: 0
            }));
        }
        else {
            /** @type {?} */
            var scale = newHeight / innerWidth;
            return (/** @type {?} */ ({
                sc: scale,
                tx: (500 / scale - 500) * scale,
                ty: 0
            }));
        }
    };
    return ZoomUtils;
}());
/**
 * Utility class with static functions for scaling maps
 *
 * This is left as a class, so that the functions are loaded only as needed
 */
export { ZoomUtils };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiem9vbXV0aWxzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vZ3VpMi1mdy1saWIvIiwic291cmNlcyI6WyJsaWIvc3ZnL3pvb211dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQW1CTSxnQkFBZ0IsR0FBRyxHQUFHOztJQUN0QixlQUFlLEdBQUcsRUFBRTs7SUFDcEIsYUFBYSxHQUFHLElBQUk7O0lBQ3BCLGFBQWEsR0FBRyxJQUFJOztJQUNwQixhQUFhLEdBQUcsSUFBSTs7O0lBQ3BCLGFBQWEsR0FBRyxHQUFHOztJQUNuQixhQUFhLEdBQUcsR0FBRzs7Ozs7QUFNekIsK0JBS0M7OztJQUpHLDJCQUFlOztJQUNmLDJCQUFlOztJQUNmLDJCQUFlOztJQUNmLDJCQUFlOzs7Ozs7QUFNbkIsNkJBR0M7OztJQUZHLHNCQUFZOztJQUNaLHNCQUFZOzs7Ozs7QUFNaEIsNEJBSUM7OztJQUhHLDBCQUFrQjs7SUFDbEIsbUJBQVU7O0lBQ1YsbUJBQVU7Ozs7OztBQU1kLG1DQUlDOzs7SUFIRywyQkFBVzs7SUFDWCwyQkFBVzs7SUFDWCwyQkFBVzs7Ozs7OztBQVFmOzs7Ozs7SUFBQTtJQWtHQSxDQUFDOzs7OztJQWpHVSw0QkFBa0I7Ozs7SUFBekIsVUFBMEIsUUFBaUI7O1lBQ2pDLEtBQUssR0FBRyxDQUFDLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLGdCQUFnQixHQUFHLENBQUMsQ0FBQyxHQUFHLGFBQWEsR0FBRyxhQUFhOztZQUNsRyxLQUFLLEdBQUcsQ0FBQyxlQUFlLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsZUFBZSxHQUFHLENBQUMsQ0FBQyxHQUFHLGFBQWE7UUFDdEYsT0FBTyxtQkFBUTtZQUNYLENBQUMsRUFBRSxLQUFLO1lBQ1IsQ0FBQyxFQUFFLEtBQUs7WUFDUixRQUFRLEVBQUU7Z0JBQ04sR0FBRyxFQUFFLFFBQVEsQ0FBQyxHQUFHO2dCQUNqQixHQUFH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Q0csS0FBSyxHQUFHLFNBQVMsR0FBRyxVQUFVO1lBQ3BDLE9BQU8sbUJBQWU7Z0JBQ2xCLEVBQUUsRUFBRSxLQUFLO2dCQUNULEVBQUUsRUFBRSxDQUFDLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsS0FBSztnQkFDL0IsRUFBRSxFQUFFLENBQUM7YUFDUixFQUFBLENBQUM7U0FDTDtJQUNMLENBQUM7SUFDTCxnQkFBQztBQUFELENBQUMsQUFsR0QsSUFrR0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMTktcHJlc2VudCBPcGVuIE5ldHdvcmtpbmcgRm91bmRhdGlvblxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuaW1wb3J0IHtMb2dTZXJ2aWNlfSBmcm9tICcuLi9sb2cuc2VydmljZSc7XG5cbmNvbnN0IExPTkdJVFVERV9FWFRFTlQgPSAxODA7XG5jb25zdCBMQVRJVFVERV9FWFRFTlQgPSA3NTtcbmNvbnN0IEdSSURfRVhURU5UX1ggPSAyMDAwO1xuY29uc3QgR1JJRF9FWFRFTlRfWSA9IDEwMDA7XG5jb25zdCBHUklEX0RJQUdPTkFMID0gMjIzNjsgLy8gMjIzNiBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBkaWFnb25hbCBvZiB0aGUgMjAwMHgxMDAwIGJveFxuY29uc3QgR1JJRF9DRU5UUkVfWCA9IDUwMDtcbmNvbnN0IEdSSURfQ0VOVFJFX1kgPSA1MDA7XG5cblxuLyoqXG4gKiBBIG1vZGVsIG9mIHRoZSBtYXAgYm91bmRzIGJvdHRvbSBsZWZ0IHRvIHRvcCByaWdodCBpbiBsYXQgYW5kIGxvbmdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYXBCb3VuZHMge1xuICAgIGxuZ01pbjogbnVtYmVyO1xuICAgIGxhdE1pbjogbnVtYmVyO1xuICAgIGxuZ01heDogbnVtYmVyO1xuICAgIGxhdE1heDogbnVtYmVyO1xufVxuXG4vKipcbiAqIG1vZGVsIG9mIHRoZSB0b3BvMkN1cnJlbnRSZWdpb24gTG9jIHBhcnQgb2YgdGhlIE1ldGFVaSBiZWxvd1xuICovXG5leHBvcnQgaW50ZXJmYWNlIExvY01ldGEge1xuICAgIGxuZzogbnVtYmVyO1xuICAgIGxhdDogbnVtYmVyO1xufVxuXG4vKipcbiAqIG1vZGVsIG9mIHRoZSB0b3BvMkN1cnJlbnRSZWdpb24gTWV0YVVpIGZyb20gRGV2aWNlIGJlbG93XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWV0YVVpIHtcbiAgICBlcXVpdkxvYzogTG9jTWV0YTtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xufVxuXG4vKipcbiAqIE1vZGVsIG9mIHRoZSBab29tIHByZWZlcmVuY2VzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVG9wb1pvb21QcmVmcyB7XG4gICAgdHg6IG51bWJlcjtcbiAgICB0eTogbnVtYmVyO1xuICAgIHNjOiBudW1iZXI7XG59XG5cbi8qKlxuICogVXRpbGl0eSBjbGFzcyB3aXRoIHN0YXRpYyBmdW5jdGlvbnMgZm9yIHNjYWxpbmcgbWFwc1xuICpcbiAqIFRoaXMgaXMgbGVmdCBhcyBhIGNsYXNzLCBzbyB0aGF0IHRoZSBmdW5jdGlvbnMgYXJlIGxvYWRlZCBvbmx5IGFzIG5lZWRlZFxuICovXG5leHBvcnQgY2xhc3MgWm9vbVV0aWxzIHtcbiAgICBzdGF0aWMgY29udmVydEdlb1RvQ2FudmFzKGxvY2F0aW9uOiBMb2NNZXRhICk6IE1ldGFVaSB7XG4gICAgICAgIGNvbnN0IGNhbGNYID0gKExPTkdJVFVERV9FWFRFTlQgKyBsb2NhdGlvbi5sbmcpIC8gKExPTkdJVFVERV9FWFRFTlQgKiAyKSAqIEdSSURfRVhURU5UX1ggLSBHUklEX0NFTlRSRV9YO1xuICAgICAgICBjb25zdCBjYWxjWSA9IChMQVRJVFVERV9FWFRFTlQgLSBsb2NhdGlvbi5sYXQpIC8gKExBVElUVURFX0VYVEVOVCAqIDIpICogR1JJRF9FWFRFTlRfWTtcbiAgICAgICAgcmV0dXJuIDxNZXRhVWk+e1xuICAgICAgICAgICAgeDogY2FsY1gsXG4gICAgICAgICAgICB5OiBjYWxjWSxcbiAgICAgICAgICAgIGVxdWl2TG9jOiB7XG4gICAgICAgICAgICAgICAgbGF0OiBsb2NhdGlvbi5sYXQsXG4gICAgICAgICAgICAgICAgbG5nOiBsb2NhdGlvbi5sbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY29udmVydFhZdG9HZW8oeDogbnVtYmVyLCB5OiBudW1iZXIpOiBNZXRhVWkge1xuICAgICAgICBjb25zdCBjYWxjTG9uZzogbnVtYmVyID0gKHggKyBHUklEX0NFTlRSRV9YKSAqIDIgKiBMT05HSVRVREVfRVhURU5UIC8gR1JJRF9FWFRFTlRfWCAtIExPTkdJVFVERV9FWFRFTlQ7XG4gICAgICAgIGNvbnN0IGNhbGNMYXQ6IG51bWJlciA9IC0oeSAqIDIgKiBMQVRJVFVERV9FWFRFTlQgLyBHUklEX0VYVEVOVF9ZIC0gTEFUSVRVREVfRVhURU5UKTtcbiAgICAgICAgcmV0dXJuIDxNZXRhVWk+e1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBlcXVpdkxvYzogPExvY01ldGE+e1xuICAgICAgICAgICAgICAgIGxhdDogKGNhbGNMYXQgPT09IC0wKSA/IDAgOiBjYWxjTGF0LFxuICAgICAgICAgICAgICAgIGxuZzogY2FsY0xvbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNvbnZlcnRzIHRoZSBib3VuZHMgb2YgYSBtYXAgbG9hZGVkIGZyb20gYSBUb3BvR3NvbiBmaWxlIHRoYXQgaGFzIGJlZW5cbiAgICAgKiBjb252ZXJ0ZWQgaW4gdG8gYSBHRU9Kc29uIGZvcm1hdCBieSBkM1xuICAgICAqXG4gICAgICogVGhlIGJvdW5kcyBhcmUgaW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSBmcm9tIGJvdHRvbSBsZWZ0IChtaW4pIHRvIHRvcCByaWdodCAobWF4KVxuICAgICAqXG4gICAgICogRmlyc3QgdGhleSBhcmUgY29udmVydGVkIGluIHRvIFNWRyB2aWV3Ym94IGNvb3JkaW5hdGVzIDAsMCB0b3AgbGVmdCAxMDAweDEwMDBcbiAgICAgKlxuICAgICAqIFRoZSB0aGUgem9vbSBsZXZlbCBpcyBjYWxjdWxhdGVkIGJ5IHNjYWxpbmcgdG8gdGhlIGdyaWQgZGlhZ29uYWxcbiAgICAgKlxuICAgICAqIEZpbmFsbHkgdGhlIHRyYW5zbGF0aW9uIGlzIGNhbGN1bGF0ZWQgYnkgYXBwbHlpbmcgdGhlIHpvb20gZmlyc3QsIGFuZCB0aGVuXG4gICAgICogdHJhbnNsYXRpbmcgb24gdGhlIHpvb21lZCBjb29yZGluYXRlIHN5c3RlbVxuICAgICAqIEBwYXJhbSBtYXBCb3VuZHMgLSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBjaG9zZW4gbWFwIGluIGxhdCBhbmQgbG9uZ1xuICAgICAqIEBwYXJhbSBsb2cgVGhlIExvZ1NlcnZpY2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY29udmVydEJvdW5kc1RvWm9vbUxldmVsKG1hcEJvdW5kczogTWFwQm91bmRzLCBsb2c/OiBMb2dTZXJ2aWNlKTogVG9wb1pvb21QcmVmcyB7XG5cbiAgICAgICAgY29uc3QgbWluOiBNZXRhVWkgPSB0aGlzLmNvbnZlcnRHZW9Ub0NhbnZhcyg8TG9jTWV0YT57XG4gICAgICAgICAgICBsbmc6IG1hcEJvdW5kcy5sbmdNaW4sXG4gICAgICAgICAgICBsYXQ6IG1hcEJvdW5kcy5sYXRNaW5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbWF4OiBNZXRhVWkgPSB0aGlzLmNvbnZlcnRHZW9Ub0NhbnZhcyg8TG9jTWV0YT57XG4gICAgICAgICAgICBsbmc6IG1hcEJvdW5kcy5sbmdNYXgsXG4gICAgICAgICAgICBsYXQ6IG1hcEJvdW5kcy5sYXRNYXhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZGlhZ29uYWwgPSBNYXRoLnNxcnQoTWF0aC5wb3cobWF4LnggLSBtaW4ueCwgMikgKyBNYXRoLnBvdyhtYXgueSAtIG1pbi55LCAyKSk7XG4gICAgICAgIGNvbnN0IGNlbnRyZVggPSAobWF4LnggLSBtaW4ueCkgLyAyICsgbWluLng7XG4gICAgICAgIGNvbnN0IGNlbnRyZVkgPSAobWF4LnkgLSBtaW4ueSkgLyAyICsgbWluLnk7XG4gICAgICAgIC8vIFpvb20gd29ya3MgZnJvbSB0aGUgdG9wIGxlZnQgb2YgdGhlIDEwMDB4MTAwMCB2aWV3Ym94XG4gICAgICAgIC8vIFRoZSBzY2FsZSBpcyBhcHBsaWVkIGZpcnN0IGFuZCB0aGVuIHRoZSB0cmFuc2xhdGUgaXMgb24gdGhlIHNjYWxlZCBjb29yZGluYXRlc1xuICAgICAgICBjb25zdCB6b29tc2NhbGUgPSAwLjUgKiBHUklEX0RJQUdPTkFMIC8gKChkaWFnb25hbCA8IDEwMCkgPyAxMDAgOiBkaWFnb25hbCk7IC8vIERvbid0IGRpdmlkZSBieSB6ZXJvXG4gICAgICAgIGNvbnN0IHpvb214ID0gLWNlbnRyZVggKiB6b29tc2NhbGUgKyBHUklEX0NFTlRSRV9YO1xuICAgICAgICBjb25zdCB6b29teSA9IC1jZW50cmVZICogem9vbXNjYWxlICsgR1JJRF9DRU5UUkVfWTtcblxuICAgICAgICAvLyBsb2cuZGVidWcoJ01hcEJvdW5kcycsIG1hcEJvdW5kcywgJ1hZTWluJywgbWluLCAnWFlNYXgnLCBtYXgsICdEaWFnJywgZGlhZ29uYWwsXG4gICAgICAgIC8vICAgICAnQ2VudHJlJywgY2VudHJlWCwgY2VudHJlWSwgJ3RyYW5zbGF0ZScsIHpvb214LCB6b29teSwgJ1NjYWxlJywgem9vbXNjYWxlKTtcblxuICAgICAgICByZXR1cm4gPFRvcG9ab29tUHJlZnM+e3R4OiB6b29teCwgdHk6IHpvb215LCBzYzogem9vbXNjYWxlfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgWm9vbSBzZXR0aW5ncyB0byBmaXQgdGhlIDEwMDB4MTAwMCBncmlkIGluIHRvIHRoZSBhdmFpbGFibGUgd2luZG93IGhlaWdodFxuICAgICAqIGxlc3MgdGhlIGJhbm5lciBoZWlnaHRcbiAgICAgKlxuICAgICAqIFNjYWxpbmcgYWx3YXlzIGhhcHBlbnMgZnJvbSB0aGUgdG9wIGxlZnQgMCwwXG4gICAgICogSWYgdGhlIGhlaWdodCBpcyBncmVhdGVyIHRoYW4gdGhlIHdpZHRoIHRoZW4gbm8gc2NhbGluZyBpcyByZXF1aXJlZCAtIGdyaWQgd2lsbFxuICAgICAqIG5lZWQgdG8gZmlsbCB0aGUgU1ZHIGNhbnZhc1xuICAgICAqIEBwYXJhbSBiYW5uZXJIZWlnaHQgLSB0aGUgdG9wIGJhbmQgb2YgdGhlIHNjcmVlbiBmb3IgdGhlIG1hc3RcbiAgICAgKiBAcGFyYW0gaW5uZXJXaWR0aCAtIHRoZSBhY3R1YWwgd2lkdGggb2YgdGhlIHNjcmVlblxuICAgICAqIEBwYXJhbSBpbm5lckhlaWdodCAtIHRoZSBhY3R1YWwgaGVpZ2h0IG9mIHRoZSBzY3JlZW5cbiAgICAgKiBAcmV0dXJuIFpvb20gc2V0dGluZ3MgLSBzY2FsZSBhbmQgdHJhbnNsYXRlXG4gICAgICovXG4gICAgc3RhdGljIHpvb21Ub1dpbmRvd1NpemUoYmFubmVySGVpZ2h0OiBudW1iZXIsIGlubmVyV2lkdGg6IG51bWJlciwgaW5uZXJIZWlnaHQ6IG51bWJlcik6IFRvcG9ab29tUHJlZnMge1xuICAgICAgICBjb25zdCBuZXdIZWlnaHQgPSBpbm5lckhlaWdodCAtIGJhbm5lckhlaWdodDtcbiAgICAgICAgaWYgKG5ld0hlaWdodCA+IGlubmVyV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiA8VG9wb1pvb21QcmVmcz57XG4gICAgICAgICAgICAgICAgc2M6IDEuMCxcbiAgICAgICAgICAgICAgICB0eDogMCxcbiAgICAgICAgICAgICAgICB0eTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gbmV3SGVpZ2h0IC8gaW5uZXJXaWR0aDtcbiAgICAgICAgICAgIHJldHVybiA8VG9wb1pvb21QcmVmcz57XG4gICAgICAgICAgICAgICAgc2M6IHNjYWxlLFxuICAgICAgICAgICAgICAgIHR4OiAoNTAwIC8gc2NhbGUgLSA1MDApICogc2NhbGUsXG4gICAgICAgICAgICAgICAgdHk6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=