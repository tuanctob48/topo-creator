/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/*
 * Copyright 2018-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Inject, Injectable } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { LogService } from '../log.service';
import { Trie, TrieOp } from './trie';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "../log.service";
/** @type {?} */
var matcher = /<\/?([a-zA-Z0-9]+)*(.*?)\/?>/igm;
/** @type {?} */
var whitelist = ['b', 'i', 'p', 'em', 'strong', 'br'];
/** @type {?} */
var evillist = ['script', 'style', 'iframe'];
/**
 * Used with the Window size function;
 *
 * @record
 */
export function WindowSize() { }
if (false) {
    /** @type {?} */
    WindowSize.prototype.width;
    /** @type {?} */
    WindowSize.prototype.height;
}
/**
 * For the sanitize() and analyze() functions
 * @record
 */
export function Match() { }
if (false) {
    /** @type {?} */
    Match.prototype.full;
    /** @type {?} */
    Match.prototype.name;
}
/**
 * ONOS GUI -- Util -- General Purpose Functions
 */
var FnService = /** @class */ (function () {
    function FnService(route, log, w) {
        var _this = this;
        this.route = route;
        this.log = log;
        this.w = w;
        // internal state
        this.debugFlags = new Map([
        //        [ "LoadingService", true ]
        ]);
        this.route.queryParams.subscribe(function (params) {
            /** @type {?} */
            var debugparam = params['debug'];
            //            log.debug('Param:', debugparam);
            _this.parseDebugFlags(debugparam);
        });
        //        this.log.debug('FnService constructed');
    }
    /**
     * Test if an argument is a function
     *
     * Note: the need for this would go away if all functions
     * were strongly typed
     */
    /**
     * Test if an argument is a function
     *
     * Note: the need for this would go away if all functions
     * were strongly typed
     * @param {?} f
     * @return {?}
     */
    FnService.prototype.isF = /**
     * Test if an argument is a function
     *
     * Note: the need for this would go away if all functions
     * were strongly typed
     * @param {?} f
     * @return {?}
     */
    function (f) {
        return typeof f === 'function' ? f : null;
    };
    /**
     * Test if an argument is an array
     *
     * Note: the need for this would go away if all arrays
     * were strongly typed
     */
    /**
     * Test if an argument is an array
     *
     * Note: the need for this would go away if all arrays
     * were strongly typed
     * @param {?} a
     * @return {?}
     */
    FnService.prototype.isA = /**
     * Test if an argument is an array
     *
     * Note: the need for this would go away if all arrays
     * were strongly typed
     * @param {?} a
     * @return {?}
     */
    function (a) {
        // NOTE: Array.isArray() is part of EMCAScript 5.1
        return Array.isArray(a) ? a : null;
    };
    /**
     * Test if an argument is a string
     *
     * Note: the need for this would go away if all strings
     * were strongly typed
     */
    /**
     * Test if an argument is a string
     *
     * Note: the need for this would go away if all strings
     * were strongly typed
     * @param {?} s
     * @return {?}
     */
    FnService.prototype.isS = /**
     * Test if an argument is a string
     *
     * Note: the need for this would go away if all strings
     * were strongly typed
     * @param {?} s
     * @return {?}
     */
    function (s) {
        return typeof s === 'string' ? s : null;
    };
    /**
     * Test if an argument is an object
     *
     * Note: the need for this would go away if all objects
     * were strongly typed
     */
    /**
     * Test if an argument is an object
     *
     * Note: the need for this would go away if all objects
     * were strongly typed
     * @param {?} o
     * @return {?}
     */
    FnService.prototype.isO = /**
     * Test if an argument is an object
     *
     * Note: the need for this would go away if all objects
     * were strongly typed
     * @param {?} o
     * @return {?}
     */
    function (o) {
        return (o && typeof o === 'object' && o.constructor === Object) ? o : null;
    };
    /**
     * Test that an array contains an object
     */
    /**
     * Test that an array contains an object
     * @param {?} a
     * @param {?} x
     * @return {?}
     */
    FnService.prototype.contains = /**
     * Test that an array contains an object
     * @param {?} a
     * @param {?} x
     * @return {?}
     */
    function (a, x) {
        return this.isA(a) && a.indexOf(x) > -1;
    };
    /**
     * Returns width and height of window inner dimensions.
     * offH, offW : offset width/height are subtracted, if present
     */
    /**
     * Returns width and height of window inner dimensions.
     * offH, offW : offset width/height are subtracted, if present
     * @param {?=} offH
     * @param {?=} offW
     * @return {?}
     */
    FnService.prototype.windowSize = /**
     * Returns width and height of window inner dimensions.
     * offH, offW : offset width/height are subtracted, if present
     * @param {?=} offH
     * @param {?=} offW
     * @return {?}
     */
    function (offH, offW) {
        if (offH === void 0) { offH = 0; }
        if (offW === void 0) { offW = 0; }
        return {
            height: this.w.innerHeight - offH,
            width: this.w.innerWidth - offW
        };
    };
    /**
     * Returns true if all names in the array are defined as functions
     * on the given api object; false otherwise.
     * Also returns false if there are properties on the api that are NOT
     * listed in the array of names.
     *
     * This gets extra complicated when the api Object is an
     * Angular service - while the functions can be retrieved
     * by an indexed get, the ownProperties does not show the
     * functions of the class. We have to dive in to the prototypes
     * properties to get these - and even then we have to filter
     * out the constructor and any member variables
     */
    /**
     * Returns true if all names in the array are defined as functions
     * on the given api object; false otherwise.
     * Also returns false if there are properties on the api that are NOT
     * listed in the array of names.
     *
     * This gets extra complicated when the api Object is an
     * Angular service - while the functions can be retrieved
     * by an indexed get, the ownProperties does not show the
     * functions of the class. We have to dive in to the prototypes
     * properties to get these - and even then we have to filter
     * out the constructor and any member variables
     * @param {?} api
     * @param {?} fnNames
     * @return {?}
     */
    FnService.prototype.areFunctions = /**
     * Returns true if all names in the array are defined as functions
     * on the given api object; false otherwise.
     * Also returns false if there are properties on the api that are NOT
     * listed in the array of names.
     *
     * This gets extra complicated when the api Object is an
     * Angular service - while the functions can be retrieved
     * by an indexed get, the ownProperties does not show the
     * functions of the class. We have to dive in to the prototypes
     * properties to get these - and even then we have to filter
     * out the constructor and any member variables
     * @param {?} api
     * @param {?} fnNames
     * @return {?}
     */
    function (api, fnNames) {
        /** @type {?} */
        var fnLookup = new Map();
        /** @type {?} */
        var extraFound = false;
        if (!this.isA(fnNames)) {
            return false;
        }
        /** @type {?} */
        var n = fnNames.length;
        /** @type {?} */
        var i;
        /** @type {?} */
        var name;
        for (i = 0; i < n; i++) {
            name = fnNames[i];
            if (!this.isF(api[name])) {
                return false;
            }
            fnLookup.set(name, true);
        }
        // check for properties on the API that are not listed in the array,
        /** @type {?} */
        var keys = Object.getOwnPropertyNames(api);
        if (keys.length === 0) {
            return true;
        }
        // If the api is a class it will have a name,
        //  else it will just be called 'Object'
        /** @type {?} */
        var apiObjectName = api.constructor.name;
        if (apiObjectName === 'Object') {
            Object.keys(api).forEach(function (key) {
                if (!fnLookup.get(key)) {
                    extraFound = true;
                }
            });
        }
        else { // It is a class, so its functions will be in the child (prototype)
            // It is a class, so its functions will be in the child (prototype)
            /** @type {?} */
            var pObj = Object.getPrototypeOf(api);
            for (var key in Object.getOwnPropertyDescriptors(pObj)) {
                if (key === 'constructor') { // Filter out constructor
                    continue;
                }
                /** @type {?} */
                var value = Object.getOwnPropertyDescriptor(pObj, key);
                // Only compare functions. Look for any not given in the map
                if (this.isF(value.value) && !fnLookup.get(key)) {
                    extraFound = true;
                }
            }
        }
        return !extraFound;
    };
    /**
     * Returns true if all names in the array are defined as functions
     * on the given api object; false otherwise. This is a non-strict version
     * that does not care about other properties on the api.
     */
    /**
     * Returns true if all names in the array are defined as functions
     * on the given api object; false otherwise. This is a non-strict version
     * that does not care about other properties on the api.
     * @param {?} api
     * @param {?} fnNames
     * @return {?}
     */
    FnService.prototype.areFunctionsNonStrict = /**
     * Returns true if all names in the array are defined as functions
     * on the given api object; false otherwise. This is a non-strict version
     * that does not care about other properties on the api.
     * @param {?} api
     * @param {?} fnNames
     * @return {?}
     */
    function (api, fnNames) {
        if (!this.isA(fnNames)) {
            return false;
        }
        /** @type {?} */
        var n = fnNames.length;
        /** @type {?} */
        var i;
        /** @type {?} */
        var name;
        for (i = 0; i < n; i++) {
            name = fnNames[i];
            if (!this.isF(api[name])) {
                return false;
            }
        }
        return true;
    };
    /**
     * Returns true if current browser determined to be a mobile device
     */
    /**
     * Returns true if current browser determined to be a mobile device
     * @return {?}
     */
    FnService.prototype.isMobile = /**
     * Returns true if current browser determined to be a mobile device
     * @return {?}
     */
    function () {
        /** @type {?} */
        var ua = this.w.navigator.userAgent;
        /** @type {?} */
        var patt = /iPhone|iPod|iPad|Silk|Android|BlackBerry|Opera Mini|IEMobile/;
        return patt.test(ua);
    };
    /**
     * Returns true if the current browser determined to be Chrome
     */
    /**
     * Returns true if the current browser determined to be Chrome
     * @return {?}
     */
    FnService.prototype.isChrome = /**
     * Returns true if the current browser determined to be Chrome
     * @return {?}
     */
    function () {
        /** @type {?} */
        var isChromium = ((/** @type {?} */ (this.w))).chrome;
        /** @type {?} */
        var vendorName = this.w.navigator.vendor;
        /** @type {?} */
        var isOpera = this.w.navigator.userAgent.indexOf('OPR') > -1;
        return (isChromium !== null &&
            isChromium !== undefined &&
            vendorName === 'Google Inc.' &&
            isOpera === false);
    };
    /**
     * @return {?}
     */
    FnService.prototype.isChromeHeadless = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var vendorName = this.w.navigator.vendor;
        /** @type {?} */
        var headlessChrome = this.w.navigator.userAgent.indexOf('HeadlessChrome') > -1;
        return (vendorName === 'Google Inc.' && headlessChrome === true);
    };
    /**
     * Returns true if the current browser determined to be Safari
     */
    /**
     * Returns true if the current browser determined to be Safari
     * @return {?}
     */
    FnService.prototype.isSafari = /**
     * Returns true if the current browser determined to be Safari
     * @return {?}
     */
    function () {
        return (this.w.navigator.userAgent.indexOf('Safari') !== -1 &&
            this.w.navigator.userAgent.indexOf('Chrome') === -1);
    };
    /**
     * Returns true if the current browser determined to be Firefox
     */
    /**
     * Returns true if the current browser determined to be Firefox
     * @return {?}
     */
    FnService.prototype.isFirefox = /**
     * Returns true if the current browser determined to be Firefox
     * @return {?}
     */
    function () {
        return typeof InstallTrigger !== 'undefined';
    };
    /**
     * search through an array of objects, looking for the one with the
     * tagged property matching the given key. tag defaults to 'id'.
     * returns the index of the matching object, or -1 for no match.
     */
    /**
     * search through an array of objects, looking for the one with the
     * tagged property matching the given key. tag defaults to 'id'.
     * returns the index of the matching object, or -1 for no match.
     * @param {?} key
     * @param {?} array
     * @param {?=} tag
     * @return {?}
     */
    FnService.prototype.find = /**
     * search through an array of objects, looking for the one with the
     * tagged property matching the given key. tag defaults to 'id'.
     * returns the index of the matching object, or -1 for no match.
     * @param {?} key
     * @param {?} array
     * @param {?=} tag
     * @return {?}
     */
    function (key, array, tag) {
        if (tag === void 0) { tag = 'id'; }
        /** @type {?} */
        var idx;
        /** @type {?} */
        var n = array.length;
        for (idx = 0; idx < n; idx++) {
            /** @type {?} */
            var d = array[idx];
            if (d[tag] === key) {
                return idx;
            }
        }
        return -1;
    };
    /**
     * search through array to find (the first occurrence of) item,
     * returning its index if found; otherwise returning -1.
     */
    /**
     * search through array to find (the first occurrence of) item,
     * returning its index if found; otherwise returning -1.
     * @param {?} item
     * @param {?} array
     * @return {?}
     */
    FnService.prototype.inArray = /**
     * search through array to find (the first occurrence of) item,
     * returning its index if found; otherwise returning -1.
     * @param {?} item
     * @param {?} array
     * @return {?}
     */
    function (item, array) {
        if (this.isA(array)) {
            for (var i = 0; i < array.length; i++) {
                if (array[i] === item) {
                    return i;
                }
            }
        }
        return -1;
    };
    /**
     * remove (the first occurrence of) the specified item from the given
     * array, if any. Return true if the removal was made; false otherwise.
     */
    /**
     * remove (the first occurrence of) the specified item from the given
     * array, if any. Return true if the removal was made; false otherwise.
     * @param {?} item
     * @param {?} array
     * @return {?}
     */
    FnService.prototype.removeFromArray = /**
     * remove (the first occurrence of) the specified item from the given
     * array, if any. Return true if the removal was made; false otherwise.
     * @param {?} item
     * @param {?} array
     * @return {?}
     */
    function (item, array) {
        /** @type {?} */
        var i = this.inArray(item, array);
        if (i >= 0) {
            array.splice(i, 1);
            return true;
        }
        return false;
    };
    /**
     * return true if the object is empty, return false otherwise
     */
    /**
     * return true if the object is empty, return false otherwise
     * @param {?} obj
     * @return {?}
     */
    FnService.prototype.isEmptyObject = /**
     * return true if the object is empty, return false otherwise
     * @param {?} obj
     * @return {?}
     */
    function (obj) {
        for (var key in obj) {
            if (true) {
                return false;
            }
        }
        return true;
    };
    /**
     * returns true if the two objects have all the same properties
     */
    /**
     * returns true if the two objects have all the same properties
     * @param {?} obj1
     * @param {?} obj2
     * @return {?}
     */
    FnService.prototype.sameObjProps = /**
     * returns true if the two objects have all the same properties
     * @param {?} obj1
     * @param {?} obj2
     * @return {?}
     */
    function (obj1, obj2) {
        for (var key in obj1) {
            if (obj1.hasOwnProperty(key)) {
                if (!(obj1[key] === obj2[key])) {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * returns true if the array contains the object
     * does NOT use strict object reference equality,
     * instead checks each property individually for equality
     */
    /**
     * returns true if the array contains the object
     * does NOT use strict object reference equality,
     * instead checks each property individually for equality
     * @param {?} arr
     * @param {?} obj
     * @return {?}
     */
    FnService.prototype.containsObj = /**
     * returns true if the array contains the object
     * does NOT use strict object reference equality,
     * instead checks each property individually for equality
     * @param {?} arr
     * @param {?} obj
     * @return {?}
     */
    function (arr, obj) {
        /** @type {?} */
        var len = arr.length;
        for (var i = 0; i < len; i++) {
            if (this.sameObjProps(arr[i], obj)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Return the given string with the first character capitalized.
     */
    /**
     * Return the given string with the first character capitalized.
     * @param {?} s
     * @return {?}
     */
    FnService.prototype.cap = /**
     * Return the given string with the first character capitalized.
     * @param {?} s
     * @return {?}
     */
    function (s) {
        return s ? s[0].toUpperCase() + s.slice(1).toLowerCase() : s;
    };
    /**
     * return the parameter without a px suffix
     */
    /**
     * return the parameter without a px suffix
     * @param {?} num
     * @return {?}
     */
    FnService.prototype.noPx = /**
     * return the parameter without a px suffix
     * @param {?} num
     * @return {?}
     */
    function (num) {
        return Number(num.replace(/px$/, ''));
    };
    /**
     * return an element's given style property without px suffix
     */
    /**
     * return an element's given style property without px suffix
     * @param {?} elem
     * @param {?} prop
     * @return {?}
     */
    FnService.prototype.noPxStyle = /**
     * return an element's given style property without px suffix
     * @param {?} elem
     * @param {?} prop
     * @return {?}
     */
    function (elem, prop) {
        return Number(elem.style(prop).replace(/px$/, ''));
    };
    /**
     * Return true if a str ends with suffix
     */
    /**
     * Return true if a str ends with suffix
     * @param {?} str
     * @param {?} suffix
     * @return {?}
     */
    FnService.prototype.endsWith = /**
     * Return true if a str ends with suffix
     * @param {?} str
     * @param {?} suffix
     * @return {?}
     */
    function (str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    };
    /**
     * output debug message to console, if debug tag set...
     * e.g. fs.debug('mytag', arg1, arg2, ...)
     */
    /**
     * output debug message to console, if debug tag set...
     * e.g. fs.debug('mytag', arg1, arg2, ...)
     * @param {?} tag
     * @param {...?} args
     * @return {?}
     */
    FnService.prototype.debug = /**
     * output debug message to console, if debug tag set...
     * e.g. fs.debug('mytag', arg1, arg2, ...)
     * @param {?} tag
     * @param {...?} args
     * @return {?}
     */
    function (tag) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.debugFlags.get(tag)) {
            //            this.log.debug(tag, args.join());
        }
    };
    /**
     * @param {?} dbgstr
     * @return {?}
     */
    FnService.prototype.parseDebugFlags = /**
     * @param {?} dbgstr
     * @return {?}
     */
    function (dbgstr) {
        var _this = this;
        /** @type {?} */
        var bits = dbgstr ? dbgstr.split(',') : [];
        bits.forEach(function (key) {
            _this.debugFlags.set(key, true);
        });
        //        this.log.debug('Debug flags:', dbgstr);
    };
    /**
      * Return true if the given debug flag was specified in the query params
      */
    /**
     * Return true if the given debug flag was specified in the query params
     * @param {?} tag
     * @return {?}
     */
    FnService.prototype.debugOn = /**
     * Return true if the given debug flag was specified in the query params
     * @param {?} tag
     * @return {?}
     */
    function (tag) {
        return this.debugFlags.get(tag);
    };
    // -----------------------------------------------------------------
    // The next section deals with sanitizing external strings destined
    // to be loaded via a .html() function call.
    //
    // See definition of matcher, evillist and whitelist at the top of this file
    /*
     * Returns true if the tag is in the evil list, (and is not an end-tag)
     */
    // -----------------------------------------------------------------
    // The next section deals with sanitizing external strings destined
    // to be loaded via a .html() function call.
    //
    // See definition of matcher, evillist and whitelist at the top of this file
    /*
         * Returns true if the tag is in the evil list, (and is not an end-tag)
         */
    /**
     * @param {?} tag
     * @return {?}
     */
    FnService.prototype.inEvilList = 
    // -----------------------------------------------------------------
    // The next section deals with sanitizing external strings destined
    // to be loaded via a .html() function call.
    //
    // See definition of matcher, evillist and whitelist at the top of this file
    /*
         * Returns true if the tag is in the evil list, (and is not an end-tag)
         */
    /**
     * @param {?} tag
     * @return {?}
     */
    function (tag) {
        return (evillist.indexOf(tag.name) !== -1 && tag.full.indexOf('/') === -1);
    };
    /*
     * Returns an array of Matches of matcher in html
     */
    /*
         * Returns an array of Matches of matcher in html
         */
    /**
     * @param {?} html
     * @return {?}
     */
    FnService.prototype.analyze = /*
         * Returns an array of Matches of matcher in html
         */
    /**
     * @param {?} html
     * @return {?}
     */
    function (html) {
        /** @type {?} */
        var matches = [];
        /** @type {?} */
        var match;
        // extract all tags
        while ((match = matcher.exec(html)) !== null) {
            matches.push({
                full: match[0],
                name: match[1],
            });
        }
        return matches;
    };
    /*
     * Returns a cleaned version of html
     */
    /*
         * Returns a cleaned version of html
         */
    /**
     * @param {?} html
     * @return {?}
     */
    FnService.prototype.sanitize = /*
         * Returns a cleaned version of html
         */
    /**
     * @param {?} html
     * @return {?}
     */
    function (html) {
        var _this = this;
        /** @type {?} */
        var matches = this.analyze(html);
        // completely obliterate evil tags and their contents...
        evillist.forEach(function (tag) {
            /** @type {?} */
            var re = new RegExp('<' + tag + '(.*?)>(.*?[\r\n])*?(.*?)(.*?[\r\n])*?<\/' + tag + '>', 'gim');
            html = html.replace(re, '');
        });
        // filter out all but white-listed tags and end-tags
        matches.forEach(function (tag) {
            if (whitelist.indexOf(tag.name) === -1) {
                html = html.replace(tag.full, '');
                if (_this.inEvilList(tag)) {
                    _this.log.warn('Unsanitary HTML input -- ' +
                        tag.full + ' detected!');
                }
            }
        });
        // TODO: consider encoding HTML entities, e.g. '&' -> '&amp;'
        return html;
    };
    /**
     * add word to trie (word will be converted to uppercase)
     * data associated with the word
     * returns 'added' or 'updated'
     */
    /**
     * add word to trie (word will be converted to uppercase)
     * data associated with the word
     * returns 'added' or 'updated'
     * @param {?} trie
     * @param {?} word
     * @param {?} data
     * @return {?}
     */
    FnService.prototype.addToTrie = /**
     * add word to trie (word will be converted to uppercase)
     * data associated with the word
     * returns 'added' or 'updated'
     * @param {?} trie
     * @param {?} word
     * @param {?} data
     * @return {?}
     */
    function (trie, word, data) {
        return new Trie(TrieOp.PLUS, trie, word, data);
    };
    /**
     * remove word from trie (word will be converted to uppercase)
     * returns 'removed' or 'absent'
     */
    /**
     * remove word from trie (word will be converted to uppercase)
     * returns 'removed' or 'absent'
     * @param {?} trie
     * @param {?} word
     * @return {?}
     */
    FnService.prototype.removeFromTrie = /**
     * remove word from trie (word will be converted to uppercase)
     * returns 'removed' or 'absent'
     * @param {?} trie
     * @param {?} word
     * @return {?}
     */
    function (trie, word) {
        return new Trie(TrieOp.MINUS, trie, word);
    };
    /**
     * lookup word (converted to uppercase) in trie
     * returns:
     *    undefined if the word is not in the trie
     *    -1 for a partial match (word is a prefix to an existing word)
     *    data for the word for an exact match
     */
    /**
     * lookup word (converted to uppercase) in trie
     * returns:
     *    undefined if the word is not in the trie
     *    -1 for a partial match (word is a prefix to an existing word)
     *    data for the word for an exact match
     * @param {?} trie
     * @param {?} word
     * @return {?}
     */
    FnService.prototype.trieLookup = /**
     * lookup word (converted to uppercase) in trie
     * returns:
     *    undefined if the word is not in the trie
     *    -1 for a partial match (word is a prefix to an existing word)
     *    data for the word for an exact match
     * @param {?} trie
     * @param {?} word
     * @return {?}
     */
    function (trie, word) {
        /** @type {?} */
        var s = word.toUpperCase().split('');
        /** @type {?} */
        var p = trie;
        /** @type {?} */
        var n;
        while (s.length) {
            n = s.shift();
            p = p[n];
            if (!p) {
                return undefined;
            }
        }
        if (p._data) {
            return p._data;
        }
        return -1;
    };
    FnService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] },
    ];
    /** @nocollapse */
    FnService.ctorParameters = function () { return [
        { type: ActivatedRoute },
        { type: LogService },
        { type: undefined, decorators: [{ type: Inject, args: ['Window',] }] }
    ]; };
    /** @nocollapse */ FnService.ngInjectableDef = i0.defineInjectable({ factory: function FnService_Factory() { return new FnService(i0.inject(i1.ActivatedRoute), i0.inject(i2.LogService), i0.inject("Window")); }, token: FnService, providedIn: "root" });
    return FnService;
}());
export { FnService };
if (false) {
    /** @type {?} */
    FnService.prototype.debugFlags;
    /** @type {?} */
    FnService.prototype.route;
    /** @type {?} */
    FnService.prototype.log;
    /** @type {?} */
    FnService.prototype.w;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm4uc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2d1aTItZnctbGliLyIsInNvdXJjZXMiOlsibGliL3V0aWwvZm4uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsT0FBTyxFQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDakQsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUMxQyxPQUFPLEVBQUMsSUFBSSxFQUFFLE1BQU0sRUFBQyxNQUFNLFFBQVEsQ0FBQzs7Ozs7SUFLOUIsT0FBTyxHQUFHLGlDQUFpQzs7SUFDM0MsU0FBUyxHQUFhLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUM7O0lBQzNELFFBQVEsR0FBYSxDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsUUFBUSxDQUFDOzs7Ozs7QUFLeEQsZ0NBR0M7OztJQUZHLDJCQUFjOztJQUNkLDRCQUFlOzs7Ozs7QUFNbkIsMkJBR0M7OztJQUZHLHFCQUFhOztJQUNiLHFCQUFhOzs7OztBQU1qQjtJQVNJLG1CQUNZLEtBQXFCLEVBQ3JCLEdBQWUsRUFFRyxDQUFNO1FBSnBDLGlCQVlDO1FBWFcsVUFBSyxHQUFMLEtBQUssQ0FBZ0I7UUFDckIsUUFBRyxHQUFILEdBQUcsQ0FBWTtRQUVHLE1BQUMsR0FBRCxDQUFDLENBQUs7O1FBUjVCLGVBQVUsR0FBRyxJQUFJLEdBQUcsQ0FBa0I7UUFDbEQsb0NBQW9DO1NBQy9CLENBQUMsQ0FBQztRQVFDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxVQUFBLE1BQU07O2dCQUM3QixVQUFVLEdBQVcsTUFBTSxDQUFDLE9BQU8sQ0FBQztZQUN0RCw4Q0FBOEM7WUFDbEMsS0FBSSxDQUFD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ZCxVQUFVO2dEQTBDVCxNQUFNLFNBQUMsUUFBUTs7O29CQTNEeEI7Q0FvZkMsQUF0Y0QsSUFzY0M7U0FuY1ksU0FBUzs7O0lBRWxCLCtCQUVHOztJQUdDLDBCQUE2Qjs7SUFDN0Isd0JBQXVCOztJQUV2QixzQkFBZ0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMTgtcHJlc2VudCBPcGVuIE5ldHdvcmtpbmcgRm91bmRhdGlvblxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHtJbmplY3QsIEluamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtBY3RpdmF0ZWRSb3V0ZX0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7TG9nU2VydmljZX0gZnJvbSAnLi4vbG9nLnNlcnZpY2UnO1xuaW1wb3J0IHtUcmllLCBUcmllT3B9IGZyb20gJy4vdHJpZSc7XG5cbi8vIEFuZ3VsYXI+PTIgd29ya2Fyb3VuZCBmb3IgbWlzc2luZyBkZWZpbml0aW9uXG5kZWNsYXJlIGNvbnN0IEluc3RhbGxUcmlnZ2VyOiBhbnk7XG5cbmNvbnN0IG1hdGNoZXIgPSAvPFxcLz8oW2EtekEtWjAtOV0rKSooLio/KVxcLz8+L2lnbTtcbmNvbnN0IHdoaXRlbGlzdDogc3RyaW5nW10gPSBbJ2InLCAnaScsICdwJywgJ2VtJywgJ3N0cm9uZycsICdiciddO1xuY29uc3QgZXZpbGxpc3Q6IHN0cmluZ1tdID0gWydzY3JpcHQnLCAnc3R5bGUnLCAnaWZyYW1lJ107XG5cbi8qKlxuICogVXNlZCB3aXRoIHRoZSBXaW5kb3cgc2l6ZSBmdW5jdGlvbjtcbiAqKi9cbmV4cG9ydCBpbnRlcmZhY2UgV2luZG93U2l6ZSB7XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBGb3IgdGhlIHNhbml0aXplKCkgYW5kIGFuYWx5emUoKSBmdW5jdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYXRjaCB7XG4gICAgZnVsbDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBPTk9TIEdVSSAtLSBVdGlsIC0tIEdlbmVyYWwgUHVycG9zZSBGdW5jdGlvbnNcbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIEZuU2VydmljZSB7XG4gICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICBwcml2YXRlIGRlYnVnRmxhZ3MgPSBuZXcgTWFwPHN0cmluZywgYm9vbGVhbj4oW1xuLy8gICAgICAgIFsgXCJMb2FkaW5nU2VydmljZVwiLCB0cnVlIF1cbiAgICBdKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZSxcbiAgICAgICAgcHJpdmF0ZSBsb2c6IExvZ1NlcnZpY2UsXG4gICAgICAgIC8vIFRPRE86IENoYW5nZSB0aGUgYW55IHR5cGUgdG8gV2luZG93IHdoZW4gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTU2NDAgaXMgZml4ZWQuXG4gICAgICAgIEBJbmplY3QoJ1dpbmRvdycpIHByaXZhdGUgdzogYW55XG4gICAgKSB7XG4gICAgICAgIHRoaXMucm91dGUucXVlcnlQYXJhbXMuc3Vic2NyaWJlKHBhcmFtcyA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWJ1Z3BhcmFtOiBzdHJpbmcgPSBwYXJhbXNbJ2RlYnVnJ107XG4vLyAgICAgICAgICAgIGxvZy5kZWJ1ZygnUGFyYW06JywgZGVidWdwYXJhbSk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlRGVidWdGbGFncyhkZWJ1Z3BhcmFtKTtcbiAgICAgICAgfSk7XG4vLyAgICAgICAgdGhpcy5sb2cuZGVidWcoJ0ZuU2VydmljZSBjb25zdHJ1Y3RlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgYW4gYXJndW1lbnQgaXMgYSBmdW5jdGlvblxuICAgICAqXG4gICAgICogTm90ZTogdGhlIG5lZWQgZm9yIHRoaXMgd291bGQgZ28gYXdheSBpZiBhbGwgZnVuY3Rpb25zXG4gICAgICogd2VyZSBzdHJvbmdseSB0eXBlZFxuICAgICAqL1xuICAgIGlzRihmOiBhbnkpOiBhbnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGYgPT09ICdmdW5jdGlvbicgPyBmIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIGFuIGFyZ3VtZW50IGlzIGFuIGFycmF5XG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGUgbmVlZCBmb3IgdGhpcyB3b3VsZCBnbyBhd2F5IGlmIGFsbCBhcnJheXNcbiAgICAgKiB3ZXJlIHN0cm9uZ2x5IHR5cGVkXG4gICAgICovXG4gICAgaXNBKGE6IGFueSk6IGFueSB7XG4gICAgLy8gTk9URTogQXJyYXkuaXNBcnJheSgpIGlzIHBhcnQgb2YgRU1DQVNjcmlwdCA1LjFcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYSkgPyBhIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIGFuIGFyZ3VtZW50IGlzIGEgc3RyaW5nXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGUgbmVlZCBmb3IgdGhpcyB3b3VsZCBnbyBhd2F5IGlmIGFsbCBzdHJpbmdzXG4gICAgICogd2VyZSBzdHJvbmdseSB0eXBlZFxuICAgICAqL1xuICAgIGlzUyhzOiBhbnkpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHMgPT09ICdzdHJpbmcnID8gcyA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBhbiBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAgICAgKlxuICAgICAqIE5vdGU6IHRoZSBuZWVkIGZvciB0aGlzIHdvdWxkIGdvIGF3YXkgaWYgYWxsIG9iamVjdHNcbiAgICAgKiB3ZXJlIHN0cm9uZ2x5IHR5cGVkXG4gICAgICovXG4gICAgaXNPKG86IGFueSk6IE9iamVjdCB7XG4gICAgICAgIHJldHVybiAobyAmJiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgby5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSA/IG8gOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3QgdGhhdCBhbiBhcnJheSBjb250YWlucyBhbiBvYmplY3RcbiAgICAgKi9cbiAgICBjb250YWlucyhhOiBhbnlbXSwgeDogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQShhKSAmJiBhLmluZGV4T2YoeCkgPiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdpZHRoIGFuZCBoZWlnaHQgb2Ygd2luZG93IGlubmVyIGRpbWVuc2lvbnMuXG4gICAgICogb2ZmSCwgb2ZmVyA6IG9mZnNldCB3aWR0aC9oZWlnaHQgYXJlIHN1YnRyYWN0ZWQsIGlmIHByZXNlbnRcbiAgICAgKi9cbiAgICB3aW5kb3dTaXplKG9mZkg6IG51bWJlciA9IDAsIG9mZlc6IG51bWJlciA9IDApOiBXaW5kb3dTaXplIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy53LmlubmVySGVpZ2h0IC0gb2ZmSCxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLncuaW5uZXJXaWR0aCAtIG9mZldcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYWxsIG5hbWVzIGluIHRoZSBhcnJheSBhcmUgZGVmaW5lZCBhcyBmdW5jdGlvbnNcbiAgICAgKiBvbiB0aGUgZ2l2ZW4gYXBpIG9iamVjdDsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEFsc28gcmV0dXJucyBmYWxzZSBpZiB0aGVyZSBhcmUgcHJvcGVydGllcyBvbiB0aGUgYXBpIHRoYXQgYXJlIE5PVFxuICAgICAqIGxpc3RlZCBpbiB0aGUgYXJyYXkgb2YgbmFtZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIGdldHMgZXh0cmEgY29tcGxpY2F0ZWQgd2hlbiB0aGUgYXBpIE9iamVjdCBpcyBhblxuICAgICAqIEFuZ3VsYXIgc2VydmljZSAtIHdoaWxlIHRoZSBmdW5jdGlvbnMgY2FuIGJlIHJldHJpZXZlZFxuICAgICAqIGJ5IGFuIGluZGV4ZWQgZ2V0LCB0aGUgb3duUHJvcGVydGllcyBkb2VzIG5vdCBzaG93IHRoZVxuICAgICAqIGZ1bmN0aW9ucyBvZiB0aGUgY2xhc3MuIFdlIGhhdmUgdG8gZGl2ZSBpbiB0byB0aGUgcHJvdG90eXBlc1xuICAgICAqIHByb3BlcnRpZXMgdG8gZ2V0IHRoZXNlIC0gYW5kIGV2ZW4gdGhlbiB3ZSBoYXZlIHRvIGZpbHRlclxuICAgICAqIG91dCB0aGUgY29uc3RydWN0b3IgYW5kIGFueSBtZW1iZXIgdmFyaWFibGVzXG4gICAgICovXG4gICAgYXJlRnVuY3Rpb25zKGFwaTogT2JqZWN0LCBmbk5hbWVzOiBzdHJpbmdbXSk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBmbkxvb2t1cDogTWFwPHN0cmluZywgYm9vbGVhbj4gPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBleHRyYUZvdW5kOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQShmbk5hbWVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbjogbnVtYmVyID0gZm5OYW1lcy5sZW5ndGg7XG4gICAgICAgIGxldCBpOiBudW1iZXI7XG4gICAgICAgIGxldCBuYW1lOiBzdHJpbmc7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbmFtZSA9IGZuTmFtZXNbaV07XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNGKGFwaVtuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbkxvb2t1cC5zZXQobmFtZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgcHJvcGVydGllcyBvbiB0aGUgQVBJIHRoYXQgYXJlIG5vdCBsaXN0ZWQgaW4gdGhlIGFycmF5LFxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXBpKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgYXBpIGlzIGEgY2xhc3MgaXQgd2lsbCBoYXZlIGEgbmFtZSxcbiAgICAgICAgLy8gIGVsc2UgaXQgd2lsbCBqdXN0IGJlIGNhbGxlZCAnT2JqZWN0J1xuICAgICAgICBjb25zdCBhcGlPYmplY3ROYW1lOiBzdHJpbmcgPSBhcGkuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgaWYgKGFwaU9iamVjdE5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhcGkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZm5Mb29rdXAuZ2V0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7IC8vIEl0IGlzIGEgY2xhc3MsIHNvIGl0cyBmdW5jdGlvbnMgd2lsbCBiZSBpbiB0aGUgY2hpbGQgKHByb3RvdHlwZSlcbiAgICAgICAgICAgIGNvbnN0IHBPYmo6IE9iamVjdCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhcGkpO1xuICAgICAgICAgICAgZm9yICggY29uc3Qga2V5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHBPYmopICkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicpIHsgLy8gRmlsdGVyIG91dCBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBPYmosIGtleSk7XG4gICAgICAgICAgICAgICAgLy8gT25seSBjb21wYXJlIGZ1bmN0aW9ucy4gTG9vayBmb3IgYW55IG5vdCBnaXZlbiBpbiB0aGUgbWFwXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNGKHZhbHVlLnZhbHVlKSAmJiAhZm5Mb29rdXAuZ2V0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhZXh0cmFGb3VuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYWxsIG5hbWVzIGluIHRoZSBhcnJheSBhcmUgZGVmaW5lZCBhcyBmdW5jdGlvbnNcbiAgICAgKiBvbiB0aGUgZ2l2ZW4gYXBpIG9iamVjdDsgZmFsc2Ugb3RoZXJ3aXNlLiBUaGlzIGlzIGEgbm9uLXN0cmljdCB2ZXJzaW9uXG4gICAgICogdGhhdCBkb2VzIG5vdCBjYXJlIGFib3V0IG90aGVyIHByb3BlcnRpZXMgb24gdGhlIGFwaS5cbiAgICAgKi9cbiAgICBhcmVGdW5jdGlvbnNOb25TdHJpY3QoYXBpLCBmbk5hbWVzKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghdGhpcy5pc0EoZm5OYW1lcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuID0gZm5OYW1lcy5sZW5ndGg7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbmFtZTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBuYW1lID0gZm5OYW1lc1tpXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0YoYXBpW25hbWVdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgY3VycmVudCBicm93c2VyIGRldGVybWluZWQgdG8gYmUgYSBtb2JpbGUgZGV2aWNlXG4gICAgICovXG4gICAgaXNNb2JpbGUoKSB7XG4gICAgICAgIGNvbnN0IHVhID0gdGhpcy53Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgICAgIGNvbnN0IHBhdHQgPSAvaVBob25lfGlQb2R8aVBhZHxTaWxrfEFuZHJvaWR8QmxhY2tCZXJyeXxPcGVyYSBNaW5pfElFTW9iaWxlLztcbiAgICAgICAgcmV0dXJuIHBhdHQudGVzdCh1YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IGJyb3dzZXIgZGV0ZXJtaW5lZCB0byBiZSBDaHJvbWVcbiAgICAgKi9cbiAgICBpc0Nocm9tZSgpIHtcbiAgICAgICAgY29uc3QgaXNDaHJvbWl1bSA9ICh0aGlzLncgYXMgYW55KS5jaHJvbWU7XG4gICAgICAgIGNvbnN0IHZlbmRvck5hbWUgPSB0aGlzLncubmF2aWdhdG9yLnZlbmRvcjtcblxuICAgICAgICBjb25zdCBpc09wZXJhID0gdGhpcy53Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignT1BSJykgPiAtMTtcbiAgICAgICAgcmV0dXJuIChpc0Nocm9taXVtICE9PSBudWxsICYmXG4gICAgICAgIGlzQ2hyb21pdW0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB2ZW5kb3JOYW1lID09PSAnR29vZ2xlIEluYy4nICYmXG4gICAgICAgIGlzT3BlcmEgPT09IGZhbHNlKTtcbiAgICB9XG5cbiAgICBpc0Nocm9tZUhlYWRsZXNzKCkge1xuICAgICAgICBjb25zdCB2ZW5kb3JOYW1lID0gdGhpcy53Lm5hdmlnYXRvci52ZW5kb3I7XG4gICAgICAgIGNvbnN0IGhlYWRsZXNzQ2hyb21lID0gdGhpcy53Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignSGVhZGxlc3NDaHJvbWUnKSA+IC0xO1xuXG4gICAgICAgIHJldHVybiAodmVuZG9yTmFtZSA9PT0gJ0dvb2dsZSBJbmMuJyAmJiBoZWFkbGVzc0Nocm9tZSA9PT0gdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IGJyb3dzZXIgZGV0ZXJtaW5lZCB0byBiZSBTYWZhcmlcbiAgICAgKi9cbiAgICBpc1NhZmFyaSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLncubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdTYWZhcmknKSAhPT0gLTEgJiZcbiAgICAgICAgdGhpcy53Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPT09IC0xKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgYnJvd3NlciBkZXRlcm1pbmVkIHRvIGJlIEZpcmVmb3hcbiAgICAgKi9cbiAgICBpc0ZpcmVmb3goKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNlYXJjaCB0aHJvdWdoIGFuIGFycmF5IG9mIG9iamVjdHMsIGxvb2tpbmcgZm9yIHRoZSBvbmUgd2l0aCB0aGVcbiAgICAgKiB0YWdnZWQgcHJvcGVydHkgbWF0Y2hpbmcgdGhlIGdpdmVuIGtleS4gdGFnIGRlZmF1bHRzIHRvICdpZCcuXG4gICAgICogcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIG9iamVjdCwgb3IgLTEgZm9yIG5vIG1hdGNoLlxuICAgICAqL1xuICAgIGZpbmQoa2V5OiBzdHJpbmcsIGFycmF5OiBPYmplY3RbXSwgdGFnOiBzdHJpbmcgPSAnaWQnKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGlkeDogbnVtYmVyO1xuICAgICAgICBjb25zdCBuOiBudW1iZXIgPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpZHggPSAwIDsgaWR4IDwgbjsgaWR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGQ6IE9iamVjdCA9IGFycmF5W2lkeF07XG4gICAgICAgICAgICBpZiAoZFt0YWddID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWFyY2ggdGhyb3VnaCBhcnJheSB0byBmaW5kICh0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZikgaXRlbSxcbiAgICAgKiByZXR1cm5pbmcgaXRzIGluZGV4IGlmIGZvdW5kOyBvdGhlcndpc2UgcmV0dXJuaW5nIC0xLlxuICAgICAqL1xuICAgIGluQXJyYXkoaXRlbTogYW55LCBhcnJheTogYW55W10pOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5pc0EoYXJyYXkpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycmF5W2ldID09PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlICh0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZikgdGhlIHNwZWNpZmllZCBpdGVtIGZyb20gdGhlIGdpdmVuXG4gICAgICogYXJyYXksIGlmIGFueS4gUmV0dXJuIHRydWUgaWYgdGhlIHJlbW92YWwgd2FzIG1hZGU7IGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICByZW1vdmVGcm9tQXJyYXkoaXRlbTogYW55LCBhcnJheTogYW55W10pOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgaTogbnVtYmVyID0gdGhpcy5pbkFycmF5KGl0ZW0sIGFycmF5KTtcbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0cnVlIGlmIHRoZSBvYmplY3QgaXMgZW1wdHksIHJldHVybiBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBpc0VtcHR5T2JqZWN0KG9iajogT2JqZWN0KTogYm9vbGVhbiB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0cnVlIGlmIHRoZSB0d28gb2JqZWN0cyBoYXZlIGFsbCB0aGUgc2FtZSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgc2FtZU9ialByb3BzKG9iajE6IE9iamVjdCwgb2JqMjogT2JqZWN0KTogYm9vbGVhbiB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iajEpIHtcbiAgICAgICAgICAgIGlmIChvYmoxLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShvYmoxW2tleV0gPT09IG9iajJba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRydWUgaWYgdGhlIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3RcbiAgICAgKiBkb2VzIE5PVCB1c2Ugc3RyaWN0IG9iamVjdCByZWZlcmVuY2UgZXF1YWxpdHksXG4gICAgICogaW5zdGVhZCBjaGVja3MgZWFjaCBwcm9wZXJ0eSBpbmRpdmlkdWFsbHkgZm9yIGVxdWFsaXR5XG4gICAgICovXG4gICAgY29udGFpbnNPYmooYXJyOiBhbnlbXSwgb2JqOiBPYmplY3QpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2FtZU9ialByb3BzKGFycltpXSwgb2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGdpdmVuIHN0cmluZyB3aXRoIHRoZSBmaXJzdCBjaGFyYWN0ZXIgY2FwaXRhbGl6ZWQuXG4gICAgICovXG4gICAgY2FwKHM6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBzID8gc1swXS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKS50b0xvd2VyQ2FzZSgpIDogcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHBhcmFtZXRlciB3aXRob3V0IGEgcHggc3VmZml4XG4gICAgICovXG4gICAgbm9QeChudW06IHN0cmluZyk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBOdW1iZXIobnVtLnJlcGxhY2UoL3B4JC8sICcnKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGFuIGVsZW1lbnQncyBnaXZlbiBzdHlsZSBwcm9wZXJ0eSB3aXRob3V0IHB4IHN1ZmZpeFxuICAgICAqL1xuICAgIG5vUHhTdHlsZShlbGVtOiBhbnksIHByb3A6IHN0cmluZyk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBOdW1iZXIoZWxlbS5zdHlsZShwcm9wKS5yZXBsYWNlKC9weCQvLCAnJykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIGEgc3RyIGVuZHMgd2l0aCBzdWZmaXhcbiAgICAgKi9cbiAgICBlbmRzV2l0aChzdHI6IHN0cmluZywgc3VmZml4OiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKHN1ZmZpeCwgc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBvdXRwdXQgZGVidWcgbWVzc2FnZSB0byBjb25zb2xlLCBpZiBkZWJ1ZyB0YWcgc2V0Li4uXG4gICAgICogZS5nLiBmcy5kZWJ1ZygnbXl0YWcnLCBhcmcxLCBhcmcyLCAuLi4pXG4gICAgICovXG4gICAgZGVidWcodGFnLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnRmxhZ3MuZ2V0KHRhZykpIHtcbi8vICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcodGFnLCBhcmdzLmpvaW4oKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHBhcnNlRGVidWdGbGFncyhkYmdzdHI6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBiaXRzID0gZGJnc3RyID8gZGJnc3RyLnNwbGl0KCcsJykgOiBbXTtcbiAgICAgICAgYml0cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVidWdGbGFncy5zZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgfSk7XG4vLyAgICAgICAgdGhpcy5sb2cuZGVidWcoJ0RlYnVnIGZsYWdzOicsIGRiZ3N0cik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiBkZWJ1ZyBmbGFnIHdhcyBzcGVjaWZpZWQgaW4gdGhlIHF1ZXJ5IHBhcmFtc1xuICAgICAgKi9cbiAgICBkZWJ1Z09uKHRhZzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlYnVnRmxhZ3MuZ2V0KHRhZyk7XG4gICAgfVxuXG5cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVGhlIG5leHQgc2VjdGlvbiBkZWFscyB3aXRoIHNhbml0aXppbmcgZXh0ZXJuYWwgc3RyaW5ncyBkZXN0aW5lZFxuICAgIC8vIHRvIGJlIGxvYWRlZCB2aWEgYSAuaHRtbCgpIGZ1bmN0aW9uIGNhbGwuXG4gICAgLy9cbiAgICAvLyBTZWUgZGVmaW5pdGlvbiBvZiBtYXRjaGVyLCBldmlsbGlzdCBhbmQgd2hpdGVsaXN0IGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlXG5cbiAgICAvKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnIGlzIGluIHRoZSBldmlsIGxpc3QsIChhbmQgaXMgbm90IGFuIGVuZC10YWcpXG4gICAgICovXG4gICAgaW5FdmlsTGlzdCh0YWc6IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKGV2aWxsaXN0LmluZGV4T2YodGFnLm5hbWUpICE9PSAtMSAmJiB0YWcuZnVsbC5pbmRleE9mKCcvJykgPT09IC0xKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgTWF0Y2hlcyBvZiBtYXRjaGVyIGluIGh0bWxcbiAgICAgKi9cbiAgICBhbmFseXplKGh0bWw6IHN0cmluZyk6IE1hdGNoW10ge1xuICAgICAgICBjb25zdCBtYXRjaGVzOiBNYXRjaFtdID0gW107XG4gICAgICAgIGxldCBtYXRjaDtcblxuICAgICAgICAvLyBleHRyYWN0IGFsbCB0YWdzXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBtYXRjaGVyLmV4ZWMoaHRtbCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGZ1bGw6IG1hdGNoWzBdLFxuICAgICAgICAgICAgICAgIG5hbWU6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IGlnbm9yaW5nIGF0dHJpYnV0ZXMge21hdGNoWzJdLnNwbGl0KCcgJyl9IGZvciBub3dcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGEgY2xlYW5lZCB2ZXJzaW9uIG9mIGh0bWxcbiAgICAgKi9cbiAgICBzYW5pdGl6ZShodG1sOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBtYXRjaGVzOiBNYXRjaFtdID0gdGhpcy5hbmFseXplKGh0bWwpO1xuXG4gICAgICAgIC8vIGNvbXBsZXRlbHkgb2JsaXRlcmF0ZSBldmlsIHRhZ3MgYW5kIHRoZWlyIGNvbnRlbnRzLi4uXG4gICAgICAgIGV2aWxsaXN0LmZvckVhY2goKHRhZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKCc8JyArIHRhZyArICcoLio/KT4oLio/W1xcclxcbl0pKj8oLio/KSguKj9bXFxyXFxuXSkqPzxcXC8nICsgdGFnICsgJz4nLCAnZ2ltJyk7XG4gICAgICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKHJlLCAnJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZpbHRlciBvdXQgYWxsIGJ1dCB3aGl0ZS1saXN0ZWQgdGFncyBhbmQgZW5kLXRhZ3NcbiAgICAgICAgbWF0Y2hlcy5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICAgICAgICAgIGlmICh3aGl0ZWxpc3QuaW5kZXhPZih0YWcubmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSh0YWcuZnVsbCwgJycpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluRXZpbExpc3QodGFnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdVbnNhbml0YXJ5IEhUTUwgaW5wdXQgLS0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcuZnVsbCArICcgZGV0ZWN0ZWQhJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUT0RPOiBjb25zaWRlciBlbmNvZGluZyBIVE1MIGVudGl0aWVzLCBlLmcuICcmJyAtPiAnJmFtcDsnXG5cbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIHdvcmQgdG8gdHJpZSAod29yZCB3aWxsIGJlIGNvbnZlcnRlZCB0byB1cHBlcmNhc2UpXG4gICAgICogZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIHdvcmRcbiAgICAgKiByZXR1cm5zICdhZGRlZCcgb3IgJ3VwZGF0ZWQnXG4gICAgICovXG4gICAgYWRkVG9UcmllKHRyaWUsIHdvcmQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmllKFRyaWVPcC5QTFVTLCB0cmllLCB3b3JkLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgd29yZCBmcm9tIHRyaWUgKHdvcmQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gdXBwZXJjYXNlKVxuICAgICAqIHJldHVybnMgJ3JlbW92ZWQnIG9yICdhYnNlbnQnXG4gICAgICovXG4gICAgcmVtb3ZlRnJvbVRyaWUodHJpZSwgd29yZCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyaWUoVHJpZU9wLk1JTlVTLCB0cmllLCB3b3JkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBsb29rdXAgd29yZCAoY29udmVydGVkIHRvIHVwcGVyY2FzZSkgaW4gdHJpZVxuICAgICAqIHJldHVybnM6XG4gICAgICogICAgdW5kZWZpbmVkIGlmIHRoZSB3b3JkIGlzIG5vdCBpbiB0aGUgdHJpZVxuICAgICAqICAgIC0xIGZvciBhIHBhcnRpYWwgbWF0Y2ggKHdvcmQgaXMgYSBwcmVmaXggdG8gYW4gZXhpc3Rpbmcgd29yZClcbiAgICAgKiAgICBkYXRhIGZvciB0aGUgd29yZCBmb3IgYW4gZXhhY3QgbWF0Y2hcbiAgICAgKi9cbiAgICB0cmllTG9va3VwKHRyaWUsIHdvcmQpIHtcbiAgICAgICAgY29uc3QgcyA9IHdvcmQudG9VcHBlckNhc2UoKS5zcGxpdCgnJyk7XG4gICAgICAgIGxldCBwID0gdHJpZTtcbiAgICAgICAgbGV0IG47XG5cbiAgICAgICAgd2hpbGUgKHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBuID0gcy5zaGlmdCgpO1xuICAgICAgICAgICAgcCA9IHBbbl07XG4gICAgICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwLl9kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gcC5fZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG59XG4iXX0=