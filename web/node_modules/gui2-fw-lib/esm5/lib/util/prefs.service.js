/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/*
 * Copyright 2018-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Inject, Injectable } from '@angular/core';
import { FnService } from './fn.service';
import { LogService } from '../log.service';
import { WebSocketService } from '../remote/websocket.service';
import * as i0 from "@angular/core";
import * as i1 from "./fn.service";
import * as i2 from "../log.service";
import * as i3 from "../remote/websocket.service";
/** @type {?} */
var UPDATE_PREFS = 'updatePrefs';
/** @type {?} */
var UPDATE_PREFS_REQ = 'updatePrefReq';
/**
 * ONOS GUI -- Util -- User Preference Service
 */
var PrefsService = /** @class */ (function () {
    function PrefsService(fs, log, wss, window) {
        var _this = this;
        this.fs = fs;
        this.log = log;
        this.wss = wss;
        this.window = window;
        this.handlers = [];
        this.listeners = [];
        this.wss.bindHandlers(new Map([
            [UPDATE_PREFS, function (data) { return _this.updatePrefs(data); }]
        ]));
        this.handlers.push(UPDATE_PREFS);
        // When index.html is fetched it is served up by MainIndexResource.java
        // which fetches userPrefs in to the global scope.
        // After that updates are done through WebSocket
        this.cache = Object.assign({}, this.window['userPrefs']);
        this.log.debug('PrefsService constructed');
    }
    /**
     * @param {?} name
     * @param {?} obj
     * @return {?}
     */
    PrefsService.prototype.setPrefs = /**
     * @param {?} name
     * @param {?} obj
     * @return {?}
     */
    function (name, obj) {
        // keep a cached copy of the object and send an update to server
        this.cache[name] = obj;
        this.wss.sendEvent(UPDATE_PREFS_REQ, { key: name, value: obj });
    };
    /**
     * @param {?} data
     * @return {?}
     */
    PrefsService.prototype.updatePrefs = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.cache = data;
        this.listeners.forEach(function (lsnr) { return lsnr(data); });
    };
    /**
     * @param {?} obj
     * @param {?=} keys
     * @param {?=} not
     * @return {?}
     */
    PrefsService.prototype.asNumbers = /**
     * @param {?} obj
     * @param {?=} keys
     * @param {?=} not
     * @return {?}
     */
    function (obj, keys, not) {
        if (!obj) {
            return null;
        }
        /** @type {?} */
        var skip = {};
        if (not) {
            keys.forEach(function (k) {
                skip[k] = 1;
            });
        }
        if (!keys || not) {
            // do them all
            Array.from(obj).forEach(function (v, k) {
                if (!not || !skip[k]) {
                    obj[k] = Number(obj[k]);
                }
            });
        }
        else {
            // do the explicitly named keys
            keys.forEach(function (k) {
                obj[k] = Number(obj[k]);
            });
        }
        return obj;
    };
    /**
     * @param {?} name
     * @param {?} defaults
     * @param {?=} qparams
     * @return {?}
     */
    PrefsService.prototype.getPrefs = /**
     * @param {?} name
     * @param {?} defaults
     * @param {?=} qparams
     * @return {?}
     */
    function (name, defaults, qparams) {
        /** @type {?} */
        var obj = Object.assign({}, defaults || {}, this.cache[name] || {});
        // if query params are specified, they override...
        if (this.fs.isO(qparams)) {
            obj.forEach(function (k) {
                if (qparams.hasOwnProperty(k)) {
                    obj[k] = qparams[k];
                }
            });
        }
        return obj;
    };
    // merge preferences:
    // The assumption here is that obj is a sparse object, and that the
    //  defined keys should overwrite the corresponding values, but any
    //  existing keys that are NOT explicitly defined here should be left
    //  alone (not deleted).
    // merge preferences:
    // The assumption here is that obj is a sparse object, and that the
    //  defined keys should overwrite the corresponding values, but any
    //  existing keys that are NOT explicitly defined here should be left
    //  alone (not deleted).
    /**
     * @param {?} name
     * @param {?} obj
     * @return {?}
     */
    PrefsService.prototype.mergePrefs = 
    // merge preferences:
    // The assumption here is that obj is a sparse object, and that the
    //  defined keys should overwrite the corresponding values, but any
    //  existing keys that are NOT explicitly defined here should be left
    //  alone (not deleted).
    /**
     * @param {?} name
     * @param {?} obj
     * @return {?}
     */
    function (name, obj) {
        /** @type {?} */
        var merged = this.cache[name] || {};
        this.setPrefs(name, Object.assign(merged, obj));
    };
    /**
     * Add a listener function
     * This will get called back when an 'updatePrefs' message is received on WSS
     * @param listener a function that can accept one param - data
     */
    /**
     * Add a listener function
     * This will get called back when an 'updatePrefs' message is received on WSS
     * @param {?} listener a function that can accept one param - data
     * @return {?}
     */
    PrefsService.prototype.addListener = /**
     * Add a listener function
     * This will get called back when an 'updatePrefs' message is received on WSS
     * @param {?} listener a function that can accept one param - data
     * @return {?}
     */
    function (listener) {
        this.listeners.push(listener);
    };
    /**
     * @param {?} listener
     * @return {?}
     */
    PrefsService.prototype.removeListener = /**
     * @param {?} listener
     * @return {?}
     */
    function (listener) {
        this.listeners = this.listeners.filter(function (obj) { return obj !== listener; });
    };
    PrefsService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] },
    ];
    /** @nocollapse */
    PrefsService.ctorParameters = function () { return [
        { type: FnService },
        { type: LogService },
        { type: WebSocketService },
        { type: undefined, decorators: [{ type: Inject, args: ['Window',] }] }
    ]; };
    /** @nocollapse */ PrefsService.ngInjectableDef = i0.defineInjectable({ factory: function PrefsService_Factory() { return new PrefsService(i0.inject(i1.FnService), i0.inject(i2.LogService), i0.inject(i3.WebSocketService), i0.inject("Window")); }, token: PrefsService, providedIn: "root" });
    return PrefsService;
}());
export { PrefsService };
if (false) {
    /** @type {?} */
    PrefsService.prototype.handlers;
    /** @type {?} */
    PrefsService.prototype.cache;
    /** @type {?} */
    PrefsService.prototype.listeners;
    /** @type {?} */
    PrefsService.prototype.fs;
    /** @type {?} */
    PrefsService.prototype.log;
    /** @type {?} */
    PrefsService.prototype.wss;
    /** @type {?} */
    PrefsService.prototype.window;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJlZnMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2d1aTItZnctbGliLyIsInNvdXJjZXMiOlsibGliL3V0aWwvcHJlZnMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsT0FBTyxFQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDakQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN6QyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDNUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7Ozs7OztJQUV6RCxZQUFZLEdBQVcsYUFBYTs7SUFDcEMsZ0JBQWdCLEdBQVcsZUFBZTs7OztBQU1oRDtJQU9JLHNCQUNjLEVBQWEsRUFDYixHQUFlLEVBQ2YsR0FBcUIsRUFDTCxNQUFXO1FBSnpDLGlCQWlCQztRQWhCYSxPQUFFLEdBQUYsRUFBRSxDQUFXO1FBQ2IsUUFBRyxHQUFILEdBQUcsQ0FBWTtRQUNmLFFBQUcsR0FBSCxHQUFHLENBQWtCO1FBQ0wsV0FBTSxHQUFOLE1BQU0sQ0FBSztRQVAvQixhQUFRLEdBQWEsRUFBRSxDQUFDO1FBRWxDLGNBQVMsR0FBdUIsRUFBRSxDQUFDO1FBTy9CLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLElBQUksR0FBRyxDQUF5QjtZQUNsRCxDQUFDLFlBQVksRUFBRSxVQUFDLElBQUksSUFBSyxPQUFBLEtBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQXRCLENBQXNCLENBQUM7U0FDbkQsQ0FBQyxDQUFDLENBQUM7UUFDSixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUVqQyx1RUFBdUU7UUFDdkUsa0RBQWtEO1FBQ2xELGdEQUFnRDtRQUNoRCxJQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENB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RyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7UUFDckMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQ7Ozs7T0FJRzs7Ozs7OztJQUNILGtDQUFXOzs7Ozs7SUFBWCxVQUFZLFFBQXdCO1FBQ2hDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2xDLENBQUM7Ozs7O0lBRUQscUNBQWM7Ozs7SUFBZCxVQUFlLFFBQXdCO1FBQ25DLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsVUFBQyxHQUFHLElBQUssT0FBQSxHQUFHLEtBQUssUUFBUSxFQUFoQixDQUFnQixDQUFDLENBQUM7SUFDdEUsQ0FBQzs7Z0JBcEdKLFVBQVUsU0FBQztvQkFDUixVQUFVLEVBQUUsTUFBTTtpQkFDckI7Ozs7Z0JBYlEsU0FBUztnQkFDVCxVQUFVO2dCQUNWLGdCQUFnQjtnREFvQmhCLE1BQU0sU0FBQyxRQUFROzs7dUJBdEN4QjtDQWlJQyxBQXRHRCxJQXNHQztTQW5HWSxZQUFZOzs7SUFDckIsZ0NBQWtDOztJQUNsQyw2QkFBYzs7SUFDZCxpQ0FBbUM7O0lBRS9CLDBCQUF1Qjs7SUFDdkIsMkJBQXlCOztJQUN6QiwyQkFBK0I7O0lBQy9CLDhCQUFxQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAxOC1wcmVzZW50IE9wZW4gTmV0d29ya2luZyBGb3VuZGF0aW9uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQge0luamVjdCwgSW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGblNlcnZpY2UgfSBmcm9tICcuL2ZuLnNlcnZpY2UnO1xuaW1wb3J0IHsgTG9nU2VydmljZSB9IGZyb20gJy4uL2xvZy5zZXJ2aWNlJztcbmltcG9ydCB7IFdlYlNvY2tldFNlcnZpY2UgfSBmcm9tICcuLi9yZW1vdGUvd2Vic29ja2V0LnNlcnZpY2UnO1xuXG5jb25zdCBVUERBVEVfUFJFRlM6IHN0cmluZyA9ICd1cGRhdGVQcmVmcyc7XG5jb25zdCBVUERBVEVfUFJFRlNfUkVROiBzdHJpbmcgPSAndXBkYXRlUHJlZlJlcSc7XG5cblxuLyoqXG4gKiBPTk9TIEdVSSAtLSBVdGlsIC0tIFVzZXIgUHJlZmVyZW5jZSBTZXJ2aWNlXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIFByZWZzU2VydmljZSB7XG4gICAgcHJvdGVjdGVkIGhhbmRsZXJzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNhY2hlOiBPYmplY3Q7XG4gICAgbGlzdGVuZXJzOiAoKGRhdGEpID0+IHZvaWQpW10gPSBbXTtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJvdGVjdGVkIGZzOiBGblNlcnZpY2UsXG4gICAgICAgIHByb3RlY3RlZCBsb2c6IExvZ1NlcnZpY2UsXG4gICAgICAgIHByb3RlY3RlZCB3c3M6IFdlYlNvY2tldFNlcnZpY2UsXG4gICAgICAgIEBJbmplY3QoJ1dpbmRvdycpIHByaXZhdGUgd2luZG93OiBhbnlcbiAgICApIHtcbiAgICAgICAgdGhpcy53c3MuYmluZEhhbmRsZXJzKG5ldyBNYXA8c3RyaW5nLCAoZGF0YSkgPT4gdm9pZD4oW1xuICAgICAgICAgICAgW1VQREFURV9QUkVGUywgKGRhdGEpID0+IHRoaXMudXBkYXRlUHJlZnMoZGF0YSldXG4gICAgICAgIF0pKTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKFVQREFURV9QUkVGUyk7XG5cbiAgICAgICAgLy8gV2hlbiBpbmRleC5odG1sIGlzIGZldGNoZWQgaXQgaXMgc2VydmVkIHVwIGJ5IE1haW5JbmRleFJlc291cmNlLmphdmFcbiAgICAgICAgLy8gd2hpY2ggZmV0Y2hlcyB1c2VyUHJlZnMgaW4gdG8gdGhlIGdsb2JhbCBzY29wZS5cbiAgICAgICAgLy8gQWZ0ZXIgdGhhdCB1cGRhdGVzIGFyZSBkb25lIHRocm91Z2ggV2ViU29ja2V0XG4gICAgICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLndpbmRvd1sndXNlclByZWZzJ10pO1xuXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdQcmVmc1NlcnZpY2UgY29uc3RydWN0ZWQnKTtcbiAgICB9XG5cbiAgICBzZXRQcmVmcyhuYW1lOiBzdHJpbmcsIG9iajogT2JqZWN0KSB7XG4gICAgICAgIC8vIGtlZXAgYSBjYWNoZWQgY29weSBvZiB0aGUgb2JqZWN0IGFuZCBzZW5kIGFuIHVwZGF0ZSB0byBzZXJ2ZXJcbiAgICAgICAgdGhpcy5jYWNoZVtuYW1lXSA9IG9iajtcbiAgICAgICAgdGhpcy53c3Muc2VuZEV2ZW50KFVQREFURV9QUkVGU19SRVEsIHsga2V5OiBuYW1lLCB2YWx1ZTogb2JqIH0pO1xuICAgIH1cbiAgICB1cGRhdGVQcmVmcyhkYXRhOiBhbnkpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IGRhdGE7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGxzbnIpID0+IGxzbnIoZGF0YSkgKTtcbiAgICB9XG5cbiAgICBhc051bWJlcnMob2JqOiBhbnksIGtleXM/OiBhbnksIG5vdD86IGFueSkge1xuICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBza2lwID0ge307XG4gICAgICAgIGlmIChub3QpIHtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgICAgICBza2lwW2tdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleXMgfHwgbm90KSB7XG4gICAgICAgICAgICAvLyBkbyB0aGVtIGFsbFxuICAgICAgICAgICAgQXJyYXkuZnJvbShvYmopLmZvckVhY2goKHYsIGspID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vdCB8fCAhc2tpcFtrXSkge1xuICAgICAgICAgICAgICAgICAgICBvYmpba10gPSBOdW1iZXIob2JqW2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRvIHRoZSBleHBsaWNpdGx5IG5hbWVkIGtleXNcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgICAgICBvYmpba10gPSBOdW1iZXIob2JqW2tdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZ2V0UHJlZnMobmFtZTogc3RyaW5nLCBkZWZhdWx0czogT2JqZWN0LCBxcGFyYW1zPzogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzIHx8IHt9LCB0aGlzLmNhY2hlW25hbWVdIHx8IHt9KTtcblxuICAgICAgICAvLyBpZiBxdWVyeSBwYXJhbXMgYXJlIHNwZWNpZmllZCwgdGhleSBvdmVycmlkZS4uLlxuICAgICAgICBpZiAodGhpcy5mcy5pc08ocXBhcmFtcykpIHtcbiAgICAgICAgICAgIG9iai5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChxcGFyYW1zLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrXSA9IHFwYXJhbXNba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAvLyBtZXJnZSBwcmVmZXJlbmNlczpcbiAgICAvLyBUaGUgYXNzdW1wdGlvbiBoZXJlIGlzIHRoYXQgb2JqIGlzIGEgc3BhcnNlIG9iamVjdCwgYW5kIHRoYXQgdGhlXG4gICAgLy8gIGRlZmluZWQga2V5cyBzaG91bGQgb3ZlcndyaXRlIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcywgYnV0IGFueVxuICAgIC8vICBleGlzdGluZyBrZXlzIHRoYXQgYXJlIE5PVCBleHBsaWNpdGx5IGRlZmluZWQgaGVyZSBzaG91bGQgYmUgbGVmdFxuICAgIC8vICBhbG9uZSAobm90IGRlbGV0ZWQpLlxuICAgIG1lcmdlUHJlZnMobmFtZTogc3RyaW5nLCBvYmo6IGFueSk6IHZvaWQge1xuICAgICAgICBjb25zdCBtZXJnZWQgPSB0aGlzLmNhY2hlW25hbWVdIHx8IHt9O1xuICAgICAgICB0aGlzLnNldFByZWZzKG5hbWUsIE9iamVjdC5hc3NpZ24obWVyZ2VkLCBvYmopKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBmdW5jdGlvblxuICAgICAqIFRoaXMgd2lsbCBnZXQgY2FsbGVkIGJhY2sgd2hlbiBhbiAndXBkYXRlUHJlZnMnIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgb24gV1NTXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIGEgZnVuY3Rpb24gdGhhdCBjYW4gYWNjZXB0IG9uZSBwYXJhbSAtIGRhdGFcbiAgICAgKi9cbiAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcjogKGRhdGEpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXI6IChkYXRhKSA9PiB2b2lkKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMuZmlsdGVyKChvYmopID0+IG9iaiAhPT0gbGlzdGVuZXIpO1xuICAgIH1cblxufVxuIl19