/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/*
 * Copyright 2018-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Pipe } from '@angular/core';
/**
 * Only return the tabledata that matches filtering with some queries
 *
 * Note: the pipe is marked pure here as we need to filter on the
 * content of the filter object (it's not a primitive type)
 */
var TableFilterPipe = /** @class */ (function () {
    function TableFilterPipe() {
    }
    /**
     * From an array of table items just return those that match the filter
     */
    /**
     * From an array of table items just return those that match the filter
     * @param {?} items
     * @param {?} tableDataFilter
     * @return {?}
     */
    TableFilterPipe.prototype.transform = /**
     * From an array of table items just return those that match the filter
     * @param {?} items
     * @param {?} tableDataFilter
     * @return {?}
     */
    function (items, tableDataFilter) {
        if (!items) {
            return [];
        }
        if (!tableDataFilter.queryStr) {
            return items;
        }
        /** @type {?} */
        var queryStr = tableDataFilter.queryStr.toLowerCase();
        return items.filter(function (it) {
            if (tableDataFilter.queryBy === '$') {
                /** @type {?} */
                var t1 = Object.values(it);
                /** @type {?} */
                var t2 = Object.values(it).filter(function (value) {
                    return ((/** @type {?} */ (value))).toLowerCase().includes(queryStr);
                });
                return Object.values(it).filter(function (value) {
                    return ((/** @type {?} */ (value))).toLowerCase().includes(queryStr);
                }).length > 0;
            }
            else {
                return it[tableDataFilter.queryBy].toLowerCase().includes(queryStr);
            }
        });
    };
    TableFilterPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'filter',
                    pure: false
                },] },
    ];
    return TableFilterPipe;
}());
export { TableFilterPipe };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGVmaWx0ZXIucGlwZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2d1aTItZnctbGliLyIsInNvdXJjZXMiOlsibGliL3dpZGdldC90YWJsZWZpbHRlci5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQSxPQUFPLEVBQUUsSUFBSSxFQUFpQixNQUFNLGVBQWUsQ0FBQzs7Ozs7OztBQVNwRDtJQUFBO0lBaUNBLENBQUM7SUEzQkc7O09BRUc7Ozs7Ozs7SUFDSCxtQ0FBUzs7Ozs7O0lBQVQsVUFBVSxLQUFZLEVBQUUsZUFBNEI7UUFDaEQsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNSLE9BQU8sRUFBRSxDQUFDO1NBQ2I7UUFDRCxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsRUFBRTtZQUMzQixPQUFPLEtBQUssQ0FBQztTQUNoQjs7WUFFSyxRQUFRLEdBQUcsZUFBZSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUU7UUFFdkQsT0FBTyxLQUFLLENBQUMsTUFBTSxDQUFFLFVBQUEsRUFBRTtZQUNuQixJQUFJLGVBQWUsQ0FBQyxPQUFPLEtBQUssR0FBRyxFQUFFOztvQkFDM0IsRUFBRSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDOztvQkFDdEIsRUFBRSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQUEsS0FBSztvQkFDMUIsT0FBTyxDQUFDLG1CQUFRLEtBQUssRUFBQSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUM1RCxDQUFDLENBQUM7Z0JBQ2IsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFBLEtBQUs7b0JBQ2pDLE9BQU8sQ0FBQyxtQkFBUSxLQUFLLEVBQUEsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDNUQsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQzthQUNqQjtpQkFBTTtnQkFDSCxPQUFPLEVBQUUsQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQ3ZFO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDOztnQkFoQ0osSUFBSSxTQUFDO29CQUNKLElBQUksRUFBRSxRQUFRO29CQUNkLElBQUksRUFBRSxLQUFLO2lCQUNaOztJQThCRCxzQkFBQztDQUFBLEFBakNELElBaUNDO1NBN0JZLGVBQWUiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMTgtcHJlc2VudCBPcGVuIE5ldHdvcmtpbmcgRm91bmRhdGlvblxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUYWJsZUZpbHRlciB9IGZyb20gJy4vdGFibGUuYmFzZSc7XG5cbi8qKlxuICogT25seSByZXR1cm4gdGhlIHRhYmxlZGF0YSB0aGF0IG1hdGNoZXMgZmlsdGVyaW5nIHdpdGggc29tZSBxdWVyaWVzXG4gKlxuICogTm90ZTogdGhlIHBpcGUgaXMgbWFya2VkIHB1cmUgaGVyZSBhcyB3ZSBuZWVkIHRvIGZpbHRlciBvbiB0aGVcbiAqIGNvbnRlbnQgb2YgdGhlIGZpbHRlciBvYmplY3QgKGl0J3Mgbm90IGEgcHJpbWl0aXZlIHR5cGUpXG4gKi9cbkBQaXBlKHtcbiAgbmFtZTogJ2ZpbHRlcicsXG4gIHB1cmU6IGZhbHNlXG59KVxuZXhwb3J0IGNsYXNzIFRhYmxlRmlsdGVyUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gICAgLyoqXG4gICAgICogRnJvbSBhbiBhcnJheSBvZiB0YWJsZSBpdGVtcyBqdXN0IHJldHVybiB0aG9zZSB0aGF0IG1hdGNoIHRoZSBmaWx0ZXJcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oaXRlbXM6IGFueVtdLCB0YWJsZURhdGFGaWx0ZXI6IFRhYmxlRmlsdGVyKTogYW55W10ge1xuICAgICAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YWJsZURhdGFGaWx0ZXIucXVlcnlTdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RyID0gdGFibGVEYXRhRmlsdGVyLnF1ZXJ5U3RyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbHRlciggaXQgPT4ge1xuICAgICAgICAgICAgaWYgKHRhYmxlRGF0YUZpbHRlci5xdWVyeUJ5ID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0MSA9IE9iamVjdC52YWx1ZXMoaXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHQyID0gT2JqZWN0LnZhbHVlcyhpdCkuZmlsdGVyKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDxzdHJpbmc+dmFsdWUpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnlTdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaXQpLmZpbHRlcih2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoPHN0cmluZz52YWx1ZSkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeVN0cik7XG4gICAgICAgICAgICAgICAgfSkubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0W3RhYmxlRGF0YUZpbHRlci5xdWVyeUJ5XS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5U3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19