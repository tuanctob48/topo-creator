/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/*
 * Copyright 2018-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable, Inject } from '@angular/core';
import { FnService } from '../util/fn.service';
import { GlyphService } from '../svg/glyph.service';
import { LogService } from '../log.service';
import { UrlFnService } from './urlfn.service';
import { WSock } from './wsock.service';
import * as i0 from "@angular/core";
import * as i1 from "../util/fn.service";
import * as i2 from "../svg/glyph.service";
import * as i3 from "../log.service";
import * as i4 from "./urlfn.service";
import * as i5 from "./wsock.service";
/**
 * Event Type structure for the WebSocketService
 * @record
 */
export function EventType() { }
if (false) {
    /** @type {?} */
    EventType.prototype.event;
    /** @type {?} */
    EventType.prototype.payload;
}
/**
 * @record
 */
export function Callback() { }
if (false) {
    /** @type {?} */
    Callback.prototype.id;
    /** @type {?} */
    Callback.prototype.error;
    /**
     * @param {?} host
     * @param {?} url
     * @return {?}
     */
    Callback.prototype.cb = function (host, url) { };
}
/**
 * @record
 */
function ClusterNode() { }
if (false) {
    /** @type {?} */
    ClusterNode.prototype.id;
    /** @type {?} */
    ClusterNode.prototype.ip;
    /** @type {?} */
    ClusterNode.prototype.m_uiAttached;
}
/**
 * @record
 */
function Glyph() { }
if (false) {
    /** @type {?} */
    Glyph.prototype.id;
    /** @type {?} */
    Glyph.prototype.viewbox;
    /** @type {?} */
    Glyph.prototype.path;
}
/**
 * @record
 */
function Bootstrap() { }
if (false) {
    /** @type {?} */
    Bootstrap.prototype.user;
    /** @type {?} */
    Bootstrap.prototype.clusterNodes;
    /** @type {?} */
    Bootstrap.prototype.glyphs;
}
/**
 * @record
 */
function ErrorData() { }
if (false) {
    /** @type {?} */
    ErrorData.prototype.message;
}
/**
 * @record
 */
export function WsOptions() { }
if (false) {
    /** @type {?} */
    WsOptions.prototype.wsport;
}
/**
 * ONOS GUI -- Remote -- Web Socket Service
 *
 * To see debug messages add ?debug=txrx to the URL
 */
var WebSocketService = /** @class */ (function () {
    function WebSocketService(fs, gs, log, ufs, wsock, window) {
        var _this = this;
        this.fs = fs;
        this.gs = gs;
        this.log = log;
        this.ufs = ufs;
        this.wsock = wsock;
        this.window = window;
        // web socket options
        this.ws = null; // web socket reference
        // web socket reference
        this.wsUp = false; // web socket is good to go
        // web socket is good to go
        // A map of event handler bindings - names and functions (that accept data and return void)
        this.handlers = new Map([]);
        this.pendingEvents = []; // events TX'd while socket not up
        // web socket URL
        this.clusterNodes = []; // ONOS instances data for failover
        // ONOS instances data for failover
        this.clusterIndex = -1; // the instance to which we are connected
        // the instance to which we are connected
        this.glyphs = [];
        this.connectRetries = 0; // limit our attempts at reconnecting
        // limit our attempts at reconnecting
        // A map of registered Callbacks for websocket open()
        this.openListeners = new Map([]);
        this.nextListenerId = 1; // internal ID for open listeners
        // internal ID for open listeners
        this.loggedInUser = null; // name of logged-in user
        this.log.debug(window.location.hostname);
        // Bind the boot strap event by default
        this.bindHandlers(new Map([
            ['bootstrap', function (data) { return _this.bootstrap(data); }],
            ['error', function (data) { return _this.error(data); }]
        ]));
        this.log.debug('WebSocketService constructed');
    }
    /**
     * built-in handler for the 'boostrap' event
     */
    // The veil component delegate
    /**
     * built-in handler for the 'boostrap' event
     * @param {?} data
     * @return {?}
     */
    WebSocketService.prototype.bootstrap = 
    // The veil component delegate
    /**
     * built-in handler for the 'boostrap' event
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        this.loggedInUser = data.user;
        this.log.info('Websocket connection bootstraped', data);
        this.clusterNodes = data.clusterNodes;
        this.clusterNodes.forEach(function (d, i) {
            if (d.m_uiAttached) {
                _this.clusterIndex = i;
                _this.log.info('Connected to cluster node ' + d.ip);
                // TODO: add connect info to masthead somewhere
            }
        });
        this.glyphs = data.glyphs;
        /** @type {?} */
        var glyphsMap = new Map([]);
        this.glyphs.forEach(function (d) {
            glyphsMap.set('_' + d.id, d.viewbox);
            glyphsMap.set(d.id, d.path);
            _this.gs.registerGlyphs(glyphsMap);
        });
    };
    /**
     * @param {?} data
     * @return {?}
     */
    WebSocketService.prototype.error = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var m = data.message || 'error from server';
        this.log.error(m, data);
        // Unrecoverable error - throw up the veil...
        if (this.vcd) {
            this.vcd.show([
                'Oops!',
                'Server reports error...',
                m,
            ]);
        }
    };
    // ==========================
    // === Web socket callbacks
    /**
     * Called when WebSocket has just opened
     *
     * Lift the Veil if it is displayed
     * If there are any events pending, send them
     * Mark the WSS as up and inform any listeners for this open event
     */
    // ==========================
    // === Web socket callbacks
    /**
     * Called when WebSocket has just opened
     *
     * Lift the Veil if it is displayed
     * If there are any events pending, send them
     * Mark the WSS as up and inform any listeners for this open event
     * @return {?}
     */
    WebSocketService.prototype.handleOpen = 
    // ==========================
    // === Web socket callbacks
    /**
     * Called when WebSocket has just opened
     *
     * Lift the Veil if it is displayed
     * If there are any events pending, send them
     * Mark the WSS as up and inform any listeners for this open event
     * @return {?}
     */
    function () {
        var _this = this;
        this.log.info('Web socket open - ', this.url);
        // Hide the veil
        if (this.vcd) {
            this.vcd.hide();
        }
        if (this.fs.debugOn('txrx')) {
            this.log.debug('Sending ' + this.pendingEvents.length + ' pending event(s)...');
        }
        this.pendingEvents.forEach(function (ev) {
            _this.send(ev);
        });
        this.pendingEvents = [];
        this.connectRetries = 0;
        this.wsUp = true;
        this.informListeners(this.host, this.url);
    };
    /**
     * Function called when WebSocket send a message
     */
    /**
     * Function called when WebSocket send a message
     * @param {?} msgEvent
     * @return {?}
     */
    WebSocketService.prototype.handleMessage = /**
     * Function called when WebSocket send a message
     * @param {?} msgEvent
     * @return {?}
     */
    function (msgEvent) {
        /** @type {?} */
        var ev;
        /** @type {?} */
        var h;
        try {
            ev = JSON.parse(msgEvent.data);
        }
        catch (e) {
            this.log.error('Message.data is not valid JSON', msgEvent.data, e);
            return null;
        }
        if (this.fs.debugOn('txrx')) {
            this.log.debug(' << *Rx* ', ev.event, ev.payload);
        }
        h = this.handlers.get(ev.event);
        if (h) {
            try {
                h(ev.payload);
            }
            catch (e) {
                this.log.error('Problem handling event:', ev, e);
                return null;
            }
        }
        else {
            this.log.warn('Unhandled event:', ev);
        }
    };
    /**
     * Called by the WebSocket if it is closed from the server end
     *
     * If the loading component is shown, call stop() on it
     * Try to find another node in the cluster to connect to
     * If this is not possible then show the Veil Component
     */
    /**
     * Called by the WebSocket if it is closed from the server end
     *
     * If the loading component is shown, call stop() on it
     * Try to find another node in the cluster to connect to
     * If this is not possible then show the Veil Component
     * @return {?}
     */
    WebSocketService.prototype.handleClose = /**
     * Called by the WebSocket if it is closed from the server end
     *
     * If the loading component is shown, call stop() on it
     * Try to find another node in the cluster to connect to
     * If this is not possible then show the Veil Component
     * @return {?}
     */
    function () {
        this.log.warn('Web socket closed');
        if (this.lcd) {
            this.lcd.stop();
        }
        this.wsUp = false;
        /** @type {?} */
        var gsucc;
        if (gsucc = this.findGuiSuccessor()) {
            this.url = this.createWebSocket(this.webSockOpts, gsucc);
        }
        else {
            // If no controllers left to contact, show the Veil...
            if (this.vcd) {
                this.vcd.show([
                    'Oops!',
                    'Web-socket connection to server closed...',
                    'Try refreshing the page.',
                ]);
            }
        }
    };
    // ==============================
    // === Private Helper Functions
    /**
     * Find the next node in the ONOS cluster.
     *
     * This is used if the WebSocket connection closes because a
     * node in the cluster ges down - fail over should be automatic
     */
    // ==============================
    // === Private Helper Functions
    /**
     * Find the next node in the ONOS cluster.
     *
     * This is used if the WebSocket connection closes because a
     * node in the cluster ges down - fail over should be automatic
     * @return {?}
     */
    WebSocketService.prototype.findGuiSuccessor = 
    // ==============================
    // === Private Helper Functions
    /**
     * Find the next node in the ONOS cluster.
     *
     * This is used if the WebSocket connection closes because a
     * node in the cluster ges down - fail over should be automatic
     * @return {?}
     */
    function () {
        /** @type {?} */
        var ncn = this.clusterNodes.length;
        /** @type {?} */
        var ip;
        /** @type {?} */
        var node;
        while (this.connectRetries < ncn && !ip) {
            this.connectRetries++;
            this.clusterIndex = (this.clusterIndex + 1) % ncn;
            node = this.clusterNodes[this.clusterIndex];
            ip = node && node.ip;
        }
        return ip;
    };
    /**
     * When the WebSocket is opened, inform any listeners that registered
     * for that event
     */
    /**
     * When the WebSocket is opened, inform any listeners that registered
     * for that event
     * @param {?} host
     * @param {?} url
     * @return {?}
     */
    WebSocketService.prototype.informListeners = /**
     * When the WebSocket is opened, inform any listeners that registered
     * for that event
     * @param {?} host
     * @param {?} url
     * @return {?}
     */
    function (host, url) {
        var e_1, _a;
        try {
            for (var _b = tslib_1.__values(this.openListeners.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = tslib_1.__read(_c.value, 2), key = _d[0], cb = _d[1];
                cb.cb(host, url);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * @param {?} ev
     * @return {?}
     */
    WebSocketService.prototype.send = /**
     * @param {?} ev
     * @return {?}
     */
    function (ev) {
        if (this.fs.debugOn('txrx')) {
            this.log.debug(' *Tx* >> ', ev.event, ev.payload);
        }
        this.ws.send(JSON.stringify(ev));
    };
    /**
     * Check if there are no WSS event handlers left
     */
    /**
     * Check if there are no WSS event handlers left
     * @param {?} handlers
     * @param {?} caller
     * @return {?}
     */
    WebSocketService.prototype.noHandlersWarn = /**
     * Check if there are no WSS event handlers left
     * @param {?} handlers
     * @param {?} caller
     * @return {?}
     */
    function (handlers, caller) {
        if (!handlers || handlers.size === 0) {
            this.log.warn('WSS.' + caller + '(): no event handlers');
            return true;
        }
        return false;
    };
    /* ===================
     * === API Functions
     */
    /**
     * Required for unit tests to set to known state
     */
    /* ===================
         * === API Functions
         */
    /**
     * Required for unit tests to set to known state
     * @return {?}
     */
    WebSocketService.prototype.resetState = /* ===================
         * === API Functions
         */
    /**
     * Required for unit tests to set to known state
     * @return {?}
     */
    function () {
        this.webSockOpts = undefined;
        this.ws = null;
        this.wsUp = false;
        this.host = undefined;
        this.url = undefined;
        this.pendingEvents = [];
        this.handlers.clear();
        this.clusterNodes = [];
        this.clusterIndex = -1;
        this.glyphs = [];
        this.connectRetries = 0;
        this.openListeners.clear();
        this.nextListenerId = 1;
    };
    /*
     * Currently supported opts:
     *  wsport: web socket port (other than default 8181)
     *  host:   if defined, is the host address to use
     */
    /*
         * Currently supported opts:
         *  wsport: web socket port (other than default 8181)
         *  host:   if defined, is the host address to use
         */
    /**
     * @param {?=} opts
     * @param {?=} host
     * @return {?}
     */
    WebSocketService.prototype.createWebSocket = /*
         * Currently supported opts:
         *  wsport: web socket port (other than default 8181)
         *  host:   if defined, is the host address to use
         */
    /**
     * @param {?=} opts
     * @param {?=} host
     * @return {?}
     */
    function (opts, host) {
        var _this = this;
        this.webSockOpts = opts; // preserved for future calls
        this.host = host === undefined ? this.window.location.host : host;
        this.url = this.ufs.wsUrl('core', opts === undefined ? '' : opts['wsport'].toString(), host);
        this.log.debug('Attempting to open websocket to: ' + this.url);
        this.ws = this.wsock.newWebSocket(this.url);
        if (this.ws) {
            // fat arrow => syntax means that the 'this' context passed will
            // be of WebSocketService, not the WebSocket
            this.ws.onopen = (function () { return _this.handleOpen(); });
            this.ws.onmessage = (function (msgEvent) { return _this.handleMessage(msgEvent); });
            this.ws.onclose = (function () { return _this.handleClose(); });
            /** @type {?} */
            var authToken = this.window['onosAuth'];
            this.log.debug('Auth Token for opening WebSocket', authToken);
            this.sendEvent('authentication', { token: authToken });
        }
        // Note: Wsock logs an error if the new WebSocket call fails
        return this.url;
    };
    /**
     * Tell the WebSocket to close - this should call the handleClose() method
     */
    /**
     * Tell the WebSocket to close - this should call the handleClose() method
     * @return {?}
     */
    WebSocketService.prototype.closeWebSocket = /**
     * Tell the WebSocket to close - this should call the handleClose() method
     * @return {?}
     */
    function () {
        this.ws.close();
    };
    /**
     * Binds the message handlers to their message type (event type) as
     *  specified in the given map. Note that keys are the event IDs; values
     *  are either:
     *     * the event handler function, or
     *     * an API object which has an event handler for the key
     */
    /**
     * Binds the message handlers to their message type (event type) as
     *  specified in the given map. Note that keys are the event IDs; values
     *  are either:
     *     * the event handler function, or
     *     * an API object which has an event handler for the key
     * @param {?} handlerMap
     * @return {?}
     */
    WebSocketService.prototype.bindHandlers = /**
     * Binds the message handlers to their message type (event type) as
     *  specified in the given map. Note that keys are the event IDs; values
     *  are either:
     *     * the event handler function, or
     *     * an API object which has an event handler for the key
     * @param {?} handlerMap
     * @return {?}
     */
    function (handlerMap) {
        var e_2, _a;
        /** @type {?} */
        var dups = [];
        if (this.noHandlersWarn(handlerMap, 'bindHandlers')) {
            return null;
        }
        try {
            for (var handlerMap_1 = tslib_1.__values(handlerMap), handlerMap_1_1 = handlerMap_1.next(); !handlerMap_1_1.done; handlerMap_1_1 = handlerMap_1.next()) {
                var _b = tslib_1.__read(handlerMap_1_1.value, 2), eventId = _b[0], api = _b[1];
                this.log.debug('Adding handler for ', eventId);
                /** @type {?} */
                var fn = this.fs.isF(api) || this.fs.isF(api[eventId]);
                if (!fn) {
                    this.log.warn(eventId + ' handler not a function');
                    return;
                }
                if (this.handlers.get(eventId)) {
                    dups.push(eventId);
                }
                else {
                    this.handlers.set(eventId, fn);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (handlerMap_1_1 && !handlerMap_1_1.done && (_a = handlerMap_1.return)) _a.call(handlerMap_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (dups.length) {
            this.log.warn('duplicate bindings ignored:', dups);
        }
    };
    /**
     * Unbinds the specified message handlers.
     *   Expected that the same map will be used, but we only care about keys
     */
    /**
     * Unbinds the specified message handlers.
     *   Expected that the same map will be used, but we only care about keys
     * @param {?} handlerIds
     * @return {?}
     */
    WebSocketService.prototype.unbindHandlers = /**
     * Unbinds the specified message handlers.
     *   Expected that the same map will be used, but we only care about keys
     * @param {?} handlerIds
     * @return {?}
     */
    function (handlerIds) {
        var e_3, _a;
        if (handlerIds.length === 0) {
            this.log.warn('WSS.unbindHandlers(): no event handlers');
            return null;
        }
        try {
            for (var handlerIds_1 = tslib_1.__values(handlerIds), handlerIds_1_1 = handlerIds_1.next(); !handlerIds_1_1.done; handlerIds_1_1 = handlerIds_1.next()) {
                var eventId = handlerIds_1_1.value;
                this.handlers.delete(eventId);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (handlerIds_1_1 && !handlerIds_1_1.done && (_a = handlerIds_1.return)) _a.call(handlerIds_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    /**
     * @param {?} handlerId
     * @return {?}
     */
    WebSocketService.prototype.isHandling = /**
     * @param {?} handlerId
     * @return {?}
     */
    function (handlerId) {
        return this.handlers.get(handlerId) !== undefined;
    };
    /**
     * Add a listener function for listening for WebSocket opening.
     * The function must give a host and url and return void
     */
    /**
     * Add a listener function for listening for WebSocket opening.
     * The function must give a host and url and return void
     * @param {?} callback
     * @return {?}
     */
    WebSocketService.prototype.addOpenListener = /**
     * Add a listener function for listening for WebSocket opening.
     * The function must give a host and url and return void
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        /** @type {?} */
        var id = this.nextListenerId++;
        /** @type {?} */
        var cb = this.fs.isF(callback);
        /** @type {?} */
        var o = (/** @type {?} */ ({ id: id, cb: cb }));
        if (cb) {
            this.openListeners.set(id, o);
        }
        else {
            this.log.error('WSS.addOpenListener(): callback not a function');
            o.error = 'No callback defined';
        }
        return o;
    };
    /**
     * Remove a listener of WebSocket opening
     */
    /**
     * Remove a listener of WebSocket opening
     * @param {?} lsnr
     * @return {?}
     */
    WebSocketService.prototype.removeOpenListener = /**
     * Remove a listener of WebSocket opening
     * @param {?} lsnr
     * @return {?}
     */
    function (lsnr) {
        /** @type {?} */
        var id = this.fs.isO(lsnr) && lsnr.id;
        /** @type {?} */
        var o;
        if (!id) {
            this.log.warn('WSS.removeOpenListener(): invalid listener', lsnr);
            return null;
        }
        o = this.openListeners[id];
        if (o) {
            this.openListeners.delete(id);
        }
    };
    /**
     * Formulates an event message and sends it via the web-socket.
     * If the websocket is not up yet, we store it in a pending list.
     */
    /**
     * Formulates an event message and sends it via the web-socket.
     * If the websocket is not up yet, we store it in a pending list.
     * @param {?} evType
     * @param {?} payload
     * @return {?}
     */
    WebSocketService.prototype.sendEvent = /**
     * Formulates an event message and sends it via the web-socket.
     * If the websocket is not up yet, we store it in a pending list.
     * @param {?} evType
     * @param {?} payload
     * @return {?}
     */
    function (evType, payload) {
        /** @type {?} */
        var ev = (/** @type {?} */ ({
            event: evType,
            payload: payload
        }));
        if (this.wsUp) {
            this.send(ev);
        }
        else {
            this.pendingEvents.push(ev);
        }
    };
    /**
     * Binds the veil service as a delegate.
     */
    /**
     * Binds the veil service as a delegate.
     * @param {?} vd
     * @return {?}
     */
    WebSocketService.prototype.setVeilDelegate = /**
     * Binds the veil service as a delegate.
     * @param {?} vd
     * @return {?}
     */
    function (vd) {
        this.vcd = vd;
    };
    /**
     * Binds the loading service as a delegate
     */
    /**
     * Binds the loading service as a delegate
     * @param {?} ld
     * @return {?}
     */
    WebSocketService.prototype.setLoadingDelegate = /**
     * Binds the loading service as a delegate
     * @param {?} ld
     * @return {?}
     */
    function (ld) {
        // TODO - Investigate changing Loading Service to LoadingComponent
        this.log.debug('Loading delegate set', ld);
        this.lcd = ld;
    };
    /**
     * @return {?}
     */
    WebSocketService.prototype.isConnected = /**
     * @return {?}
     */
    function () {
        return this.wsUp;
    };
    WebSocketService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] },
    ];
    /** @nocollapse */
    WebSocketService.ctorParameters = function () { return [
        { type: FnService },
        { type: GlyphService },
        { type: LogService },
        { type: UrlFnService },
        { type: WSock },
        { type: undefined, decorators: [{ type: Inject, args: ['Window',] }] }
    ]; };
    /** @nocollapse */ WebSocketService.ngInjectableDef = i0.defineInjectable({ factory: function WebSocketService_Factory() { return new WebSocketService(i0.inject(i1.FnService), i0.inject(i2.GlyphService), i0.inject(i3.LogService), i0.inject(i4.UrlFnService), i0.inject(i5.WSock), i0.inject("Window")); }, token: WebSocketService, providedIn: "root" });
    return WebSocketService;
}());
export { WebSocketService };
if (false) {
    /** @type {?} */
    WebSocketService.prototype.webSockOpts;
    /** @type {?} */
    WebSocketService.prototype.ws;
    /** @type {?} */
    WebSocketService.prototype.wsUp;
    /** @type {?} */
    WebSocketService.prototype.handlers;
    /** @type {?} */
    WebSocketService.prototype.pendingEvents;
    /** @type {?} */
    WebSocketService.prototype.host;
    /** @type {?} */
    WebSocketService.prototype.url;
    /** @type {?} */
    WebSocketService.prototype.clusterNodes;
    /** @type {?} */
    WebSocketService.prototype.clusterIndex;
    /** @type {?} */
    WebSocketService.prototype.glyphs;
    /** @type {?} */
    WebSocketService.prototype.connectRetries;
    /** @type {?} */
    WebSocketService.prototype.openListeners;
    /** @type {?} */
    WebSocketService.prototype.nextListenerId;
    /** @type {?} */
    WebSocketService.prototype.loggedInUser;
    /** @type {?} */
    WebSocketService.prototype.lcd;
    /** @type {?} */
    WebSocketService.prototype.vcd;
    /** @type {?} */
    WebSocketService.prototype.fs;
    /** @type {?} */
    WebSocketService.prototype.gs;
    /** @type {?} */
    WebSocketService.prototype.log;
    /** @type {?} */
    WebSocketService.prototype.ufs;
    /** @type {?} */
    WebSocketService.prototype.wsock;
    /** @type {?} */
    WebSocketService.prototype.window;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2Vic29ja2V0LnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9ndWkyLWZ3LWxpYi8iLCJzb3VyY2VzIjpbImxpYi9yZW1vdGUvd2Vic29ja2V0LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDL0MsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3BELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM1QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFL0MsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7Ozs7Ozs7OztBQUt4QywrQkFHQzs7O0lBRkcsMEJBQWM7O0lBQ2QsNEJBQWdCOzs7OztBQUdwQiw4QkFJQzs7O0lBSEcsc0JBQVc7O0lBQ1gseUJBQWM7Ozs7OztJQUNkLGlEQUFvQzs7Ozs7QUFHeEMsMEJBSUM7OztJQUhHLHlCQUFXOztJQUNYLHlCQUFXOztJQUNYLG1DQUFzQjs7Ozs7QUFHMUIsb0JBSUM7OztJQUhHLG1CQUFXOztJQUNYLHdCQUFnQjs7SUFDaEIscUJBQWE7Ozs7O0FBR2pCLHdCQUlDOzs7SUFIRyx5QkFBYTs7SUFDYixpQ0FBNEI7O0lBQzVCLDJCQUFnQjs7Ozs7QUFHcEIsd0JBRUM7OztJQURHLDRCQUFnQjs7Ozs7QUFHcEIsK0JBRUM7OztJQURHLDJCQUFlOzs7Ozs7O0FBUW5CO0lBZ0VJLDBCQUNZLEVBQWEsRUFDYixFQUFnQixFQUNoQixHQUFlLEVBQ2YsR0FBaUIsRUFDakIsS0FBWSxFQUNNLE1BQVc7UUFOekMsaUJBaUJDO1FBaEJXLE9BQUUsR0FBRixFQUFFLENBQVc7UUFDYixPQUFFLEdBQUYsRUFB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OzsyQkExSXhCO0NBdWRDLEFBblpELElBbVpDO1NBaFpZLGdCQUFnQjs7O0lBRXpCLHVDQUErQjs7SUFDL0IsOEJBQTZCOztJQUM3QixnQ0FBOEI7O0lBRzlCLG9DQUE0RDs7SUFDNUQseUNBQXdDOztJQUN4QyxnQ0FBcUI7O0lBQ3JCLCtCQUFZOztJQUNaLHdDQUF5Qzs7SUFDekMsd0NBQTBCOztJQUMxQixrQ0FBNkI7O0lBQzdCLDBDQUFtQzs7SUFHbkMseUNBQXNEOztJQUN0RCwwQ0FBbUM7O0lBQ25DLHdDQUE0Qjs7SUFDNUIsK0JBQWlCOztJQUNqQiwrQkFBaUI7O0lBeUNiLDhCQUFxQjs7SUFDckIsOEJBQXdCOztJQUN4QiwrQkFBdUI7O0lBQ3ZCLCtCQUF5Qjs7SUFDekIsaUNBQW9COztJQUNwQixrQ0FBcUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMTgtcHJlc2VudCBPcGVuIE5ldHdvcmtpbmcgRm91bmRhdGlvblxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGblNlcnZpY2UgfSBmcm9tICcuLi91dGlsL2ZuLnNlcnZpY2UnO1xuaW1wb3J0IHsgR2x5cGhTZXJ2aWNlIH0gZnJvbSAnLi4vc3ZnL2dseXBoLnNlcnZpY2UnO1xuaW1wb3J0IHsgTG9nU2VydmljZSB9IGZyb20gJy4uL2xvZy5zZXJ2aWNlJztcbmltcG9ydCB7IFVybEZuU2VydmljZSB9IGZyb20gJy4vdXJsZm4uc2VydmljZSc7XG5pbXBvcnQgeyBWZWlsQ29tcG9uZW50IH0gZnJvbSAnLi4vbGF5ZXIvdmVpbC92ZWlsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBXU29jayB9IGZyb20gJy4vd3NvY2suc2VydmljZSc7XG5cbi8qKlxuICogRXZlbnQgVHlwZSBzdHJ1Y3R1cmUgZm9yIHRoZSBXZWJTb2NrZXRTZXJ2aWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRUeXBlIHtcbiAgICBldmVudDogc3RyaW5nO1xuICAgIHBheWxvYWQ6IE9iamVjdDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWxsYmFjayB7XG4gICAgaWQ6IG51bWJlcjtcbiAgICBlcnJvcjogc3RyaW5nO1xuICAgIGNiKGhvc3Q6IHN0cmluZywgdXJsOiBzdHJpbmcpOiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgQ2x1c3Rlck5vZGUge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgaXA6IHN0cmluZztcbiAgICBtX3VpQXR0YWNoZWQ6IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBHbHlwaCB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB2aWV3Ym94OiBzdHJpbmc7XG4gICAgcGF0aDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgQm9vdHN0cmFwIHtcbiAgICB1c2VyOiBzdHJpbmc7XG4gICAgY2x1c3Rlck5vZGVzOiBDbHVzdGVyTm9kZVtdO1xuICAgIGdseXBoczogR2x5cGhbXTtcbn1cblxuaW50ZXJmYWNlIEVycm9yRGF0YSB7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdzT3B0aW9ucyB7XG4gICAgd3Nwb3J0OiBudW1iZXI7XG59XG5cbi8qKlxuICogT05PUyBHVUkgLS0gUmVtb3RlIC0tIFdlYiBTb2NrZXQgU2VydmljZVxuICpcbiAqIFRvIHNlZSBkZWJ1ZyBtZXNzYWdlcyBhZGQgP2RlYnVnPXR4cnggdG8gdGhlIFVSTFxuICovXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgV2ViU29ja2V0U2VydmljZSB7XG4gICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICBwcml2YXRlIHdlYlNvY2tPcHRzOiBXc09wdGlvbnM7IC8vIHdlYiBzb2NrZXQgb3B0aW9uc1xuICAgIHByaXZhdGUgd3M6IFdlYlNvY2tldCA9IG51bGw7IC8vIHdlYiBzb2NrZXQgcmVmZXJlbmNlXG4gICAgcHJpdmF0ZSB3c1VwOiBib29sZWFuID0gZmFsc2U7IC8vIHdlYiBzb2NrZXQgaXMgZ29vZCB0byBnb1xuXG4gICAgLy8gQSBtYXAgb2YgZXZlbnQgaGFuZGxlciBiaW5kaW5ncyAtIG5hbWVzIGFuZCBmdW5jdGlvbnMgKHRoYXQgYWNjZXB0IGRhdGEgYW5kIHJldHVybiB2b2lkKVxuICAgIHByaXZhdGUgaGFuZGxlcnMgPSBuZXcgTWFwPHN0cmluZywgKGRhdGE6IGFueSkgPT4gdm9pZD4oW10pO1xuICAgIHByaXZhdGUgcGVuZGluZ0V2ZW50czogRXZlbnRUeXBlW10gPSBbXTsgLy8gZXZlbnRzIFRYJ2Qgd2hpbGUgc29ja2V0IG5vdCB1cFxuICAgIHByaXZhdGUgaG9zdDogc3RyaW5nOyAvLyB3ZWIgc29ja2V0IGhvc3RcbiAgICBwcml2YXRlIHVybDsgLy8gd2ViIHNvY2tldCBVUkxcbiAgICBwcml2YXRlIGNsdXN0ZXJOb2RlczogQ2x1c3Rlck5vZGVbXSA9IFtdOyAvLyBPTk9TIGluc3RhbmNlcyBkYXRhIGZvciBmYWlsb3ZlclxuICAgIHByaXZhdGUgY2x1c3RlckluZGV4ID0gLTE7IC8vIHRoZSBpbnN0YW5jZSB0byB3aGljaCB3ZSBhcmUgY29ubmVjdGVkXG4gICAgcHJpdmF0ZSBnbHlwaHM6IEdseXBoW10gPSBbXTtcbiAgICBwcml2YXRlIGNvbm5lY3RSZXRyaWVzOiBudW1iZXIgPSAwOyAvLyBsaW1pdCBvdXIgYXR0ZW1wdHMgYXQgcmVjb25uZWN0aW5nXG5cbiAgICAvLyBBIG1hcCBvZiByZWdpc3RlcmVkIENhbGxiYWNrcyBmb3Igd2Vic29ja2V0IG9wZW4oKVxuICAgIHByaXZhdGUgb3Blbkxpc3RlbmVycyA9IG5ldyBNYXA8bnVtYmVyLCBDYWxsYmFjaz4oW10pO1xuICAgIHByaXZhdGUgbmV4dExpc3RlbmVySWQ6IG51bWJlciA9IDE7IC8vIGludGVybmFsIElEIGZvciBvcGVuIGxpc3RlbmVyc1xuICAgIHByaXZhdGUgbG9nZ2VkSW5Vc2VyID0gbnVsbDsgLy8gbmFtZSBvZiBsb2dnZWQtaW4gdXNlclxuICAgIHByaXZhdGUgbGNkOiBhbnk7IC8vIFRoZSBsb2FkaW5nIGNvbXBvbmVudCBkZWxlZ2F0ZVxuICAgIHByaXZhdGUgdmNkOiBhbnk7IC8vIFRoZSB2ZWlsIGNvbXBvbmVudCBkZWxlZ2F0ZVxuXG4gICAgLyoqXG4gICAgICogYnVpbHQtaW4gaGFuZGxlciBmb3IgdGhlICdib29zdHJhcCcgZXZlbnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGJvb3RzdHJhcChkYXRhOiBCb290c3RyYXApIHtcbiAgICAgICAgdGhpcy5sb2dnZWRJblVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgIHRoaXMubG9nLmluZm8oJ1dlYnNvY2tldCBjb25uZWN0aW9uIGJvb3RzdHJhcGVkJywgZGF0YSk7XG5cbiAgICAgICAgdGhpcy5jbHVzdGVyTm9kZXMgPSBkYXRhLmNsdXN0ZXJOb2RlcztcbiAgICAgICAgdGhpcy5jbHVzdGVyTm9kZXMuZm9yRWFjaCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGQubV91aUF0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbHVzdGVySW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ0Nvbm5lY3RlZCB0byBjbHVzdGVyIG5vZGUgJyArIGQuaXApO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFkZCBjb25uZWN0IGluZm8gdG8gbWFzdGhlYWQgc29tZXdoZXJlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdseXBocyA9IGRhdGEuZ2x5cGhzO1xuICAgICAgICBjb25zdCBnbHlwaHNNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPihbXSk7XG4gICAgICAgIHRoaXMuZ2x5cGhzLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgICAgIGdseXBoc01hcC5zZXQoJ18nICsgZC5pZCwgZC52aWV3Ym94KTtcbiAgICAgICAgICAgIGdseXBoc01hcC5zZXQoZC5pZCwgZC5wYXRoKTtcbiAgICAgICAgICAgIHRoaXMuZ3MucmVnaXN0ZXJHbHlwaHMoZ2x5cGhzTWFwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBlcnJvcihkYXRhOiBFcnJvckRhdGEpIHtcbiAgICAgICAgY29uc3QgbTogc3RyaW5nID0gZGF0YS5tZXNzYWdlIHx8ICdlcnJvciBmcm9tIHNlcnZlcic7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKG0sIGRhdGEpO1xuXG4gICAgICAgIC8vIFVucmVjb3ZlcmFibGUgZXJyb3IgLSB0aHJvdyB1cCB0aGUgdmVpbC4uLlxuICAgICAgICBpZiAodGhpcy52Y2QpIHtcbiAgICAgICAgICAgIHRoaXMudmNkLnNob3coW1xuICAgICAgICAgICAgICAgICdPb3BzIScsXG4gICAgICAgICAgICAgICAgJ1NlcnZlciByZXBvcnRzIGVycm9yLi4uJyxcbiAgICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBmczogRm5TZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIGdzOiBHbHlwaFNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgbG9nOiBMb2dTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHVmczogVXJsRm5TZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHdzb2NrOiBXU29jayxcbiAgICAgICAgQEluamVjdCgnV2luZG93JykgcHJpdmF0ZSB3aW5kb3c6IGFueVxuICAgICkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1Zyh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpO1xuXG4gICAgICAgIC8vIEJpbmQgdGhlIGJvb3Qgc3RyYXAgZXZlbnQgYnkgZGVmYXVsdFxuICAgICAgICB0aGlzLmJpbmRIYW5kbGVycyhuZXcgTWFwPHN0cmluZywgKGRhdGEpID0+IHZvaWQ+KFtcbiAgICAgICAgICAgIFsnYm9vdHN0cmFwJywgKGRhdGEpID0+IHRoaXMuYm9vdHN0cmFwKGRhdGEpXSxcbiAgICAgICAgICAgIFsnZXJyb3InLCAoZGF0YSkgPT4gdGhpcy5lcnJvcihkYXRhKV1cbiAgICAgICAgXSkpO1xuXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdXZWJTb2NrZXRTZXJ2aWNlIGNvbnN0cnVjdGVkJyk7XG4gICAgfVxuXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vID09PSBXZWIgc29ja2V0IGNhbGxiYWNrc1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gV2ViU29ja2V0IGhhcyBqdXN0IG9wZW5lZFxuICAgICAqXG4gICAgICogTGlmdCB0aGUgVmVpbCBpZiBpdCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBJZiB0aGVyZSBhcmUgYW55IGV2ZW50cyBwZW5kaW5nLCBzZW5kIHRoZW1cbiAgICAgKiBNYXJrIHRoZSBXU1MgYXMgdXAgYW5kIGluZm9ybSBhbnkgbGlzdGVuZXJzIGZvciB0aGlzIG9wZW4gZXZlbnRcbiAgICAgKi9cbiAgICBoYW5kbGVPcGVuKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKCdXZWIgc29ja2V0IG9wZW4gLSAnLCB0aGlzLnVybCk7XG4gICAgICAgIC8vIEhpZGUgdGhlIHZlaWxcbiAgICAgICAgaWYgKHRoaXMudmNkKSB7XG4gICAgICAgICAgICB0aGlzLnZjZC5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mcy5kZWJ1Z09uKCd0eHJ4JykpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdTZW5kaW5nICcgKyB0aGlzLnBlbmRpbmdFdmVudHMubGVuZ3RoICsgJyBwZW5kaW5nIGV2ZW50KHMpLi4uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nRXZlbnRzLmZvckVhY2goKGV2KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlbmQoZXYpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRXZlbnRzID0gW107XG5cbiAgICAgICAgdGhpcy5jb25uZWN0UmV0cmllcyA9IDA7XG4gICAgICAgIHRoaXMud3NVcCA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5mb3JtTGlzdGVuZXJzKHRoaXMuaG9zdCwgdGhpcy51cmwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIFdlYlNvY2tldCBzZW5kIGEgbWVzc2FnZVxuICAgICAqL1xuICAgIGhhbmRsZU1lc3NhZ2UobXNnRXZlbnQ6IE1lc3NhZ2VFdmVudCk6IHZvaWQge1xuICAgICAgICBsZXQgZXY6IEV2ZW50VHlwZTtcbiAgICAgICAgbGV0IGg7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBldiA9IEpTT04ucGFyc2UobXNnRXZlbnQuZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdNZXNzYWdlLmRhdGEgaXMgbm90IHZhbGlkIEpTT04nLCBtc2dFdmVudC5kYXRhLCBlKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZzLmRlYnVnT24oJ3R4cngnKSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJyA8PCAqUngqICcsIGV2LmV2ZW50LCBldi5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBoID0gdGhpcy5oYW5kbGVycy5nZXQoZXYuZXZlbnQpO1xuICAgICAgICBpZiAoaCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoKGV2LnBheWxvYWQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdQcm9ibGVtIGhhbmRsaW5nIGV2ZW50OicsIGV2LCBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ1VuaGFuZGxlZCBldmVudDonLCBldik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYnkgdGhlIFdlYlNvY2tldCBpZiBpdCBpcyBjbG9zZWQgZnJvbSB0aGUgc2VydmVyIGVuZFxuICAgICAqXG4gICAgICogSWYgdGhlIGxvYWRpbmcgY29tcG9uZW50IGlzIHNob3duLCBjYWxsIHN0b3AoKSBvbiBpdFxuICAgICAqIFRyeSB0byBmaW5kIGFub3RoZXIgbm9kZSBpbiB0aGUgY2x1c3RlciB0byBjb25uZWN0IHRvXG4gICAgICogSWYgdGhpcyBpcyBub3QgcG9zc2libGUgdGhlbiBzaG93IHRoZSBWZWlsIENvbXBvbmVudFxuICAgICAqL1xuICAgIGhhbmRsZUNsb3NlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdXZWIgc29ja2V0IGNsb3NlZCcpO1xuICAgICAgICBpZiAodGhpcy5sY2QpIHtcbiAgICAgICAgICAgIHRoaXMubGNkLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndzVXAgPSBmYWxzZTtcbiAgICAgICAgbGV0IGdzdWNjO1xuXG4gICAgICAgIGlmIChnc3VjYyA9IHRoaXMuZmluZEd1aVN1Y2Nlc3NvcigpKSB7XG4gICAgICAgICAgICB0aGlzLnVybCA9IHRoaXMuY3JlYXRlV2ViU29ja2V0KHRoaXMud2ViU29ja09wdHMsIGdzdWNjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIG5vIGNvbnRyb2xsZXJzIGxlZnQgdG8gY29udGFjdCwgc2hvdyB0aGUgVmVpbC4uLlxuICAgICAgICAgICAgaWYgKHRoaXMudmNkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52Y2Quc2hvdyhbXG4gICAgICAgICAgICAgICAgICAgICdPb3BzIScsICAvLyBUT0RPOiBMb2NhbGl6ZSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICdXZWItc29ja2V0IGNvbm5lY3Rpb24gdG8gc2VydmVyIGNsb3NlZC4uLicsXG4gICAgICAgICAgICAgICAgICAgICdUcnkgcmVmcmVzaGluZyB0aGUgcGFnZS4nLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gPT09IFByaXZhdGUgSGVscGVyIEZ1bmN0aW9uc1xuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgbmV4dCBub2RlIGluIHRoZSBPTk9TIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzZWQgaWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNsb3NlcyBiZWNhdXNlIGFcbiAgICAgKiBub2RlIGluIHRoZSBjbHVzdGVyIGdlcyBkb3duIC0gZmFpbCBvdmVyIHNob3VsZCBiZSBhdXRvbWF0aWNcbiAgICAgKi9cbiAgICBmaW5kR3VpU3VjY2Vzc29yKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IG5jbiA9IHRoaXMuY2x1c3Rlck5vZGVzLmxlbmd0aDtcbiAgICAgICAgbGV0IGlwOiBzdHJpbmc7XG4gICAgICAgIGxldCBub2RlO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLmNvbm5lY3RSZXRyaWVzIDwgbmNuICYmICFpcCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0UmV0cmllcysrO1xuICAgICAgICAgICAgdGhpcy5jbHVzdGVySW5kZXggPSAodGhpcy5jbHVzdGVySW5kZXggKyAxKSAlIG5jbjtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLmNsdXN0ZXJOb2Rlc1t0aGlzLmNsdXN0ZXJJbmRleF07XG4gICAgICAgICAgICBpcCA9IG5vZGUgJiYgbm9kZS5pcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBXZWJTb2NrZXQgaXMgb3BlbmVkLCBpbmZvcm0gYW55IGxpc3RlbmVycyB0aGF0IHJlZ2lzdGVyZWRcbiAgICAgKiBmb3IgdGhhdCBldmVudFxuICAgICAqL1xuICAgIGluZm9ybUxpc3RlbmVycyhob3N0OiBzdHJpbmcsIHVybDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgY2JdIG9mIHRoaXMub3Blbkxpc3RlbmVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNiLmNiKGhvc3QsIHVybCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZW5kKGV2OiBFdmVudFR5cGUpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZnMuZGVidWdPbigndHhyeCcpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnICpUeCogPj4gJywgZXYuZXZlbnQsIGV2LnBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3Muc2VuZChKU09OLnN0cmluZ2lmeShldikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlIGFyZSBubyBXU1MgZXZlbnQgaGFuZGxlcnMgbGVmdFxuICAgICAqL1xuICAgIG5vSGFuZGxlcnNXYXJuKGhhbmRsZXJzOiBNYXA8c3RyaW5nLCBPYmplY3Q+LCBjYWxsZXI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIWhhbmRsZXJzIHx8IGhhbmRsZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ1dTUy4nICsgY2FsbGVyICsgJygpOiBubyBldmVudCBoYW5kbGVycycpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT1cbiAgICAgKiA9PT0gQVBJIEZ1bmN0aW9uc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmVxdWlyZWQgZm9yIHVuaXQgdGVzdHMgdG8gc2V0IHRvIGtub3duIHN0YXRlXG4gICAgICovXG4gICAgcmVzZXRTdGF0ZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy53ZWJTb2NrT3B0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy53cyA9IG51bGw7XG4gICAgICAgIHRoaXMud3NVcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhvc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudXJsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBlbmRpbmdFdmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5jbGVhcigpO1xuICAgICAgICB0aGlzLmNsdXN0ZXJOb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmNsdXN0ZXJJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmdseXBocyA9IFtdO1xuICAgICAgICB0aGlzLmNvbm5lY3RSZXRyaWVzID0gMDtcbiAgICAgICAgdGhpcy5vcGVuTGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMubmV4dExpc3RlbmVySWQgPSAxO1xuXG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDdXJyZW50bHkgc3VwcG9ydGVkIG9wdHM6XG4gICAgICogIHdzcG9ydDogd2ViIHNvY2tldCBwb3J0IChvdGhlciB0aGFuIGRlZmF1bHQgODE4MSlcbiAgICAgKiAgaG9zdDogICBpZiBkZWZpbmVkLCBpcyB0aGUgaG9zdCBhZGRyZXNzIHRvIHVzZVxuICAgICAqL1xuICAgIGNyZWF0ZVdlYlNvY2tldChvcHRzPzogV3NPcHRpb25zLCBob3N0Pzogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMud2ViU29ja09wdHMgPSBvcHRzOyAvLyBwcmVzZXJ2ZWQgZm9yIGZ1dHVyZSBjYWxsc1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0ID09PSB1bmRlZmluZWQgPyB0aGlzLndpbmRvdy5sb2NhdGlvbi5ob3N0IDogaG9zdDtcbiAgICAgICAgdGhpcy51cmwgPSB0aGlzLnVmcy53c1VybCgnY29yZScsIG9wdHMgPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0c1snd3Nwb3J0J10udG9TdHJpbmcoKSwgaG9zdCk7XG5cbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ0F0dGVtcHRpbmcgdG8gb3BlbiB3ZWJzb2NrZXQgdG86ICcgKyB0aGlzLnVybCk7XG4gICAgICAgIHRoaXMud3MgPSB0aGlzLndzb2NrLm5ld1dlYlNvY2tldCh0aGlzLnVybCk7XG4gICAgICAgIGlmICh0aGlzLndzKSB7XG4gICAgICAgICAgICAvLyBmYXQgYXJyb3cgPT4gc3ludGF4IG1lYW5zIHRoYXQgdGhlICd0aGlzJyBjb250ZXh0IHBhc3NlZCB3aWxsXG4gICAgICAgICAgICAvLyBiZSBvZiBXZWJTb2NrZXRTZXJ2aWNlLCBub3QgdGhlIFdlYlNvY2tldFxuICAgICAgICAgICAgdGhpcy53cy5vbm9wZW4gPSAoKCkgPT4gdGhpcy5oYW5kbGVPcGVuKCkpO1xuICAgICAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSAoKG1zZ0V2ZW50KSA9PiB0aGlzLmhhbmRsZU1lc3NhZ2UobXNnRXZlbnQpKTtcbiAgICAgICAgICAgIHRoaXMud3Mub25jbG9zZSA9ICgoKSA9PiB0aGlzLmhhbmRsZUNsb3NlKCkpO1xuICAgICAgICAgICAgY29uc3QgYXV0aFRva2VuID0gdGhpcy53aW5kb3dbJ29ub3NBdXRoJ107XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnQXV0aCBUb2tlbiBmb3Igb3BlbmluZyBXZWJTb2NrZXQnLCBhdXRoVG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5zZW5kRXZlbnQoJ2F1dGhlbnRpY2F0aW9uJywgeyB0b2tlbjogYXV0aFRva2VuIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IFdzb2NrIGxvZ3MgYW4gZXJyb3IgaWYgdGhlIG5ldyBXZWJTb2NrZXQgY2FsbCBmYWlsc1xuICAgICAgICByZXR1cm4gdGhpcy51cmw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbCB0aGUgV2ViU29ja2V0IHRvIGNsb3NlIC0gdGhpcyBzaG91bGQgY2FsbCB0aGUgaGFuZGxlQ2xvc2UoKSBtZXRob2RcbiAgICAgKi9cbiAgICBjbG9zZVdlYlNvY2tldCgpIHtcbiAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQmluZHMgdGhlIG1lc3NhZ2UgaGFuZGxlcnMgdG8gdGhlaXIgbWVzc2FnZSB0eXBlIChldmVudCB0eXBlKSBhc1xuICAgICAqICBzcGVjaWZpZWQgaW4gdGhlIGdpdmVuIG1hcC4gTm90ZSB0aGF0IGtleXMgYXJlIHRoZSBldmVudCBJRHM7IHZhbHVlc1xuICAgICAqICBhcmUgZWl0aGVyOlxuICAgICAqICAgICAqIHRoZSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uLCBvclxuICAgICAqICAgICAqIGFuIEFQSSBvYmplY3Qgd2hpY2ggaGFzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBrZXlcbiAgICAgKi9cbiAgICBiaW5kSGFuZGxlcnMoaGFuZGxlck1hcDogTWFwPHN0cmluZywgKGRhdGEpID0+IHZvaWQ+KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGR1cHM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMubm9IYW5kbGVyc1dhcm4oaGFuZGxlck1hcCwgJ2JpbmRIYW5kbGVycycpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtldmVudElkLCBhcGldIG9mIGhhbmRsZXJNYXApIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdBZGRpbmcgaGFuZGxlciBmb3IgJywgZXZlbnRJZCk7XG4gICAgICAgICAgICBjb25zdCBmbiA9IHRoaXMuZnMuaXNGKGFwaSkgfHwgdGhpcy5mcy5pc0YoYXBpW2V2ZW50SWRdKTtcbiAgICAgICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy53YXJuKGV2ZW50SWQgKyAnIGhhbmRsZXIgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhhbmRsZXJzLmdldChldmVudElkKSkge1xuICAgICAgICAgICAgICAgIGR1cHMucHVzaChldmVudElkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5zZXQoZXZlbnRJZCwgZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkdXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybignZHVwbGljYXRlIGJpbmRpbmdzIGlnbm9yZWQ6JywgZHVwcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmJpbmRzIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSBoYW5kbGVycy5cbiAgICAgKiAgIEV4cGVjdGVkIHRoYXQgdGhlIHNhbWUgbWFwIHdpbGwgYmUgdXNlZCwgYnV0IHdlIG9ubHkgY2FyZSBhYm91dCBrZXlzXG4gICAgICovXG4gICAgdW5iaW5kSGFuZGxlcnMoaGFuZGxlcklkczogc3RyaW5nW10pOiB2b2lkIHtcbiAgICAgICAgaWYgKCBoYW5kbGVySWRzLmxlbmd0aCA9PT0gMCApIHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ1dTUy51bmJpbmRIYW5kbGVycygpOiBubyBldmVudCBoYW5kbGVycycpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBldmVudElkIG9mIGhhbmRsZXJJZHMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMuZGVsZXRlKGV2ZW50SWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNIYW5kbGluZyhoYW5kbGVySWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVycy5nZXQoaGFuZGxlcklkKSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxpc3RlbmVyIGZ1bmN0aW9uIGZvciBsaXN0ZW5pbmcgZm9yIFdlYlNvY2tldCBvcGVuaW5nLlxuICAgICAqIFRoZSBmdW5jdGlvbiBtdXN0IGdpdmUgYSBob3N0IGFuZCB1cmwgYW5kIHJldHVybiB2b2lkXG4gICAgICovXG4gICAgYWRkT3Blbkxpc3RlbmVyKGNhbGxiYWNrOiAoaG9zdDogc3RyaW5nLCB1cmw6IHN0cmluZykgPT4gdm9pZCApOiBDYWxsYmFjayB7XG4gICAgICAgIGNvbnN0IGlkOiBudW1iZXIgPSB0aGlzLm5leHRMaXN0ZW5lcklkKys7XG4gICAgICAgIGNvbnN0IGNiID0gdGhpcy5mcy5pc0YoY2FsbGJhY2spO1xuICAgICAgICBjb25zdCBvOiBDYWxsYmFjayA9IDxDYWxsYmFjaz57IGlkOiBpZCwgY2I6IGNiIH07XG5cbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5MaXN0ZW5lcnMuc2V0KGlkLCBvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdXU1MuYWRkT3Blbkxpc3RlbmVyKCk6IGNhbGxiYWNrIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICBvLmVycm9yID0gJ05vIGNhbGxiYWNrIGRlZmluZWQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIG9mIFdlYlNvY2tldCBvcGVuaW5nXG4gICAgICovXG4gICAgcmVtb3ZlT3Blbkxpc3RlbmVyKGxzbnI6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5mcy5pc08obHNucikgJiYgbHNuci5pZDtcbiAgICAgICAgbGV0IG87XG5cbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybignV1NTLnJlbW92ZU9wZW5MaXN0ZW5lcigpOiBpbnZhbGlkIGxpc3RlbmVyJywgbHNucik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBvID0gdGhpcy5vcGVuTGlzdGVuZXJzW2lkXTtcblxuICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgdGhpcy5vcGVuTGlzdGVuZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtdWxhdGVzIGFuIGV2ZW50IG1lc3NhZ2UgYW5kIHNlbmRzIGl0IHZpYSB0aGUgd2ViLXNvY2tldC5cbiAgICAgKiBJZiB0aGUgd2Vic29ja2V0IGlzIG5vdCB1cCB5ZXQsIHdlIHN0b3JlIGl0IGluIGEgcGVuZGluZyBsaXN0LlxuICAgICAqL1xuICAgIHNlbmRFdmVudChldlR5cGU6IHN0cmluZywgcGF5bG9hZDogT2JqZWN0ICk6IHZvaWQge1xuICAgICAgICBjb25zdCBldiA9IDxFdmVudFR5cGU+IHtcbiAgICAgICAgICAgIGV2ZW50OiBldlR5cGUsXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMud3NVcCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kKGV2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0V2ZW50cy5wdXNoKGV2KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmRzIHRoZSB2ZWlsIHNlcnZpY2UgYXMgYSBkZWxlZ2F0ZS5cbiAgICAgKi9cbiAgICBzZXRWZWlsRGVsZWdhdGUodmQ6IFZlaWxDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy52Y2QgPSB2ZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyB0aGUgbG9hZGluZyBzZXJ2aWNlIGFzIGEgZGVsZWdhdGVcbiAgICAgKi9cbiAgICBzZXRMb2FkaW5nRGVsZWdhdGUobGQ6IGFueSk6IHZvaWQge1xuICAgICAgICAvLyBUT0RPIC0gSW52ZXN0aWdhdGUgY2hhbmdpbmcgTG9hZGluZyBTZXJ2aWNlIHRvIExvYWRpbmdDb21wb25lbnRcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ0xvYWRpbmcgZGVsZWdhdGUgc2V0JywgbGQpO1xuICAgICAgICB0aGlzLmxjZCA9IGxkO1xuICAgIH1cblxuICAgIGlzQ29ubmVjdGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy53c1VwO1xuICAgIH1cbn1cbiJdfQ==