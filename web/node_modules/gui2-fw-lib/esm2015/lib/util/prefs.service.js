/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/*
 * Copyright 2018-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Inject, Injectable } from '@angular/core';
import { FnService } from './fn.service';
import { LogService } from '../log.service';
import { WebSocketService } from '../remote/websocket.service';
import * as i0 from "@angular/core";
import * as i1 from "./fn.service";
import * as i2 from "../log.service";
import * as i3 from "../remote/websocket.service";
/** @type {?} */
const UPDATE_PREFS = 'updatePrefs';
/** @type {?} */
const UPDATE_PREFS_REQ = 'updatePrefReq';
/**
 * ONOS GUI -- Util -- User Preference Service
 */
export class PrefsService {
    /**
     * @param {?} fs
     * @param {?} log
     * @param {?} wss
     * @param {?} window
     */
    constructor(fs, log, wss, window) {
        this.fs = fs;
        this.log = log;
        this.wss = wss;
        this.window = window;
        this.handlers = [];
        this.listeners = [];
        this.wss.bindHandlers(new Map([
            [UPDATE_PREFS, (data) => this.updatePrefs(data)]
        ]));
        this.handlers.push(UPDATE_PREFS);
        // When index.html is fetched it is served up by MainIndexResource.java
        // which fetches userPrefs in to the global scope.
        // After that updates are done through WebSocket
        this.cache = Object.assign({}, this.window['userPrefs']);
        this.log.debug('PrefsService constructed');
    }
    /**
     * @param {?} name
     * @param {?} obj
     * @return {?}
     */
    setPrefs(name, obj) {
        // keep a cached copy of the object and send an update to server
        this.cache[name] = obj;
        this.wss.sendEvent(UPDATE_PREFS_REQ, { key: name, value: obj });
    }
    /**
     * @param {?} data
     * @return {?}
     */
    updatePrefs(data) {
        this.cache = data;
        this.listeners.forEach((lsnr) => lsnr(data));
    }
    /**
     * @param {?} obj
     * @param {?=} keys
     * @param {?=} not
     * @return {?}
     */
    asNumbers(obj, keys, not) {
        if (!obj) {
            return null;
        }
        /** @type {?} */
        const skip = {};
        if (not) {
            keys.forEach(k => {
                skip[k] = 1;
            });
        }
        if (!keys || not) {
            // do them all
            Array.from(obj).forEach((v, k) => {
                if (!not || !skip[k]) {
                    obj[k] = Number(obj[k]);
                }
            });
        }
        else {
            // do the explicitly named keys
            keys.forEach(k => {
                obj[k] = Number(obj[k]);
            });
        }
        return obj;
    }
    /**
     * @param {?} name
     * @param {?} defaults
     * @param {?=} qparams
     * @return {?}
     */
    getPrefs(name, defaults, qparams) {
        /** @type {?} */
        const obj = Object.assign({}, defaults || {}, this.cache[name] || {});
        // if query params are specified, they override...
        if (this.fs.isO(qparams)) {
            obj.forEach(k => {
                if (qparams.hasOwnProperty(k)) {
                    obj[k] = qparams[k];
                }
            });
        }
        return obj;
    }
    // merge preferences:
    // The assumption here is that obj is a sparse object, and that the
    //  defined keys should overwrite the corresponding values, but any
    //  existing keys that are NOT explicitly defined here should be left
    //  alone (not deleted).
    /**
     * @param {?} name
     * @param {?} obj
     * @return {?}
     */
    mergePrefs(name, obj) {
        /** @type {?} */
        const merged = this.cache[name] || {};
        this.setPrefs(name, Object.assign(merged, obj));
    }
    /**
     * Add a listener function
     * This will get called back when an 'updatePrefs' message is received on WSS
     * @param {?} listener a function that can accept one param - data
     * @return {?}
     */
    addListener(listener) {
        this.listeners.push(listener);
    }
    /**
     * @param {?} listener
     * @return {?}
     */
    removeListener(listener) {
        this.listeners = this.listeners.filter((obj) => obj !== listener);
    }
}
PrefsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] },
];
/** @nocollapse */
PrefsService.ctorParameters = () => [
    { type: FnService },
    { type: LogService },
    { type: WebSocketService },
    { type: undefined, decorators: [{ type: Inject, args: ['Window',] }] }
];
/** @nocollapse */ PrefsService.ngInjectableDef = i0.defineInjectable({ factory: function PrefsService_Factory() { return new PrefsService(i0.inject(i1.FnService), i0.inject(i2.LogService), i0.inject(i3.WebSocketService), i0.inject("Window")); }, token: PrefsService, providedIn: "root" });
if (false) {
    /** @type {?} */
    PrefsService.prototype.handlers;
    /** @type {?} */
    PrefsService.prototype.cache;
    /** @type {?} */
    PrefsService.prototype.listeners;
    /** @type {?} */
    PrefsService.prototype.fs;
    /** @type {?} */
    PrefsService.prototype.log;
    /** @type {?} */
    PrefsService.prototype.wss;
    /** @type {?} */
    PrefsService.prototype.window;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJlZnMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2d1aTItZnctbGliLyIsInNvdXJjZXMiOlsibGliL3V0aWwvcHJlZnMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsT0FBTyxFQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDakQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN6QyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDNUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7Ozs7OztNQUV6RCxZQUFZLEdBQVcsYUFBYTs7TUFDcEMsZ0JBQWdCLEdBQVcsZUFBZTs7OztBQVNoRCxNQUFNLE9BQU8sWUFBWTs7Ozs7OztJQUlyQixZQUNjLEVBQWEsRUFDYixHQUFlLEVBQ2YsR0FBcUIsRUFDTCxNQUFXO1FBSDNCLE9BQUUsR0FBRixFQUFFLENBQVc7UUFDYixRQUFHLEdBQUgsR0FBRyxDQUFZO1FBQ2YsUUFBRyxHQUFILEdBQUcsQ0FBa0I7UUFDTCxXQUFNLEdBQU4sTUFBTSxDQUFLO1FBUC9CLGFBQVEsR0FBYSxFQUFFLENBQUM7UUFFbEMsY0FBUyxHQUF1QixFQUFFLENBQUM7UUFPL0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsSUFBSSxHQUFHLENBQXlCO1lBQ2xELENBQUMsWUFBWSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ25ELENBQUMsQ0FBQyxDQUFDO1FBQ0osSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFakMsdUVBQXVFO1FBQ3ZFLGtEQUFrRDtRQUNsRCxnREFBZ0Q7UUFDaEQsSUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsTUFBTSxD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TSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDcEQsQ0FBQzs7Ozs7OztJQU9ELFdBQVcsQ0FBQyxRQUF3QjtRQUNoQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNsQyxDQUFDOzs7OztJQUVELGNBQWMsQ0FBQyxRQUF3QjtRQUNuQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEtBQUssUUFBUSxDQUFDLENBQUM7SUFDdEUsQ0FBQzs7O1lBcEdKLFVBQVUsU0FBQztnQkFDUixVQUFVLEVBQUUsTUFBTTthQUNyQjs7OztZQWJRLFNBQVM7WUFDVCxVQUFVO1lBQ1YsZ0JBQWdCOzRDQW9CaEIsTUFBTSxTQUFDLFFBQVE7Ozs7O0lBUHBCLGdDQUFrQzs7SUFDbEMsNkJBQWM7O0lBQ2QsaUNBQW1DOztJQUUvQiwwQkFBdUI7O0lBQ3ZCLDJCQUF5Qjs7SUFDekIsMkJBQStCOztJQUMvQiw4QkFBcUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMTgtcHJlc2VudCBPcGVuIE5ldHdvcmtpbmcgRm91bmRhdGlvblxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHtJbmplY3QsIEluamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm5TZXJ2aWNlIH0gZnJvbSAnLi9mbi5zZXJ2aWNlJztcbmltcG9ydCB7IExvZ1NlcnZpY2UgfSBmcm9tICcuLi9sb2cuc2VydmljZSc7XG5pbXBvcnQgeyBXZWJTb2NrZXRTZXJ2aWNlIH0gZnJvbSAnLi4vcmVtb3RlL3dlYnNvY2tldC5zZXJ2aWNlJztcblxuY29uc3QgVVBEQVRFX1BSRUZTOiBzdHJpbmcgPSAndXBkYXRlUHJlZnMnO1xuY29uc3QgVVBEQVRFX1BSRUZTX1JFUTogc3RyaW5nID0gJ3VwZGF0ZVByZWZSZXEnO1xuXG5cbi8qKlxuICogT05PUyBHVUkgLS0gVXRpbCAtLSBVc2VyIFByZWZlcmVuY2UgU2VydmljZVxuICovXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBQcmVmc1NlcnZpY2Uge1xuICAgIHByb3RlY3RlZCBoYW5kbGVyczogc3RyaW5nW10gPSBbXTtcbiAgICBjYWNoZTogT2JqZWN0O1xuICAgIGxpc3RlbmVyczogKChkYXRhKSA9PiB2b2lkKVtdID0gW107XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByb3RlY3RlZCBmczogRm5TZXJ2aWNlLFxuICAgICAgICBwcm90ZWN0ZWQgbG9nOiBMb2dTZXJ2aWNlLFxuICAgICAgICBwcm90ZWN0ZWQgd3NzOiBXZWJTb2NrZXRTZXJ2aWNlLFxuICAgICAgICBASW5qZWN0KCdXaW5kb3cnKSBwcml2YXRlIHdpbmRvdzogYW55XG4gICAgKSB7XG4gICAgICAgIHRoaXMud3NzLmJpbmRIYW5kbGVycyhuZXcgTWFwPHN0cmluZywgKGRhdGEpID0+IHZvaWQ+KFtcbiAgICAgICAgICAgIFtVUERBVEVfUFJFRlMsIChkYXRhKSA9PiB0aGlzLnVwZGF0ZVByZWZzKGRhdGEpXVxuICAgICAgICBdKSk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaChVUERBVEVfUFJFRlMpO1xuXG4gICAgICAgIC8vIFdoZW4gaW5kZXguaHRtbCBpcyBmZXRjaGVkIGl0IGlzIHNlcnZlZCB1cCBieSBNYWluSW5kZXhSZXNvdXJjZS5qYXZhXG4gICAgICAgIC8vIHdoaWNoIGZldGNoZXMgdXNlclByZWZzIGluIHRvIHRoZSBnbG9iYWwgc2NvcGUuXG4gICAgICAgIC8vIEFmdGVyIHRoYXQgdXBkYXRlcyBhcmUgZG9uZSB0aHJvdWdoIFdlYlNvY2tldFxuICAgICAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy53aW5kb3dbJ3VzZXJQcmVmcyddKTtcblxuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnUHJlZnNTZXJ2aWNlIGNvbnN0cnVjdGVkJyk7XG4gICAgfVxuXG4gICAgc2V0UHJlZnMobmFtZTogc3RyaW5nLCBvYmo6IE9iamVjdCkge1xuICAgICAgICAvLyBrZWVwIGEgY2FjaGVkIGNvcHkgb2YgdGhlIG9iamVjdCBhbmQgc2VuZCBhbiB1cGRhdGUgdG8gc2VydmVyXG4gICAgICAgIHRoaXMuY2FjaGVbbmFtZV0gPSBvYmo7XG4gICAgICAgIHRoaXMud3NzLnNlbmRFdmVudChVUERBVEVfUFJFRlNfUkVRLCB7IGtleTogbmFtZSwgdmFsdWU6IG9iaiB9KTtcbiAgICB9XG4gICAgdXBkYXRlUHJlZnMoZGF0YTogYW55KSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBkYXRhO1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsc25yKSA9PiBsc25yKGRhdGEpICk7XG4gICAgfVxuXG4gICAgYXNOdW1iZXJzKG9iajogYW55LCBrZXlzPzogYW55LCBub3Q/OiBhbnkpIHtcbiAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2tpcCA9IHt9O1xuICAgICAgICBpZiAobm90KSB7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICAgICAgc2tpcFtrXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXlzIHx8IG5vdCkge1xuICAgICAgICAgICAgLy8gZG8gdGhlbSBhbGxcbiAgICAgICAgICAgIEFycmF5LmZyb20ob2JqKS5mb3JFYWNoKCh2LCBrKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFub3QgfHwgIXNraXBba10pIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tdID0gTnVtYmVyKG9ialtrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkbyB0aGUgZXhwbGljaXRseSBuYW1lZCBrZXlzXG4gICAgICAgICAgICBrZXlzLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICAgICAgb2JqW2tdID0gTnVtYmVyKG9ialtrXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGdldFByZWZzKG5hbWU6IHN0cmluZywgZGVmYXVsdHM6IE9iamVjdCwgcXBhcmFtcz86IHN0cmluZykge1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyB8fCB7fSwgdGhpcy5jYWNoZVtuYW1lXSB8fCB7fSk7XG5cbiAgICAgICAgLy8gaWYgcXVlcnkgcGFyYW1zIGFyZSBzcGVjaWZpZWQsIHRoZXkgb3ZlcnJpZGUuLi5cbiAgICAgICAgaWYgKHRoaXMuZnMuaXNPKHFwYXJhbXMpKSB7XG4gICAgICAgICAgICBvYmouZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocXBhcmFtcy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmpba10gPSBxcGFyYW1zW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgLy8gbWVyZ2UgcHJlZmVyZW5jZXM6XG4gICAgLy8gVGhlIGFzc3VtcHRpb24gaGVyZSBpcyB0aGF0IG9iaiBpcyBhIHNwYXJzZSBvYmplY3QsIGFuZCB0aGF0IHRoZVxuICAgIC8vICBkZWZpbmVkIGtleXMgc2hvdWxkIG92ZXJ3cml0ZSB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMsIGJ1dCBhbnlcbiAgICAvLyAgZXhpc3Rpbmcga2V5cyB0aGF0IGFyZSBOT1QgZXhwbGljaXRseSBkZWZpbmVkIGhlcmUgc2hvdWxkIGJlIGxlZnRcbiAgICAvLyAgYWxvbmUgKG5vdCBkZWxldGVkKS5cbiAgICBtZXJnZVByZWZzKG5hbWU6IHN0cmluZywgb2JqOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gdGhpcy5jYWNoZVtuYW1lXSB8fCB7fTtcbiAgICAgICAgdGhpcy5zZXRQcmVmcyhuYW1lLCBPYmplY3QuYXNzaWduKG1lcmdlZCwgb2JqKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgZnVuY3Rpb25cbiAgICAgKiBUaGlzIHdpbGwgZ2V0IGNhbGxlZCBiYWNrIHdoZW4gYW4gJ3VwZGF0ZVByZWZzJyBtZXNzYWdlIGlzIHJlY2VpdmVkIG9uIFdTU1xuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBhIGZ1bmN0aW9uIHRoYXQgY2FuIGFjY2VwdCBvbmUgcGFyYW0gLSBkYXRhXG4gICAgICovXG4gICAgYWRkTGlzdGVuZXIobGlzdGVuZXI6IChkYXRhKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIHJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyOiAoZGF0YSkgPT4gdm9pZCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzLmZpbHRlcigob2JqKSA9PiBvYmogIT09IGxpc3RlbmVyKTtcbiAgICB9XG5cbn1cbiJdfQ==