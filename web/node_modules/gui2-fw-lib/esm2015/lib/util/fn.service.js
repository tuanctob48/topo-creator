/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/*
 * Copyright 2018-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Inject, Injectable } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { LogService } from '../log.service';
import { Trie, TrieOp } from './trie';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "../log.service";
/** @type {?} */
const matcher = /<\/?([a-zA-Z0-9]+)*(.*?)\/?>/igm;
/** @type {?} */
const whitelist = ['b', 'i', 'p', 'em', 'strong', 'br'];
/** @type {?} */
const evillist = ['script', 'style', 'iframe'];
/**
 * Used with the Window size function;
 *
 * @record
 */
export function WindowSize() { }
if (false) {
    /** @type {?} */
    WindowSize.prototype.width;
    /** @type {?} */
    WindowSize.prototype.height;
}
/**
 * For the sanitize() and analyze() functions
 * @record
 */
export function Match() { }
if (false) {
    /** @type {?} */
    Match.prototype.full;
    /** @type {?} */
    Match.prototype.name;
}
/**
 * ONOS GUI -- Util -- General Purpose Functions
 */
export class FnService {
    /**
     * @param {?} route
     * @param {?} log
     * @param {?} w
     */
    constructor(route, log, w) {
        this.route = route;
        this.log = log;
        this.w = w;
        // internal state
        this.debugFlags = new Map([
        //        [ "LoadingService", true ]
        ]);
        this.route.queryParams.subscribe(params => {
            /** @type {?} */
            const debugparam = params['debug'];
            //            log.debug('Param:', debugparam);
            this.parseDebugFlags(debugparam);
        });
        //        this.log.debug('FnService constructed');
    }
    /**
     * Test if an argument is a function
     *
     * Note: the need for this would go away if all functions
     * were strongly typed
     * @param {?} f
     * @return {?}
     */
    isF(f) {
        return typeof f === 'function' ? f : null;
    }
    /**
     * Test if an argument is an array
     *
     * Note: the need for this would go away if all arrays
     * were strongly typed
     * @param {?} a
     * @return {?}
     */
    isA(a) {
        // NOTE: Array.isArray() is part of EMCAScript 5.1
        return Array.isArray(a) ? a : null;
    }
    /**
     * Test if an argument is a string
     *
     * Note: the need for this would go away if all strings
     * were strongly typed
     * @param {?} s
     * @return {?}
     */
    isS(s) {
        return typeof s === 'string' ? s : null;
    }
    /**
     * Test if an argument is an object
     *
     * Note: the need for this would go away if all objects
     * were strongly typed
     * @param {?} o
     * @return {?}
     */
    isO(o) {
        return (o && typeof o === 'object' && o.constructor === Object) ? o : null;
    }
    /**
     * Test that an array contains an object
     * @param {?} a
     * @param {?} x
     * @return {?}
     */
    contains(a, x) {
        return this.isA(a) && a.indexOf(x) > -1;
    }
    /**
     * Returns width and height of window inner dimensions.
     * offH, offW : offset width/height are subtracted, if present
     * @param {?=} offH
     * @param {?=} offW
     * @return {?}
     */
    windowSize(offH = 0, offW = 0) {
        return {
            height: this.w.innerHeight - offH,
            width: this.w.innerWidth - offW
        };
    }
    /**
     * Returns true if all names in the array are defined as functions
     * on the given api object; false otherwise.
     * Also returns false if there are properties on the api that are NOT
     * listed in the array of names.
     *
     * This gets extra complicated when the api Object is an
     * Angular service - while the functions can be retrieved
     * by an indexed get, the ownProperties does not show the
     * functions of the class. We have to dive in to the prototypes
     * properties to get these - and even then we have to filter
     * out the constructor and any member variables
     * @param {?} api
     * @param {?} fnNames
     * @return {?}
     */
    areFunctions(api, fnNames) {
        /** @type {?} */
        const fnLookup = new Map();
        /** @type {?} */
        let extraFound = false;
        if (!this.isA(fnNames)) {
            return false;
        }
        /** @type {?} */
        const n = fnNames.length;
        /** @type {?} */
        let i;
        /** @type {?} */
        let name;
        for (i = 0; i < n; i++) {
            name = fnNames[i];
            if (!this.isF(api[name])) {
                return false;
            }
            fnLookup.set(name, true);
        }
        // check for properties on the API that are not listed in the array,
        /** @type {?} */
        const keys = Object.getOwnPropertyNames(api);
        if (keys.length === 0) {
            return true;
        }
        // If the api is a class it will have a name,
        //  else it will just be called 'Object'
        /** @type {?} */
        const apiObjectName = api.constructor.name;
        if (apiObjectName === 'Object') {
            Object.keys(api).forEach((key) => {
                if (!fnLookup.get(key)) {
                    extraFound = true;
                }
            });
        }
        else { // It is a class, so its functions will be in the child (prototype)
            // It is a class, so its functions will be in the child (prototype)
            /** @type {?} */
            const pObj = Object.getPrototypeOf(api);
            for (const key in Object.getOwnPropertyDescriptors(pObj)) {
                if (key === 'constructor') { // Filter out constructor
                    continue;
                }
                /** @type {?} */
                const value = Object.getOwnPropertyDescriptor(pObj, key);
                // Only compare functions. Look for any not given in the map
                if (this.isF(value.value) && !fnLookup.get(key)) {
                    extraFound = true;
                }
            }
        }
        return !extraFound;
    }
    /**
     * Returns true if all names in the array are defined as functions
     * on the given api object; false otherwise. This is a non-strict version
     * that does not care about other properties on the api.
     * @param {?} api
     * @param {?} fnNames
     * @return {?}
     */
    areFunctionsNonStrict(api, fnNames) {
        if (!this.isA(fnNames)) {
            return false;
        }
        /** @type {?} */
        const n = fnNames.length;
        /** @type {?} */
        let i;
        /** @type {?} */
        let name;
        for (i = 0; i < n; i++) {
            name = fnNames[i];
            if (!this.isF(api[name])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns true if current browser determined to be a mobile device
     * @return {?}
     */
    isMobile() {
        /** @type {?} */
        const ua = this.w.navigator.userAgent;
        /** @type {?} */
        const patt = /iPhone|iPod|iPad|Silk|Android|BlackBerry|Opera Mini|IEMobile/;
        return patt.test(ua);
    }
    /**
     * Returns true if the current browser determined to be Chrome
     * @return {?}
     */
    isChrome() {
        /** @type {?} */
        const isChromium = ((/** @type {?} */ (this.w))).chrome;
        /** @type {?} */
        const vendorName = this.w.navigator.vendor;
        /** @type {?} */
        const isOpera = this.w.navigator.userAgent.indexOf('OPR') > -1;
        return (isChromium !== null &&
            isChromium !== undefined &&
            vendorName === 'Google Inc.' &&
            isOpera === false);
    }
    /**
     * @return {?}
     */
    isChromeHeadless() {
        /** @type {?} */
        const vendorName = this.w.navigator.vendor;
        /** @type {?} */
        const headlessChrome = this.w.navigator.userAgent.indexOf('HeadlessChrome') > -1;
        return (vendorName === 'Google Inc.' && headlessChrome === true);
    }
    /**
     * Returns true if the current browser determined to be Safari
     * @return {?}
     */
    isSafari() {
        return (this.w.navigator.userAgent.indexOf('Safari') !== -1 &&
            this.w.navigator.userAgent.indexOf('Chrome') === -1);
    }
    /**
     * Returns true if the current browser determined to be Firefox
     * @return {?}
     */
    isFirefox() {
        return typeof InstallTrigger !== 'undefined';
    }
    /**
     * search through an array of objects, looking for the one with the
     * tagged property matching the given key. tag defaults to 'id'.
     * returns the index of the matching object, or -1 for no match.
     * @param {?} key
     * @param {?} array
     * @param {?=} tag
     * @return {?}
     */
    find(key, array, tag = 'id') {
        /** @type {?} */
        let idx;
        /** @type {?} */
        const n = array.length;
        for (idx = 0; idx < n; idx++) {
            /** @type {?} */
            const d = array[idx];
            if (d[tag] === key) {
                return idx;
            }
        }
        return -1;
    }
    /**
     * search through array to find (the first occurrence of) item,
     * returning its index if found; otherwise returning -1.
     * @param {?} item
     * @param {?} array
     * @return {?}
     */
    inArray(item, array) {
        if (this.isA(array)) {
            for (let i = 0; i < array.length; i++) {
                if (array[i] === item) {
                    return i;
                }
            }
        }
        return -1;
    }
    /**
     * remove (the first occurrence of) the specified item from the given
     * array, if any. Return true if the removal was made; false otherwise.
     * @param {?} item
     * @param {?} array
     * @return {?}
     */
    removeFromArray(item, array) {
        /** @type {?} */
        const i = this.inArray(item, array);
        if (i >= 0) {
            array.splice(i, 1);
            return true;
        }
        return false;
    }
    /**
     * return true if the object is empty, return false otherwise
     * @param {?} obj
     * @return {?}
     */
    isEmptyObject(obj) {
        for (const key in obj) {
            if (true) {
                return false;
            }
        }
        return true;
    }
    /**
     * returns true if the two objects have all the same properties
     * @param {?} obj1
     * @param {?} obj2
     * @return {?}
     */
    sameObjProps(obj1, obj2) {
        for (const key in obj1) {
            if (obj1.hasOwnProperty(key)) {
                if (!(obj1[key] === obj2[key])) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * returns true if the array contains the object
     * does NOT use strict object reference equality,
     * instead checks each property individually for equality
     * @param {?} arr
     * @param {?} obj
     * @return {?}
     */
    containsObj(arr, obj) {
        /** @type {?} */
        const len = arr.length;
        for (let i = 0; i < len; i++) {
            if (this.sameObjProps(arr[i], obj)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Return the given string with the first character capitalized.
     * @param {?} s
     * @return {?}
     */
    cap(s) {
        return s ? s[0].toUpperCase() + s.slice(1).toLowerCase() : s;
    }
    /**
     * return the parameter without a px suffix
     * @param {?} num
     * @return {?}
     */
    noPx(num) {
        return Number(num.replace(/px$/, ''));
    }
    /**
     * return an element's given style property without px suffix
     * @param {?} elem
     * @param {?} prop
     * @return {?}
     */
    noPxStyle(elem, prop) {
        return Number(elem.style(prop).replace(/px$/, ''));
    }
    /**
     * Return true if a str ends with suffix
     * @param {?} str
     * @param {?} suffix
     * @return {?}
     */
    endsWith(str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }
    /**
     * output debug message to console, if debug tag set...
     * e.g. fs.debug('mytag', arg1, arg2, ...)
     * @param {?} tag
     * @param {...?} args
     * @return {?}
     */
    debug(tag, ...args) {
        if (this.debugFlags.get(tag)) {
            //            this.log.debug(tag, args.join());
        }
    }
    /**
     * @param {?} dbgstr
     * @return {?}
     */
    parseDebugFlags(dbgstr) {
        /** @type {?} */
        const bits = dbgstr ? dbgstr.split(',') : [];
        bits.forEach((key) => {
            this.debugFlags.set(key, true);
        });
        //        this.log.debug('Debug flags:', dbgstr);
    }
    /**
     * Return true if the given debug flag was specified in the query params
     * @param {?} tag
     * @return {?}
     */
    debugOn(tag) {
        return this.debugFlags.get(tag);
    }
    // -----------------------------------------------------------------
    // The next section deals with sanitizing external strings destined
    // to be loaded via a .html() function call.
    //
    // See definition of matcher, evillist and whitelist at the top of this file
    /*
         * Returns true if the tag is in the evil list, (and is not an end-tag)
         */
    /**
     * @param {?} tag
     * @return {?}
     */
    inEvilList(tag) {
        return (evillist.indexOf(tag.name) !== -1 && tag.full.indexOf('/') === -1);
    }
    /*
         * Returns an array of Matches of matcher in html
         */
    /**
     * @param {?} html
     * @return {?}
     */
    analyze(html) {
        /** @type {?} */
        const matches = [];
        /** @type {?} */
        let match;
        // extract all tags
        while ((match = matcher.exec(html)) !== null) {
            matches.push({
                full: match[0],
                name: match[1],
            });
        }
        return matches;
    }
    /*
         * Returns a cleaned version of html
         */
    /**
     * @param {?} html
     * @return {?}
     */
    sanitize(html) {
        /** @type {?} */
        const matches = this.analyze(html);
        // completely obliterate evil tags and their contents...
        evillist.forEach((tag) => {
            /** @type {?} */
            const re = new RegExp('<' + tag + '(.*?)>(.*?[\r\n])*?(.*?)(.*?[\r\n])*?<\/' + tag + '>', 'gim');
            html = html.replace(re, '');
        });
        // filter out all but white-listed tags and end-tags
        matches.forEach((tag) => {
            if (whitelist.indexOf(tag.name) === -1) {
                html = html.replace(tag.full, '');
                if (this.inEvilList(tag)) {
                    this.log.warn('Unsanitary HTML input -- ' +
                        tag.full + ' detected!');
                }
            }
        });
        // TODO: consider encoding HTML entities, e.g. '&' -> '&amp;'
        return html;
    }
    /**
     * add word to trie (word will be converted to uppercase)
     * data associated with the word
     * returns 'added' or 'updated'
     * @param {?} trie
     * @param {?} word
     * @param {?} data
     * @return {?}
     */
    addToTrie(trie, word, data) {
        return new Trie(TrieOp.PLUS, trie, word, data);
    }
    /**
     * remove word from trie (word will be converted to uppercase)
     * returns 'removed' or 'absent'
     * @param {?} trie
     * @param {?} word
     * @return {?}
     */
    removeFromTrie(trie, word) {
        return new Trie(TrieOp.MINUS, trie, word);
    }
    /**
     * lookup word (converted to uppercase) in trie
     * returns:
     *    undefined if the word is not in the trie
     *    -1 for a partial match (word is a prefix to an existing word)
     *    data for the word for an exact match
     * @param {?} trie
     * @param {?} word
     * @return {?}
     */
    trieLookup(trie, word) {
        /** @type {?} */
        const s = word.toUpperCase().split('');
        /** @type {?} */
        let p = trie;
        /** @type {?} */
        let n;
        while (s.length) {
            n = s.shift();
            p = p[n];
            if (!p) {
                return undefined;
            }
        }
        if (p._data) {
            return p._data;
        }
        return -1;
    }
}
FnService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] },
];
/** @nocollapse */
FnService.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: LogService },
    { type: undefined, decorators: [{ type: Inject, args: ['Window',] }] }
];
/** @nocollapse */ FnService.ngInjectableDef = i0.defineInjectable({ factory: function FnService_Factory() { return new FnService(i0.inject(i1.ActivatedRoute), i0.inject(i2.LogService), i0.inject("Window")); }, token: FnService, providedIn: "root" });
if (false) {
    /** @type {?} */
    FnService.prototype.debugFlags;
    /** @type {?} */
    FnService.prototype.route;
    /** @type {?} */
    FnService.prototype.log;
    /** @type {?} */
    FnService.prototype.w;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm4uc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2d1aTItZnctbGliLyIsInNvdXJjZXMiOlsibGliL3V0aWwvZm4uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsT0FBTyxFQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDakQsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUMxQyxPQUFPLEVBQUMsSUFBSSxFQUFFLE1BQU0sRUFBQyxNQUFNLFFBQVEsQ0FBQzs7Ozs7TUFLOUIsT0FBTyxHQUFHLGlDQUFpQzs7TUFDM0MsU0FBUyxHQUFhLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUM7O01BQzNELFFBQVEsR0FBYSxDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsUUFBUSxDQUFDOzs7Ozs7QUFLeEQsZ0NBR0M7OztJQUZHLDJCQUFjOztJQUNkLDRCQUFlOzs7Ozs7QUFNbkIsMkJBR0M7OztJQUZHLHFCQUFhOztJQUNiLHFCQUFhOzs7OztBQVNqQixNQUFNLE9BQU8sU0FBUzs7Ozs7O0lBTWxCLFlBQ1ksS0FBcUIsRUFDckIsR0FBZSxFQUVHLENBQU07UUFIeEIsVUFBSyxHQUFMLEtBQUssQ0FBZ0I7UUFDckIsUUFBRyxHQUFILEdBQUcsQ0FBWTtRQUVHLE1BQUMsR0FBRCxDQUFDLENBQUs7O1FBUjVCLGVBQVUsR0FBRyxJQUFJLEdBQUcsQ0FBa0I7UUFDbEQsb0NBQW9DO1NBQy9CLENBQUMsQ0FBQztRQVFDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRTs7a0JBQ2hDLFVBQVUsR0FBVyxNQUFNLENBQUMsT0FBTyxDQUFDO1lBQ3RELDhDQUE4QztZ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Ozs7WUFoQ08sY0FBYztZQUNkLFVBQVU7NENBMENULE1BQU0sU0FBQyxRQUFROzs7OztJQVJwQiwrQkFFRzs7SUFHQywwQkFBNkI7O0lBQzdCLHdCQUF1Qjs7SUFFdkIsc0JBQWdDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDE4LXByZXNlbnQgT3BlbiBOZXR3b3JraW5nIEZvdW5kYXRpb25cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7SW5qZWN0LCBJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QWN0aXZhdGVkUm91dGV9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQge0xvZ1NlcnZpY2V9IGZyb20gJy4uL2xvZy5zZXJ2aWNlJztcbmltcG9ydCB7VHJpZSwgVHJpZU9wfSBmcm9tICcuL3RyaWUnO1xuXG4vLyBBbmd1bGFyPj0yIHdvcmthcm91bmQgZm9yIG1pc3NpbmcgZGVmaW5pdGlvblxuZGVjbGFyZSBjb25zdCBJbnN0YWxsVHJpZ2dlcjogYW55O1xuXG5jb25zdCBtYXRjaGVyID0gLzxcXC8/KFthLXpBLVowLTldKykqKC4qPylcXC8/Pi9pZ207XG5jb25zdCB3aGl0ZWxpc3Q6IHN0cmluZ1tdID0gWydiJywgJ2knLCAncCcsICdlbScsICdzdHJvbmcnLCAnYnInXTtcbmNvbnN0IGV2aWxsaXN0OiBzdHJpbmdbXSA9IFsnc2NyaXB0JywgJ3N0eWxlJywgJ2lmcmFtZSddO1xuXG4vKipcbiAqIFVzZWQgd2l0aCB0aGUgV2luZG93IHNpemUgZnVuY3Rpb247XG4gKiovXG5leHBvcnQgaW50ZXJmYWNlIFdpbmRvd1NpemUge1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG59XG5cbi8qKlxuICogRm9yIHRoZSBzYW5pdGl6ZSgpIGFuZCBhbmFseXplKCkgZnVuY3Rpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWF0Y2gge1xuICAgIGZ1bGw6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG59XG5cbi8qKlxuICogT05PUyBHVUkgLS0gVXRpbCAtLSBHZW5lcmFsIFB1cnBvc2UgRnVuY3Rpb25zXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBGblNlcnZpY2Uge1xuICAgIC8vIGludGVybmFsIHN0YXRlXG4gICAgcHJpdmF0ZSBkZWJ1Z0ZsYWdzID0gbmV3IE1hcDxzdHJpbmcsIGJvb2xlYW4+KFtcbi8vICAgICAgICBbIFwiTG9hZGluZ1NlcnZpY2VcIiwgdHJ1ZSBdXG4gICAgXSk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByb3V0ZTogQWN0aXZhdGVkUm91dGUsXG4gICAgICAgIHByaXZhdGUgbG9nOiBMb2dTZXJ2aWNlLFxuICAgICAgICAvLyBUT0RPOiBDaGFuZ2UgdGhlIGFueSB0eXBlIHRvIFdpbmRvdyB3aGVuIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE1NjQwIGlzIGZpeGVkLlxuICAgICAgICBASW5qZWN0KCdXaW5kb3cnKSBwcml2YXRlIHc6IGFueVxuICAgICkge1xuICAgICAgICB0aGlzLnJvdXRlLnF1ZXJ5UGFyYW1zLnN1YnNjcmliZShwYXJhbXMgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVidWdwYXJhbTogc3RyaW5nID0gcGFyYW1zWydkZWJ1ZyddO1xuLy8gICAgICAgICAgICBsb2cuZGVidWcoJ1BhcmFtOicsIGRlYnVncGFyYW0pO1xuICAgICAgICAgICAgdGhpcy5wYXJzZURlYnVnRmxhZ3MoZGVidWdwYXJhbSk7XG4gICAgICAgIH0pO1xuLy8gICAgICAgIHRoaXMubG9nLmRlYnVnKCdGblNlcnZpY2UgY29uc3RydWN0ZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIGFuIGFyZ3VtZW50IGlzIGEgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoZSBuZWVkIGZvciB0aGlzIHdvdWxkIGdvIGF3YXkgaWYgYWxsIGZ1bmN0aW9uc1xuICAgICAqIHdlcmUgc3Ryb25nbHkgdHlwZWRcbiAgICAgKi9cbiAgICBpc0YoZjogYW55KTogYW55IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmID09PSAnZnVuY3Rpb24nID8gZiA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBhbiBhcmd1bWVudCBpcyBhbiBhcnJheVxuICAgICAqXG4gICAgICogTm90ZTogdGhlIG5lZWQgZm9yIHRoaXMgd291bGQgZ28gYXdheSBpZiBhbGwgYXJyYXlzXG4gICAgICogd2VyZSBzdHJvbmdseSB0eXBlZFxuICAgICAqL1xuICAgIGlzQShhOiBhbnkpOiBhbnkge1xuICAgIC8vIE5PVEU6IEFycmF5LmlzQXJyYXkoKSBpcyBwYXJ0IG9mIEVNQ0FTY3JpcHQgNS4xXG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGEpID8gYSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBhbiBhcmd1bWVudCBpcyBhIHN0cmluZ1xuICAgICAqXG4gICAgICogTm90ZTogdGhlIG5lZWQgZm9yIHRoaXMgd291bGQgZ28gYXdheSBpZiBhbGwgc3RyaW5nc1xuICAgICAqIHdlcmUgc3Ryb25nbHkgdHlwZWRcbiAgICAgKi9cbiAgICBpc1MoczogYW55KTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJyA/IHMgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgYW4gYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGUgbmVlZCBmb3IgdGhpcyB3b3VsZCBnbyBhd2F5IGlmIGFsbCBvYmplY3RzXG4gICAgICogd2VyZSBzdHJvbmdseSB0eXBlZFxuICAgICAqL1xuICAgIGlzTyhvOiBhbnkpOiBPYmplY3Qge1xuICAgICAgICByZXR1cm4gKG8gJiYgdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIG8uY29uc3RydWN0b3IgPT09IE9iamVjdCkgPyBvIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IHRoYXQgYW4gYXJyYXkgY29udGFpbnMgYW4gb2JqZWN0XG4gICAgICovXG4gICAgY29udGFpbnMoYTogYW55W10sIHg6IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0EoYSkgJiYgYS5pbmRleE9mKHgpID4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aWR0aCBhbmQgaGVpZ2h0IG9mIHdpbmRvdyBpbm5lciBkaW1lbnNpb25zLlxuICAgICAqIG9mZkgsIG9mZlcgOiBvZmZzZXQgd2lkdGgvaGVpZ2h0IGFyZSBzdWJ0cmFjdGVkLCBpZiBwcmVzZW50XG4gICAgICovXG4gICAgd2luZG93U2l6ZShvZmZIOiBudW1iZXIgPSAwLCBvZmZXOiBudW1iZXIgPSAwKTogV2luZG93U2l6ZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMudy5pbm5lckhlaWdodCAtIG9mZkgsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53LmlubmVyV2lkdGggLSBvZmZXXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFsbCBuYW1lcyBpbiB0aGUgYXJyYXkgYXJlIGRlZmluZWQgYXMgZnVuY3Rpb25zXG4gICAgICogb24gdGhlIGdpdmVuIGFwaSBvYmplY3Q7IGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBBbHNvIHJldHVybnMgZmFsc2UgaWYgdGhlcmUgYXJlIHByb3BlcnRpZXMgb24gdGhlIGFwaSB0aGF0IGFyZSBOT1RcbiAgICAgKiBsaXN0ZWQgaW4gdGhlIGFycmF5IG9mIG5hbWVzLlxuICAgICAqXG4gICAgICogVGhpcyBnZXRzIGV4dHJhIGNvbXBsaWNhdGVkIHdoZW4gdGhlIGFwaSBPYmplY3QgaXMgYW5cbiAgICAgKiBBbmd1bGFyIHNlcnZpY2UgLSB3aGlsZSB0aGUgZnVuY3Rpb25zIGNhbiBiZSByZXRyaWV2ZWRcbiAgICAgKiBieSBhbiBpbmRleGVkIGdldCwgdGhlIG93blByb3BlcnRpZXMgZG9lcyBub3Qgc2hvdyB0aGVcbiAgICAgKiBmdW5jdGlvbnMgb2YgdGhlIGNsYXNzLiBXZSBoYXZlIHRvIGRpdmUgaW4gdG8gdGhlIHByb3RvdHlwZXNcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIGdldCB0aGVzZSAtIGFuZCBldmVuIHRoZW4gd2UgaGF2ZSB0byBmaWx0ZXJcbiAgICAgKiBvdXQgdGhlIGNvbnN0cnVjdG9yIGFuZCBhbnkgbWVtYmVyIHZhcmlhYmxlc1xuICAgICAqL1xuICAgIGFyZUZ1bmN0aW9ucyhhcGk6IE9iamVjdCwgZm5OYW1lczogc3RyaW5nW10pOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZm5Mb29rdXA6IE1hcDxzdHJpbmcsIGJvb2xlYW4+ID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgZXh0cmFGb3VuZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghdGhpcy5pc0EoZm5OYW1lcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG46IG51bWJlciA9IGZuTmFtZXMubGVuZ3RoO1xuICAgICAgICBsZXQgaTogbnVtYmVyO1xuICAgICAgICBsZXQgbmFtZTogc3RyaW5nO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIG5hbWUgPSBmbk5hbWVzW2ldO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRihhcGlbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm5Mb29rdXAuc2V0KG5hbWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIHByb3BlcnRpZXMgb24gdGhlIEFQSSB0aGF0IGFyZSBub3QgbGlzdGVkIGluIHRoZSBhcnJheSxcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFwaSk7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGFwaSBpcyBhIGNsYXNzIGl0IHdpbGwgaGF2ZSBhIG5hbWUsXG4gICAgICAgIC8vICBlbHNlIGl0IHdpbGwganVzdCBiZSBjYWxsZWQgJ09iamVjdCdcbiAgICAgICAgY29uc3QgYXBpT2JqZWN0TmFtZTogc3RyaW5nID0gYXBpLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIGlmIChhcGlPYmplY3ROYW1lID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXBpKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWZuTG9va3VwLmdldChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgeyAvLyBJdCBpcyBhIGNsYXNzLCBzbyBpdHMgZnVuY3Rpb25zIHdpbGwgYmUgaW4gdGhlIGNoaWxkIChwcm90b3R5cGUpXG4gICAgICAgICAgICBjb25zdCBwT2JqOiBPYmplY3QgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXBpKTtcbiAgICAgICAgICAgIGZvciAoIGNvbnN0IGtleSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhwT2JqKSApIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InKSB7IC8vIEZpbHRlciBvdXQgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwT2JqLCBrZXkpO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgY29tcGFyZSBmdW5jdGlvbnMuIExvb2sgZm9yIGFueSBub3QgZ2l2ZW4gaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRih2YWx1ZS52YWx1ZSkgJiYgIWZuTG9va3VwLmdldChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWV4dHJhRm91bmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFsbCBuYW1lcyBpbiB0aGUgYXJyYXkgYXJlIGRlZmluZWQgYXMgZnVuY3Rpb25zXG4gICAgICogb24gdGhlIGdpdmVuIGFwaSBvYmplY3Q7IGZhbHNlIG90aGVyd2lzZS4gVGhpcyBpcyBhIG5vbi1zdHJpY3QgdmVyc2lvblxuICAgICAqIHRoYXQgZG9lcyBub3QgY2FyZSBhYm91dCBvdGhlciBwcm9wZXJ0aWVzIG9uIHRoZSBhcGkuXG4gICAgICovXG4gICAgYXJlRnVuY3Rpb25zTm9uU3RyaWN0KGFwaSwgZm5OYW1lcyk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIXRoaXMuaXNBKGZuTmFtZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbiA9IGZuTmFtZXMubGVuZ3RoO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IG5hbWU7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbmFtZSA9IGZuTmFtZXNbaV07XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNGKGFwaVtuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGN1cnJlbnQgYnJvd3NlciBkZXRlcm1pbmVkIHRvIGJlIGEgbW9iaWxlIGRldmljZVxuICAgICAqL1xuICAgIGlzTW9iaWxlKCkge1xuICAgICAgICBjb25zdCB1YSA9IHRoaXMudy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgICBjb25zdCBwYXR0ID0gL2lQaG9uZXxpUG9kfGlQYWR8U2lsa3xBbmRyb2lkfEJsYWNrQmVycnl8T3BlcmEgTWluaXxJRU1vYmlsZS87XG4gICAgICAgIHJldHVybiBwYXR0LnRlc3QodWEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBicm93c2VyIGRldGVybWluZWQgdG8gYmUgQ2hyb21lXG4gICAgICovXG4gICAgaXNDaHJvbWUoKSB7XG4gICAgICAgIGNvbnN0IGlzQ2hyb21pdW0gPSAodGhpcy53IGFzIGFueSkuY2hyb21lO1xuICAgICAgICBjb25zdCB2ZW5kb3JOYW1lID0gdGhpcy53Lm5hdmlnYXRvci52ZW5kb3I7XG5cbiAgICAgICAgY29uc3QgaXNPcGVyYSA9IHRoaXMudy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ09QUicpID4gLTE7XG4gICAgICAgIHJldHVybiAoaXNDaHJvbWl1bSAhPT0gbnVsbCAmJlxuICAgICAgICBpc0Nocm9taXVtICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdmVuZG9yTmFtZSA9PT0gJ0dvb2dsZSBJbmMuJyAmJlxuICAgICAgICBpc09wZXJhID09PSBmYWxzZSk7XG4gICAgfVxuXG4gICAgaXNDaHJvbWVIZWFkbGVzcygpIHtcbiAgICAgICAgY29uc3QgdmVuZG9yTmFtZSA9IHRoaXMudy5uYXZpZ2F0b3IudmVuZG9yO1xuICAgICAgICBjb25zdCBoZWFkbGVzc0Nocm9tZSA9IHRoaXMudy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0hlYWRsZXNzQ2hyb21lJykgPiAtMTtcblxuICAgICAgICByZXR1cm4gKHZlbmRvck5hbWUgPT09ICdHb29nbGUgSW5jLicgJiYgaGVhZGxlc3NDaHJvbWUgPT09IHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBicm93c2VyIGRldGVybWluZWQgdG8gYmUgU2FmYXJpXG4gICAgICovXG4gICAgaXNTYWZhcmkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy53Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignU2FmYXJpJykgIT09IC0xICYmXG4gICAgICAgIHRoaXMudy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IGJyb3dzZXIgZGV0ZXJtaW5lZCB0byBiZSBGaXJlZm94XG4gICAgICovXG4gICAgaXNGaXJlZm94KCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWFyY2ggdGhyb3VnaCBhbiBhcnJheSBvZiBvYmplY3RzLCBsb29raW5nIGZvciB0aGUgb25lIHdpdGggdGhlXG4gICAgICogdGFnZ2VkIHByb3BlcnR5IG1hdGNoaW5nIHRoZSBnaXZlbiBrZXkuIHRhZyBkZWZhdWx0cyB0byAnaWQnLlxuICAgICAqIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGluZyBvYmplY3QsIG9yIC0xIGZvciBubyBtYXRjaC5cbiAgICAgKi9cbiAgICBmaW5kKGtleTogc3RyaW5nLCBhcnJheTogT2JqZWN0W10sIHRhZzogc3RyaW5nID0gJ2lkJyk6IG51bWJlciB7XG4gICAgICAgIGxldCBpZHg6IG51bWJlcjtcbiAgICAgICAgY29uc3QgbjogbnVtYmVyID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaWR4ID0gMCA7IGlkeCA8IG47IGlkeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBkOiBPYmplY3QgPSBhcnJheVtpZHhdO1xuICAgICAgICAgICAgaWYgKGRbdGFnXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2VhcmNoIHRocm91Z2ggYXJyYXkgdG8gZmluZCAodGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YpIGl0ZW0sXG4gICAgICogcmV0dXJuaW5nIGl0cyBpbmRleCBpZiBmb3VuZDsgb3RoZXJ3aXNlIHJldHVybmluZyAtMS5cbiAgICAgKi9cbiAgICBpbkFycmF5KGl0ZW06IGFueSwgYXJyYXk6IGFueVtdKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBKGFycmF5KSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnJheVtpXSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSAodGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YpIHRoZSBzcGVjaWZpZWQgaXRlbSBmcm9tIHRoZSBnaXZlblxuICAgICAqIGFycmF5LCBpZiBhbnkuIFJldHVybiB0cnVlIGlmIHRoZSByZW1vdmFsIHdhcyBtYWRlOyBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVtb3ZlRnJvbUFycmF5KGl0ZW06IGFueSwgYXJyYXk6IGFueVtdKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGk6IG51bWJlciA9IHRoaXMuaW5BcnJheShpdGVtLCBhcnJheSk7XG4gICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGVtcHR5LCByZXR1cm4gZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNFbXB0eU9iamVjdChvYmo6IE9iamVjdCk6IGJvb2xlYW4ge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICh0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIG9iamVjdHMgaGF2ZSBhbGwgdGhlIHNhbWUgcHJvcGVydGllc1xuICAgICAqL1xuICAgIHNhbWVPYmpQcm9wcyhvYmoxOiBPYmplY3QsIG9iajI6IE9iamVjdCk6IGJvb2xlYW4ge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmoxKSB7XG4gICAgICAgICAgICBpZiAob2JqMS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEob2JqMVtrZXldID09PSBvYmoyW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0cnVlIGlmIHRoZSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0XG4gICAgICogZG9lcyBOT1QgdXNlIHN0cmljdCBvYmplY3QgcmVmZXJlbmNlIGVxdWFsaXR5LFxuICAgICAqIGluc3RlYWQgY2hlY2tzIGVhY2ggcHJvcGVydHkgaW5kaXZpZHVhbGx5IGZvciBlcXVhbGl0eVxuICAgICAqL1xuICAgIGNvbnRhaW5zT2JqKGFycjogYW55W10sIG9iajogT2JqZWN0KTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNhbWVPYmpQcm9wcyhhcnJbaV0sIG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBnaXZlbiBzdHJpbmcgd2l0aCB0aGUgZmlyc3QgY2hhcmFjdGVyIGNhcGl0YWxpemVkLlxuICAgICAqL1xuICAgIGNhcChzOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gcyA/IHNbMF0udG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSkudG9Mb3dlckNhc2UoKSA6IHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBwYXJhbWV0ZXIgd2l0aG91dCBhIHB4IHN1ZmZpeFxuICAgICAqL1xuICAgIG5vUHgobnVtOiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTnVtYmVyKG51bS5yZXBsYWNlKC9weCQvLCAnJykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhbiBlbGVtZW50J3MgZ2l2ZW4gc3R5bGUgcHJvcGVydHkgd2l0aG91dCBweCBzdWZmaXhcbiAgICAgKi9cbiAgICBub1B4U3R5bGUoZWxlbTogYW55LCBwcm9wOiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTnVtYmVyKGVsZW0uc3R5bGUocHJvcCkucmVwbGFjZSgvcHgkLywgJycpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiBhIHN0ciBlbmRzIHdpdGggc3VmZml4XG4gICAgICovXG4gICAgZW5kc1dpdGgoc3RyOiBzdHJpbmcsIHN1ZmZpeDogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHIuaW5kZXhPZihzdWZmaXgsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogb3V0cHV0IGRlYnVnIG1lc3NhZ2UgdG8gY29uc29sZSwgaWYgZGVidWcgdGFnIHNldC4uLlxuICAgICAqIGUuZy4gZnMuZGVidWcoJ215dGFnJywgYXJnMSwgYXJnMiwgLi4uKVxuICAgICAqL1xuICAgIGRlYnVnKHRhZywgLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5kZWJ1Z0ZsYWdzLmdldCh0YWcpKSB7XG4vLyAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKHRhZywgYXJncy5qb2luKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYXJzZURlYnVnRmxhZ3MoZGJnc3RyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgYml0cyA9IGRiZ3N0ciA/IGRiZ3N0ci5zcGxpdCgnLCcpIDogW107XG4gICAgICAgIGJpdHMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnRmxhZ3Muc2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuLy8gICAgICAgIHRoaXMubG9nLmRlYnVnKCdEZWJ1ZyBmbGFnczonLCBkYmdzdHIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gZGVidWcgZmxhZyB3YXMgc3BlY2lmaWVkIGluIHRoZSBxdWVyeSBwYXJhbXNcbiAgICAgICovXG4gICAgZGVidWdPbih0YWc6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWJ1Z0ZsYWdzLmdldCh0YWcpO1xuICAgIH1cblxuXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFRoZSBuZXh0IHNlY3Rpb24gZGVhbHMgd2l0aCBzYW5pdGl6aW5nIGV4dGVybmFsIHN0cmluZ3MgZGVzdGluZWRcbiAgICAvLyB0byBiZSBsb2FkZWQgdmlhIGEgLmh0bWwoKSBmdW5jdGlvbiBjYWxsLlxuICAgIC8vXG4gICAgLy8gU2VlIGRlZmluaXRpb24gb2YgbWF0Y2hlciwgZXZpbGxpc3QgYW5kIHdoaXRlbGlzdCBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRhZyBpcyBpbiB0aGUgZXZpbCBsaXN0LCAoYW5kIGlzIG5vdCBhbiBlbmQtdGFnKVxuICAgICAqL1xuICAgIGluRXZpbExpc3QodGFnOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChldmlsbGlzdC5pbmRleE9mKHRhZy5uYW1lKSAhPT0gLTEgJiYgdGFnLmZ1bGwuaW5kZXhPZignLycpID09PSAtMSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIE1hdGNoZXMgb2YgbWF0Y2hlciBpbiBodG1sXG4gICAgICovXG4gICAgYW5hbHl6ZShodG1sOiBzdHJpbmcpOiBNYXRjaFtdIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlczogTWF0Y2hbXSA9IFtdO1xuICAgICAgICBsZXQgbWF0Y2g7XG5cbiAgICAgICAgLy8gZXh0cmFjdCBhbGwgdGFnc1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gbWF0Y2hlci5leGVjKGh0bWwpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBmdWxsOiBtYXRjaFswXSxcbiAgICAgICAgICAgICAgICBuYW1lOiBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBpZ25vcmluZyBhdHRyaWJ1dGVzIHttYXRjaFsyXS5zcGxpdCgnICcpfSBmb3Igbm93XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUmV0dXJucyBhIGNsZWFuZWQgdmVyc2lvbiBvZiBodG1sXG4gICAgICovXG4gICAgc2FuaXRpemUoaHRtbDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlczogTWF0Y2hbXSA9IHRoaXMuYW5hbHl6ZShodG1sKTtcblxuICAgICAgICAvLyBjb21wbGV0ZWx5IG9ibGl0ZXJhdGUgZXZpbCB0YWdzIGFuZCB0aGVpciBjb250ZW50cy4uLlxuICAgICAgICBldmlsbGlzdC5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cCgnPCcgKyB0YWcgKyAnKC4qPyk+KC4qP1tcXHJcXG5dKSo/KC4qPykoLio/W1xcclxcbl0pKj88XFwvJyArIHRhZyArICc+JywgJ2dpbScpO1xuICAgICAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZShyZSwgJycpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBmaWx0ZXIgb3V0IGFsbCBidXQgd2hpdGUtbGlzdGVkIHRhZ3MgYW5kIGVuZC10YWdzXG4gICAgICAgIG1hdGNoZXMuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICAgICAgICBpZiAod2hpdGVsaXN0LmluZGV4T2YodGFnLm5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UodGFnLmZ1bGwsICcnKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbkV2aWxMaXN0KHRhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cud2FybignVW5zYW5pdGFyeSBIVE1MIGlucHV0IC0tICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnLmZ1bGwgKyAnIGRldGVjdGVkIScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgZW5jb2RpbmcgSFRNTCBlbnRpdGllcywgZS5nLiAnJicgLT4gJyZhbXA7J1xuXG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCB3b3JkIHRvIHRyaWUgKHdvcmQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gdXBwZXJjYXNlKVxuICAgICAqIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSB3b3JkXG4gICAgICogcmV0dXJucyAnYWRkZWQnIG9yICd1cGRhdGVkJ1xuICAgICAqL1xuICAgIGFkZFRvVHJpZSh0cmllLCB3b3JkLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJpZShUcmllT3AuUExVUywgdHJpZSwgd29yZCwgZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHdvcmQgZnJvbSB0cmllICh3b3JkIHdpbGwgYmUgY29udmVydGVkIHRvIHVwcGVyY2FzZSlcbiAgICAgKiByZXR1cm5zICdyZW1vdmVkJyBvciAnYWJzZW50J1xuICAgICAqL1xuICAgIHJlbW92ZUZyb21UcmllKHRyaWUsIHdvcmQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmllKFRyaWVPcC5NSU5VUywgdHJpZSwgd29yZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbG9va3VwIHdvcmQgKGNvbnZlcnRlZCB0byB1cHBlcmNhc2UpIGluIHRyaWVcbiAgICAgKiByZXR1cm5zOlxuICAgICAqICAgIHVuZGVmaW5lZCBpZiB0aGUgd29yZCBpcyBub3QgaW4gdGhlIHRyaWVcbiAgICAgKiAgICAtMSBmb3IgYSBwYXJ0aWFsIG1hdGNoICh3b3JkIGlzIGEgcHJlZml4IHRvIGFuIGV4aXN0aW5nIHdvcmQpXG4gICAgICogICAgZGF0YSBmb3IgdGhlIHdvcmQgZm9yIGFuIGV4YWN0IG1hdGNoXG4gICAgICovXG4gICAgdHJpZUxvb2t1cCh0cmllLCB3b3JkKSB7XG4gICAgICAgIGNvbnN0IHMgPSB3b3JkLnRvVXBwZXJDYXNlKCkuc3BsaXQoJycpO1xuICAgICAgICBsZXQgcCA9IHRyaWU7XG4gICAgICAgIGxldCBuO1xuXG4gICAgICAgIHdoaWxlIChzLmxlbmd0aCkge1xuICAgICAgICAgICAgbiA9IHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHAgPSBwW25dO1xuICAgICAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocC5fZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHAuX2RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxufVxuIl19