/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/*
 * Copyright 2019-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
const LONGITUDE_EXTENT = 180;
/** @type {?} */
const LATITUDE_EXTENT = 75;
/** @type {?} */
const GRID_EXTENT_X = 2000;
/** @type {?} */
const GRID_EXTENT_Y = 1000;
/** @type {?} */
const GRID_DIAGONAL = 2236;
// 2236 is the length of the diagonal of the 2000x1000 box
/** @type {?} */
const GRID_CENTRE_X = 500;
/** @type {?} */
const GRID_CENTRE_Y = 500;
/**
 * A model of the map bounds bottom left to top right in lat and long
 * @record
 */
export function MapBounds() { }
if (false) {
    /** @type {?} */
    MapBounds.prototype.lngMin;
    /** @type {?} */
    MapBounds.prototype.latMin;
    /** @type {?} */
    MapBounds.prototype.lngMax;
    /** @type {?} */
    MapBounds.prototype.latMax;
}
/**
 * model of the topo2CurrentRegion Loc part of the MetaUi below
 * @record
 */
export function LocMeta() { }
if (false) {
    /** @type {?} */
    LocMeta.prototype.lng;
    /** @type {?} */
    LocMeta.prototype.lat;
}
/**
 * model of the topo2CurrentRegion MetaUi from Device below
 * @record
 */
export function MetaUi() { }
if (false) {
    /** @type {?} */
    MetaUi.prototype.equivLoc;
    /** @type {?} */
    MetaUi.prototype.x;
    /** @type {?} */
    MetaUi.prototype.y;
}
/**
 * Model of the Zoom preferences
 * @record
 */
export function TopoZoomPrefs() { }
if (false) {
    /** @type {?} */
    TopoZoomPrefs.prototype.tx;
    /** @type {?} */
    TopoZoomPrefs.prototype.ty;
    /** @type {?} */
    TopoZoomPrefs.prototype.sc;
}
/**
 * Utility class with static functions for scaling maps
 *
 * This is left as a class, so that the functions are loaded only as needed
 */
export class ZoomUtils {
    /**
     * @param {?} location
     * @return {?}
     */
    static convertGeoToCanvas(location) {
        /** @type {?} */
        const calcX = (LONGITUDE_EXTENT + location.lng) / (LONGITUDE_EXTENT * 2) * GRID_EXTENT_X - GRID_CENTRE_X;
        /** @type {?} */
        const calcY = (LATITUDE_EXTENT - location.lat) / (LATITUDE_EXTENT * 2) * GRID_EXTENT_Y;
        return (/** @type {?} */ ({
            x: calcX,
            y: calcY,
            equivLoc: {
                lat: location.lat,
                lng: location.lng
            }
        }));
    }
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    static convertXYtoGeo(x, y) {
        /** @type {?} */
        const calcLong = (x + GRID_CENTRE_X) * 2 * LONGITUDE_EXTENT / GRID_EXTENT_X - LONGITUDE_EXTENT;
        /** @type {?} */
        const calcLat = -(y * 2 * LATITUDE_EXTENT / GRID_EXTENT_Y - LATITUDE_EXTENT);
        return (/** @type {?} */ ({
            x: x,
            y: y,
            equivLoc: (/** @type {?} */ ({
                lat: (calcLat === -0) ? 0 : calcLat,
                lng: calcLong
            }))
        }));
    }
    /**
     * This converts the bounds of a map loaded from a TopoGson file that has been
     * converted in to a GEOJson format by d3
     *
     * The bounds are in latitude and longitude from bottom left (min) to top right (max)
     *
     * First they are converted in to SVG viewbox coordinates 0,0 top left 1000x1000
     *
     * The the zoom level is calculated by scaling to the grid diagonal
     *
     * Finally the translation is calculated by applying the zoom first, and then
     * translating on the zoomed coordinate system
     * @param {?} mapBounds - the bounding box of the chosen map in lat and long
     * @param {?=} log The LogService
     * @return {?}
     */
    static convertBoundsToZoomLevel(mapBounds, log) {
        /** @type {?} */
        const min = this.convertGeoToCanvas((/** @type {?} */ ({
            lng: mapBounds.lngMin,
            lat: mapBounds.latMin
        })));
        /** @type {?} */
        const max = this.convertGeoToCanvas((/** @type {?} */ ({
            lng: mapBounds.lngMax,
            lat: mapBounds.latMax
        })));
        /** @type {?} */
        const diagonal = Math.sqrt(Math.pow(max.x - min.x, 2) + Math.pow(max.y - min.y, 2));
        /** @type {?} */
        const centreX = (max.x - min.x) / 2 + min.x;
        /** @type {?} */
        const centreY = (max.y - min.y) / 2 + min.y;
        // Zoom works from the top left of the 1000x1000 viewbox
        // The scale is applied first and then the translate is on the scaled coordinates
        /** @type {?} */
        const zoomscale = 0.5 * GRID_DIAGONAL / ((diagonal < 100) ? 100 : diagonal);
        // Don't divide by zero
        /** @type {?} */
        const zoomx = -centreX * zoomscale + GRID_CENTRE_X;
        /** @type {?} */
        const zoomy = -centreY * zoomscale + GRID_CENTRE_Y;
        // log.debug('MapBounds', mapBounds, 'XYMin', min, 'XYMax', max, 'Diag', diagonal,
        //     'Centre', centreX, centreY, 'translate', zoomx, zoomy, 'Scale', zoomscale);
        return (/** @type {?} */ ({ tx: zoomx, ty: zoomy, sc: zoomscale }));
    }
    /**
     * Calculate Zoom settings to fit the 1000x1000 grid in to the available window height
     * less the banner height
     *
     * Scaling always happens from the top left 0,0
     * If the height is greater than the width then no scaling is required - grid will
     * need to fill the SVG canvas
     * @param {?} bannerHeight - the top band of the screen for the mast
     * @param {?} innerWidth - the actual width of the screen
     * @param {?} innerHeight - the actual height of the screen
     * @return {?} Zoom settings - scale and translate
     */
    static zoomToWindowSize(bannerHeight, innerWidth, innerHeight) {
        /** @type {?} */
        const newHeight = innerHeight - bannerHeight;
        if (newHeight > innerWidth) {
            return (/** @type {?} */ ({
                sc: 1.0,
                tx: 0,
                ty: 0
            }));
        }
        else {
            /** @type {?} */
            const scale = newHeight / innerWidth;
            return (/** @type {?} */ ({
                sc: scale,
                tx: (500 / scale - 500) * scale,
                ty: 0
            }));
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiem9vbXV0aWxzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vZ3VpMi1mdy1saWIvIiwic291cmNlcyI6WyJsaWIvc3ZnL3pvb211dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQW1CTSxnQkFBZ0IsR0FBRyxHQUFHOztNQUN0QixlQUFlLEdBQUcsRUFBRTs7TUFDcEIsYUFBYSxHQUFHLElBQUk7O01BQ3BCLGFBQWEsR0FBRyxJQUFJOztNQUNwQixhQUFhLEdBQUcsSUFBSTs7O01BQ3BCLGFBQWEsR0FBRyxHQUFHOztNQUNuQixhQUFhLEdBQUcsR0FBRzs7Ozs7QUFNekIsK0JBS0M7OztJQUpHLDJCQUFlOztJQUNmLDJCQUFlOztJQUNmLDJCQUFlOztJQUNmLDJCQUFlOzs7Ozs7QUFNbkIsNkJBR0M7OztJQUZHLHNCQUFZOztJQUNaLHNCQUFZOzs7Ozs7QUFNaEIsNEJBSUM7OztJQUhHLDBCQUFrQjs7SUFDbEIsbUJBQVU7O0lBQ1YsbUJBQVU7Ozs7OztBQU1kLG1DQUlDOzs7SUFIRywyQkFBVzs7SUFDWCwyQkFBVzs7SUFDWCwyQkFBVzs7Ozs7OztBQVFmLE1BQU0sT0FBTyxTQUFTOzs7OztJQUNsQixNQUFNLENBQUMsa0JBQWtCLENBQUMsUUFBaUI7O2NBQ2pDLEtBQUssR0FBRyxDQUFDLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLGdCQUFnQixHQUFHLENBQUMsQ0FBQyxHQUFHLGFBQWEsR0FBRyxhQUFhOztjQUNsRyxLQUFLLEdBQUcsQ0FBQyxlQUFlLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsZUFBZSxHQUFHLENBQUMsQ0FBQyxHQUFHLGFBQWE7UUFDdEYsT0FBTyxtQkFBUTtZQUNYLENBQUMsRUFBRSxLQUFLO1lBQ1IsQ0FBQyxFQUFFLEtBQUs7WUFDUixRQUFRLEVBQUU7Z0JBQ04sR0FBRyxFQUFFLFFBQVEsQ0FBQyxHQUFHO2dCQUNqQixHQUFHLEVBQUUs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Q1QsRUFBRSxFQUFFLENBQUMsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxLQUFLO2dCQUMvQixFQUFFLEVBQUUsQ0FBQzthQUNSLEVBQUEsQ0FBQztTQUNMO0lBQ0wsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDE5LXByZXNlbnQgT3BlbiBOZXR3b3JraW5nIEZvdW5kYXRpb25cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbmltcG9ydCB7TG9nU2VydmljZX0gZnJvbSAnLi4vbG9nLnNlcnZpY2UnO1xuXG5jb25zdCBMT05HSVRVREVfRVhURU5UID0gMTgwO1xuY29uc3QgTEFUSVRVREVfRVhURU5UID0gNzU7XG5jb25zdCBHUklEX0VYVEVOVF9YID0gMjAwMDtcbmNvbnN0IEdSSURfRVhURU5UX1kgPSAxMDAwO1xuY29uc3QgR1JJRF9ESUFHT05BTCA9IDIyMzY7IC8vIDIyMzYgaXMgdGhlIGxlbmd0aCBvZiB0aGUgZGlhZ29uYWwgb2YgdGhlIDIwMDB4MTAwMCBib3hcbmNvbnN0IEdSSURfQ0VOVFJFX1ggPSA1MDA7XG5jb25zdCBHUklEX0NFTlRSRV9ZID0gNTAwO1xuXG5cbi8qKlxuICogQSBtb2RlbCBvZiB0aGUgbWFwIGJvdW5kcyBib3R0b20gbGVmdCB0byB0b3AgcmlnaHQgaW4gbGF0IGFuZCBsb25nXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFwQm91bmRzIHtcbiAgICBsbmdNaW46IG51bWJlcjtcbiAgICBsYXRNaW46IG51bWJlcjtcbiAgICBsbmdNYXg6IG51bWJlcjtcbiAgICBsYXRNYXg6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBtb2RlbCBvZiB0aGUgdG9wbzJDdXJyZW50UmVnaW9uIExvYyBwYXJ0IG9mIHRoZSBNZXRhVWkgYmVsb3dcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2NNZXRhIHtcbiAgICBsbmc6IG51bWJlcjtcbiAgICBsYXQ6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBtb2RlbCBvZiB0aGUgdG9wbzJDdXJyZW50UmVnaW9uIE1ldGFVaSBmcm9tIERldmljZSBiZWxvd1xuICovXG5leHBvcnQgaW50ZXJmYWNlIE1ldGFVaSB7XG4gICAgZXF1aXZMb2M6IExvY01ldGE7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBNb2RlbCBvZiB0aGUgWm9vbSBwcmVmZXJlbmNlc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFRvcG9ab29tUHJlZnMge1xuICAgIHR4OiBudW1iZXI7XG4gICAgdHk6IG51bWJlcjtcbiAgICBzYzogbnVtYmVyO1xufVxuXG4vKipcbiAqIFV0aWxpdHkgY2xhc3Mgd2l0aCBzdGF0aWMgZnVuY3Rpb25zIGZvciBzY2FsaW5nIG1hcHNcbiAqXG4gKiBUaGlzIGlzIGxlZnQgYXMgYSBjbGFzcywgc28gdGhhdCB0aGUgZnVuY3Rpb25zIGFyZSBsb2FkZWQgb25seSBhcyBuZWVkZWRcbiAqL1xuZXhwb3J0IGNsYXNzIFpvb21VdGlscyB7XG4gICAgc3RhdGljIGNvbnZlcnRHZW9Ub0NhbnZhcyhsb2NhdGlvbjogTG9jTWV0YSApOiBNZXRhVWkge1xuICAgICAgICBjb25zdCBjYWxjWCA9IChMT05HSVRVREVfRVhURU5UICsgbG9jYXRpb24ubG5nKSAvIChMT05HSVRVREVfRVhURU5UICogMikgKiBHUklEX0VYVEVOVF9YIC0gR1JJRF9DRU5UUkVfWDtcbiAgICAgICAgY29uc3QgY2FsY1kgPSAoTEFUSVRVREVfRVhURU5UIC0gbG9jYXRpb24ubGF0KSAvIChMQVRJVFVERV9FWFRFTlQgKiAyKSAqIEdSSURfRVhURU5UX1k7XG4gICAgICAgIHJldHVybiA8TWV0YVVpPntcbiAgICAgICAgICAgIHg6IGNhbGNYLFxuICAgICAgICAgICAgeTogY2FsY1ksXG4gICAgICAgICAgICBlcXVpdkxvYzoge1xuICAgICAgICAgICAgICAgIGxhdDogbG9jYXRpb24ubGF0LFxuICAgICAgICAgICAgICAgIGxuZzogbG9jYXRpb24ubG5nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbnZlcnRYWXRvR2VvKHg6IG51bWJlciwgeTogbnVtYmVyKTogTWV0YVVpIHtcbiAgICAgICAgY29uc3QgY2FsY0xvbmc6IG51bWJlciA9ICh4ICsgR1JJRF9DRU5UUkVfWCkgKiAyICogTE9OR0lUVURFX0VYVEVOVCAvIEdSSURfRVhURU5UX1ggLSBMT05HSVRVREVfRVhURU5UO1xuICAgICAgICBjb25zdCBjYWxjTGF0OiBudW1iZXIgPSAtKHkgKiAyICogTEFUSVRVREVfRVhURU5UIC8gR1JJRF9FWFRFTlRfWSAtIExBVElUVURFX0VYVEVOVCk7XG4gICAgICAgIHJldHVybiA8TWV0YVVpPntcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgZXF1aXZMb2M6IDxMb2NNZXRhPntcbiAgICAgICAgICAgICAgICBsYXQ6IChjYWxjTGF0ID09PSAtMCkgPyAwIDogY2FsY0xhdCxcbiAgICAgICAgICAgICAgICBsbmc6IGNhbGNMb25nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjb252ZXJ0cyB0aGUgYm91bmRzIG9mIGEgbWFwIGxvYWRlZCBmcm9tIGEgVG9wb0dzb24gZmlsZSB0aGF0IGhhcyBiZWVuXG4gICAgICogY29udmVydGVkIGluIHRvIGEgR0VPSnNvbiBmb3JtYXQgYnkgZDNcbiAgICAgKlxuICAgICAqIFRoZSBib3VuZHMgYXJlIGluIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgZnJvbSBib3R0b20gbGVmdCAobWluKSB0byB0b3AgcmlnaHQgKG1heClcbiAgICAgKlxuICAgICAqIEZpcnN0IHRoZXkgYXJlIGNvbnZlcnRlZCBpbiB0byBTVkcgdmlld2JveCBjb29yZGluYXRlcyAwLDAgdG9wIGxlZnQgMTAwMHgxMDAwXG4gICAgICpcbiAgICAgKiBUaGUgdGhlIHpvb20gbGV2ZWwgaXMgY2FsY3VsYXRlZCBieSBzY2FsaW5nIHRvIHRoZSBncmlkIGRpYWdvbmFsXG4gICAgICpcbiAgICAgKiBGaW5hbGx5IHRoZSB0cmFuc2xhdGlvbiBpcyBjYWxjdWxhdGVkIGJ5IGFwcGx5aW5nIHRoZSB6b29tIGZpcnN0LCBhbmQgdGhlblxuICAgICAqIHRyYW5zbGF0aW5nIG9uIHRoZSB6b29tZWQgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgKiBAcGFyYW0gbWFwQm91bmRzIC0gdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgY2hvc2VuIG1hcCBpbiBsYXQgYW5kIGxvbmdcbiAgICAgKiBAcGFyYW0gbG9nIFRoZSBMb2dTZXJ2aWNlXG4gICAgICovXG4gICAgc3RhdGljIGNvbnZlcnRCb3VuZHNUb1pvb21MZXZlbChtYXBCb3VuZHM6IE1hcEJvdW5kcywgbG9nPzogTG9nU2VydmljZSk6IFRvcG9ab29tUHJlZnMge1xuXG4gICAgICAgIGNvbnN0IG1pbjogTWV0YVVpID0gdGhpcy5jb252ZXJ0R2VvVG9DYW52YXMoPExvY01ldGE+e1xuICAgICAgICAgICAgbG5nOiBtYXBCb3VuZHMubG5nTWluLFxuICAgICAgICAgICAgbGF0OiBtYXBCb3VuZHMubGF0TWluXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG1heDogTWV0YVVpID0gdGhpcy5jb252ZXJ0R2VvVG9DYW52YXMoPExvY01ldGE+e1xuICAgICAgICAgICAgbG5nOiBtYXBCb3VuZHMubG5nTWF4LFxuICAgICAgICAgICAgbGF0OiBtYXBCb3VuZHMubGF0TWF4XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGRpYWdvbmFsID0gTWF0aC5zcXJ0KE1hdGgucG93KG1heC54IC0gbWluLngsIDIpICsgTWF0aC5wb3cobWF4LnkgLSBtaW4ueSwgMikpO1xuICAgICAgICBjb25zdCBjZW50cmVYID0gKG1heC54IC0gbWluLngpIC8gMiArIG1pbi54O1xuICAgICAgICBjb25zdCBjZW50cmVZID0gKG1heC55IC0gbWluLnkpIC8gMiArIG1pbi55O1xuICAgICAgICAvLyBab29tIHdvcmtzIGZyb20gdGhlIHRvcCBsZWZ0IG9mIHRoZSAxMDAweDEwMDAgdmlld2JveFxuICAgICAgICAvLyBUaGUgc2NhbGUgaXMgYXBwbGllZCBmaXJzdCBhbmQgdGhlbiB0aGUgdHJhbnNsYXRlIGlzIG9uIHRoZSBzY2FsZWQgY29vcmRpbmF0ZXNcbiAgICAgICAgY29uc3Qgem9vbXNjYWxlID0gMC41ICogR1JJRF9ESUFHT05BTCAvICgoZGlhZ29uYWwgPCAxMDApID8gMTAwIDogZGlhZ29uYWwpOyAvLyBEb24ndCBkaXZpZGUgYnkgemVyb1xuICAgICAgICBjb25zdCB6b29teCA9IC1jZW50cmVYICogem9vbXNjYWxlICsgR1JJRF9DRU5UUkVfWDtcbiAgICAgICAgY29uc3Qgem9vbXkgPSAtY2VudHJlWSAqIHpvb21zY2FsZSArIEdSSURfQ0VOVFJFX1k7XG5cbiAgICAgICAgLy8gbG9nLmRlYnVnKCdNYXBCb3VuZHMnLCBtYXBCb3VuZHMsICdYWU1pbicsIG1pbiwgJ1hZTWF4JywgbWF4LCAnRGlhZycsIGRpYWdvbmFsLFxuICAgICAgICAvLyAgICAgJ0NlbnRyZScsIGNlbnRyZVgsIGNlbnRyZVksICd0cmFuc2xhdGUnLCB6b29teCwgem9vbXksICdTY2FsZScsIHpvb21zY2FsZSk7XG5cbiAgICAgICAgcmV0dXJuIDxUb3BvWm9vbVByZWZzPnt0eDogem9vbXgsIHR5OiB6b29teSwgc2M6IHpvb21zY2FsZX07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIFpvb20gc2V0dGluZ3MgdG8gZml0IHRoZSAxMDAweDEwMDAgZ3JpZCBpbiB0byB0aGUgYXZhaWxhYmxlIHdpbmRvdyBoZWlnaHRcbiAgICAgKiBsZXNzIHRoZSBiYW5uZXIgaGVpZ2h0XG4gICAgICpcbiAgICAgKiBTY2FsaW5nIGFsd2F5cyBoYXBwZW5zIGZyb20gdGhlIHRvcCBsZWZ0IDAsMFxuICAgICAqIElmIHRoZSBoZWlnaHQgaXMgZ3JlYXRlciB0aGFuIHRoZSB3aWR0aCB0aGVuIG5vIHNjYWxpbmcgaXMgcmVxdWlyZWQgLSBncmlkIHdpbGxcbiAgICAgKiBuZWVkIHRvIGZpbGwgdGhlIFNWRyBjYW52YXNcbiAgICAgKiBAcGFyYW0gYmFubmVySGVpZ2h0IC0gdGhlIHRvcCBiYW5kIG9mIHRoZSBzY3JlZW4gZm9yIHRoZSBtYXN0XG4gICAgICogQHBhcmFtIGlubmVyV2lkdGggLSB0aGUgYWN0dWFsIHdpZHRoIG9mIHRoZSBzY3JlZW5cbiAgICAgKiBAcGFyYW0gaW5uZXJIZWlnaHQgLSB0aGUgYWN0dWFsIGhlaWdodCBvZiB0aGUgc2NyZWVuXG4gICAgICogQHJldHVybiBab29tIHNldHRpbmdzIC0gc2NhbGUgYW5kIHRyYW5zbGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyB6b29tVG9XaW5kb3dTaXplKGJhbm5lckhlaWdodDogbnVtYmVyLCBpbm5lcldpZHRoOiBudW1iZXIsIGlubmVySGVpZ2h0OiBudW1iZXIpOiBUb3BvWm9vbVByZWZzIHtcbiAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gaW5uZXJIZWlnaHQgLSBiYW5uZXJIZWlnaHQ7XG4gICAgICAgIGlmIChuZXdIZWlnaHQgPiBpbm5lcldpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gPFRvcG9ab29tUHJlZnM+e1xuICAgICAgICAgICAgICAgIHNjOiAxLjAsXG4gICAgICAgICAgICAgICAgdHg6IDAsXG4gICAgICAgICAgICAgICAgdHk6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IG5ld0hlaWdodCAvIGlubmVyV2lkdGg7XG4gICAgICAgICAgICByZXR1cm4gPFRvcG9ab29tUHJlZnM+e1xuICAgICAgICAgICAgICAgIHNjOiBzY2FsZSxcbiAgICAgICAgICAgICAgICB0eDogKDUwMCAvIHNjYWxlIC0gNTAwKSAqIHNjYWxlLFxuICAgICAgICAgICAgICAgIHR5OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuIl19