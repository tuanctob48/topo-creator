/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/*
 * Copyright 2018-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable } from '@angular/core';
import { FnService } from '../util/fn.service';
import { LogService } from '../log.service';
import * as gds from './glyphdata.service';
import * as d3 from 'd3';
import { SvgUtilService } from './svgutil.service';
import * as i0 from "@angular/core";
import * as i1 from "../util/fn.service";
import * as i2 from "../log.service";
import * as i3 from "./svgutil.service";
// constants
/** @type {?} */
const msgGS = 'GlyphService.';
/** @type {?} */
const rg = 'registerGlyphs(): ';
/** @type {?} */
const rgs = 'registerGlyphSet(): ';
/**
 * ONOS GUI -- SVG -- Glyph Service
 */
export class GlyphService {
    /**
     * @param {?} fs
     * @param {?} log
     * @param {?} sus
     */
    constructor(fs, log, sus) {
        this.fs = fs;
        this.log = log;
        this.sus = sus;
        // internal state
        this.glyphs = d3.map();
        this.clear();
        this.init();
        this.api = {
            registerGlyphs: this.registerGlyphs,
            registerGlyphSet: this.registerGlyphSet,
            ids: this.ids,
            glyph: this.glyph,
            glyphDefined: this.glyphDefined,
            loadDefs: this.loadDefs,
            addGlyph: this.addGlyph,
        };
        this.log.debug('GlyphService constructed');
    }
    /**
     * @param {?} msg
     * @return {?}
     */
    warn(msg) {
        this.log.warn(msgGS + msg);
    }
    /**
     * @param {?} key
     * @param {?} value
     * @param {?} vbox
     * @param {?} overwrite
     * @param {?} dups
     * @return {?}
     */
    addToMap(key, value, vbox, overwrite, dups) {
        if (!overwrite && this.glyphs.get(key)) {
            dups.push(key);
        }
        else {
            this.glyphs.set(key, { id: key, vb: vbox, d: value });
        }
    }
    /**
     * @param {?} dups
     * @param {?} which
     * @return {?}
     */
    reportDups(dups, which) {
        /** @type {?} */
        const ok = (dups.length === 0);
        /** @type {?} */
        const msg = 'ID collision: ';
        if (!ok) {
            dups.forEach((id) => {
                this.warn(which + msg + '"' + id + '"');
            });
        }
        return ok;
    }
    /**
     * @param {?} missing
     * @param {?} which
     * @return {?}
     */
    reportMissVb(missing, which) {
        /** @type {?} */
        const ok = (missing.length === 0);
        /** @type {?} */
        const msg = 'Missing viewbox property: ';
        if (!ok) {
            missing.forEach((vbk) => {
                this.warn(which + msg + '"' + vbk + '"');
            });
        }
        return ok;
    }
    /**
     * @return {?}
     */
    clear() {
        // start with a fresh map
        this.glyphs = d3.map();
    }
    /**
     * @return {?}
     */
    init() {
        this.log.info('Registering glyphs');
        this.registerGlyphs(gds.logos);
        this.registerGlyphSet(gds.glyphDataSet);
        this.registerGlyphSet(gds.badgeDataSet);
        this.registerGlyphs(gds.spriteData);
        this.registerGlyphSet(gds.mojoDataSet);
        this.registerGlyphs(gds.extraGlyphs);
    }
    /**
     * @param {?} data
     * @param {?=} overwrite
     * @return {?}
     */
    registerGlyphs(data, overwrite = false) {
        /** @type {?} */
        const dups = [];
        /** @type {?} */
        const missvb = [];
        for (const [key, value] of data.entries()) {
            /** @type {?} */
            const vbk = '_' + key;
            /** @type {?} */
            const vb = data.get(vbk);
            if (key[0] !== '_') {
                if (!vb) {
                    missvb.push(vbk);
                    continue;
                }
                this.addToMap(key, value, vb, overwrite, dups);
            }
        }
        return this.reportDups(dups, rg) && this.reportMissVb(missvb, rg);
    }
    /**
     * @param {?} data
     * @param {?=} overwrite
     * @return {?}
     */
    registerGlyphSet(data, overwrite = false) {
        /** @type {?} */
        const dups = [];
        /** @type {?} */
        const vb = data.get('_viewbox');
        if (!vb) {
            this.warn(rgs + 'no "_viewbox" property found');
            return false;
        }
        for (const [key, value] of data.entries()) {
            //        angular.forEach(data, function (value, key) {
            if (key[0] !== '_') {
                this.addToMap(key, value, vb, overwrite, dups);
            }
        }
        return this.reportDups(dups, rgs);
    }
    /**
     * @return {?}
     */
    ids() {
        return this.glyphs.keys();
    }
    /**
     * @param {?} id
     * @return {?}
     */
    glyph(id) {
        return this.glyphs.get(id);
    }
    /**
     * @param {?} id
     * @return {?}
     */
    glyphDefined(id) {
        return this.glyphs.has(id);
    }
    /**
     * Load definitions of a glyph
     *
     * Note: defs should be a D3 selection of a single <defs> element
     * @param {?} defs
     * @param {?} glyphIds
     * @param {?} noClear
     * @return {?}
     */
    loadDefs(defs, glyphIds, noClear) {
        /** @type {?} */
        const list = this.fs.isA(glyphIds) || this.ids();
        if (!noClear) {
            // remove all existing content
            defs.html(null);
        }
        // load up the requested glyphs
        list.forEach((id) => {
            /** @type {?} */
            const g = this.glyph(id);
            if (g) {
                if (noClear) {
                    // quick exit if symbol is already present
                    // TODO: check if this should be a continue or break instead
                    if (defs.select('symbol#' + g.id).size() > 0) {
                        return;
                    }
                }
                defs.append('symbol')
                    .attr('id', g.id)
                    .attr('viewBox', g.vb)
                    .append('path')
                    .attr('d', g.d);
            }
        });
    }
    /**
     * @param {?} elem
     * @param {?} glyphId
     * @param {?} size
     * @param {?} overlay
     * @param {?} trans
     * @return {?}
     */
    addGlyph(elem, glyphId, size, overlay, trans) {
        /** @type {?} */
        const sz = size || 40;
        /** @type {?} */
        const ovr = !!overlay;
        /** @type {?} */
        const xns = this.fs.isA(trans);
        /** @type {?} */
        const glyphUse = elem
            .append('use')
            .attr('width', sz)
            .attr('height', sz)
            .attr('class', 'glyph')
            .attr('xlink:href', '#' + glyphId)
            .classed('overlay', ovr);
        if (xns) {
            glyphUse.attr('transform', this.sus.translate(trans));
        }
        return glyphUse;
    }
}
GlyphService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] },
];
/** @nocollapse */
GlyphService.ctorParameters = () => [
    { type: FnService },
    { type: LogService },
    { type: SvgUtilService }
];
/** @nocollapse */ GlyphService.ngInjectableDef = i0.defineInjectable({ factory: function GlyphService_Factory() { return new GlyphService(i0.inject(i1.FnService), i0.inject(i2.LogService), i0.inject(i3.SvgUtilService)); }, token: GlyphService, providedIn: "root" });
if (false) {
    /** @type {?} */
    GlyphService.prototype.glyphs;
    /** @type {?} */
    GlyphService.prototype.api;
    /** @type {?} */
    GlyphService.prototype.fs;
    /** @type {?} */
    GlyphService.prototype.log;
    /** @type {?} */
    GlyphService.prototype.sus;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2x5cGguc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2d1aTItZnctbGliLyIsInNvdXJjZXMiOlsibGliL3N2Zy9nbHlwaC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUMvQyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDNUMsT0FBTyxLQUFLLEdBQUcsTUFBTSxxQkFBcUIsQ0FBQztBQUMzQyxPQUFPLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQztBQUN6QixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7Ozs7Ozs7TUFHN0MsS0FBSyxHQUFHLGVBQWU7O01BQ3ZCLEVBQUUsR0FBRyxvQkFBb0I7O01BQ3pCLEdBQUcsR0FBRyxzQkFBc0I7Ozs7QUFRbEMsTUFBTSxPQUFPLFlBQVk7Ozs7OztJQUtyQixZQUNZLEVBQWEsRUFFYixHQUFlLEVBQ2YsR0FBbUI7UUFIbkIsT0FBRSxHQUFGLEVBQUUsQ0FBVztRQUViLFFBQUcsR0FBSCxHQUFHLENBQVk7UUFDZixRQUFHLEdBQUgsR0FBRyxDQUFnQjs7UUFQL0IsV0FBTSxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQVNkLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNiLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNaLElBQUksQ0FBQyxHQUFHLEdBQUc7WUFDUCxjQUFjLEVBQUUsSUFBSSxDQUFDLGNBQWM7WUFDbkMsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLGdCQUFnQjtZQUN2QyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUc7WUFDYixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7WUFDakIsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZO1lB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cmlnaHQgMjAxOC1wcmVzZW50IE9wZW4gTmV0d29ya2luZyBGb3VuZGF0aW9uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGblNlcnZpY2UgfSBmcm9tICcuLi91dGlsL2ZuLnNlcnZpY2UnO1xuaW1wb3J0IHsgTG9nU2VydmljZSB9IGZyb20gJy4uL2xvZy5zZXJ2aWNlJztcbmltcG9ydCAqIGFzIGdkcyBmcm9tICcuL2dseXBoZGF0YS5zZXJ2aWNlJztcbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbmltcG9ydCB7IFN2Z1V0aWxTZXJ2aWNlIH0gZnJvbSAnLi9zdmd1dGlsLnNlcnZpY2UnO1xuXG4vLyBjb25zdGFudHNcbmNvbnN0IG1zZ0dTID0gJ0dseXBoU2VydmljZS4nO1xuY29uc3QgcmcgPSAncmVnaXN0ZXJHbHlwaHMoKTogJztcbmNvbnN0IHJncyA9ICdyZWdpc3RlckdseXBoU2V0KCk6ICc7XG5cbi8qKlxuICogT05PUyBHVUkgLS0gU1ZHIC0tIEdseXBoIFNlcnZpY2VcbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIEdseXBoU2VydmljZSB7XG4gICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICBnbHlwaHMgPSBkMy5tYXAoKTtcbiAgICBhcGk6IE9iamVjdDtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGZzOiBGblNlcnZpY2UsXG4gICAgICAgIC8vICAgICAgICBwcml2YXRlIGdkOiBHbHlwaERhdGFTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIGxvZzogTG9nU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBzdXM6IFN2Z1V0aWxTZXJ2aWNlXG4gICAgKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHRoaXMuYXBpID0ge1xuICAgICAgICAgICAgcmVnaXN0ZXJHbHlwaHM6IHRoaXMucmVnaXN0ZXJHbHlwaHMsXG4gICAgICAgICAgICByZWdpc3RlckdseXBoU2V0OiB0aGlzLnJlZ2lzdGVyR2x5cGhTZXQsXG4gICAgICAgICAgICBpZHM6IHRoaXMuaWRzLFxuICAgICAgICAgICAgZ2x5cGg6IHRoaXMuZ2x5cGgsXG4gICAgICAgICAgICBnbHlwaERlZmluZWQ6IHRoaXMuZ2x5cGhEZWZpbmVkLFxuICAgICAgICAgICAgbG9hZERlZnM6IHRoaXMubG9hZERlZnMsXG4gICAgICAgICAgICBhZGRHbHlwaDogdGhpcy5hZGRHbHlwaCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ0dseXBoU2VydmljZSBjb25zdHJ1Y3RlZCcpO1xuICAgIH1cblxuICAgIHdhcm4obXNnOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2cud2Fybihtc2dHUyArIG1zZyk7XG4gICAgfVxuXG4gICAgYWRkVG9NYXAoa2V5LCB2YWx1ZSwgdmJveCwgb3ZlcndyaXRlOiBib29sZWFuLCBkdXBzKSB7XG4gICAgICAgIGlmICghb3ZlcndyaXRlICYmIHRoaXMuZ2x5cGhzLmdldChrZXkpKSB7XG4gICAgICAgICAgICBkdXBzLnB1c2goa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhzLnNldChrZXksIHsgaWQ6IGtleSwgdmI6IHZib3gsIGQ6IHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVwb3J0RHVwcyhkdXBzOiBzdHJpbmdbXSwgd2hpY2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBvazogYm9vbGVhbiA9IChkdXBzLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIGNvbnN0IG1zZyA9ICdJRCBjb2xsaXNpb246ICc7XG5cbiAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgZHVwcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud2Fybih3aGljaCArIG1zZyArICdcIicgKyBpZCArICdcIicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9rO1xuICAgIH1cblxuICAgIHJlcG9ydE1pc3NWYihtaXNzaW5nOiBzdHJpbmdbXSwgd2hpY2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBvazogYm9vbGVhbiA9IChtaXNzaW5nLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIGNvbnN0IG1zZyA9ICdNaXNzaW5nIHZpZXdib3ggcHJvcGVydHk6ICc7XG5cbiAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgbWlzc2luZy5mb3JFYWNoKCh2YmspID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndhcm4od2hpY2ggKyBtc2cgKyAnXCInICsgdmJrICsgJ1wiJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2s7XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIC8vIHN0YXJ0IHdpdGggYSBmcmVzaCBtYXBcbiAgICAgICAgdGhpcy5nbHlwaHMgPSBkMy5tYXAoKTtcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKCdSZWdpc3RlcmluZyBnbHlwaHMnKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckdseXBocyhnZHMubG9nb3MpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyR2x5cGhTZXQoZ2RzLmdseXBoRGF0YVNldCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJHbHlwaFNldChnZHMuYmFkZ2VEYXRhU2V0KTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckdseXBocyhnZHMuc3ByaXRlRGF0YSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJHbHlwaFNldChnZHMubW9qb0RhdGFTZXQpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyR2x5cGhzKGdkcy5leHRyYUdseXBocyk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJHbHlwaHMoZGF0YTogTWFwPHN0cmluZywgc3RyaW5nPiwgb3ZlcndyaXRlOiBib29sZWFuID0gZmFsc2UpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZHVwczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgY29uc3QgbWlzc3ZiOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBkYXRhLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdmJrID0gJ18nICsga2V5O1xuICAgICAgICAgICAgY29uc3QgdmIgPSBkYXRhLmdldCh2YmspO1xuXG4gICAgICAgICAgICBpZiAoa2V5WzBdICE9PSAnXycpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pc3N2Yi5wdXNoKHZiayk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRvTWFwKGtleSwgdmFsdWUsIHZiLCBvdmVyd3JpdGUsIGR1cHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcG9ydER1cHMoZHVwcywgcmcpICYmIHRoaXMucmVwb3J0TWlzc1ZiKG1pc3N2YiwgcmcpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyR2x5cGhTZXQoZGF0YTogTWFwPHN0cmluZywgc3RyaW5nPiwgb3ZlcndyaXRlOiBib29sZWFuID0gZmFsc2UpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZHVwczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgY29uc3QgdmI6IHN0cmluZyA9IGRhdGEuZ2V0KCdfdmlld2JveCcpO1xuXG4gICAgICAgIGlmICghdmIpIHtcbiAgICAgICAgICAgIHRoaXMud2FybihyZ3MgKyAnbm8gXCJfdmlld2JveFwiIHByb3BlcnR5IGZvdW5kJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBkYXRhLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgLy8gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChkYXRhLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gJ18nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUb01hcChrZXksIHZhbHVlLCB2Yiwgb3ZlcndyaXRlLCBkdXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXBvcnREdXBzKGR1cHMsIHJncyk7XG4gICAgfVxuXG4gICAgaWRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbHlwaHMua2V5cygpO1xuICAgIH1cblxuICAgIGdseXBoKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdseXBocy5nZXQoaWQpO1xuICAgIH1cblxuICAgIGdseXBoRGVmaW5lZChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbHlwaHMuaGFzKGlkKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIExvYWQgZGVmaW5pdGlvbnMgb2YgYSBnbHlwaFxuICAgICAqXG4gICAgICogTm90ZTogZGVmcyBzaG91bGQgYmUgYSBEMyBzZWxlY3Rpb24gb2YgYSBzaW5nbGUgPGRlZnM+IGVsZW1lbnRcbiAgICAgKi9cbiAgICBsb2FkRGVmcyhkZWZzLCBnbHlwaElkczogc3RyaW5nW10sIG5vQ2xlYXI6IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMuZnMuaXNBKGdseXBoSWRzKSB8fCB0aGlzLmlkcygpO1xuXG4gICAgICAgIGlmICghbm9DbGVhcikge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBleGlzdGluZyBjb250ZW50XG4gICAgICAgICAgICBkZWZzLmh0bWwobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsb2FkIHVwIHRoZSByZXF1ZXN0ZWQgZ2x5cGhzXG4gICAgICAgIGxpc3QuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGcgPSB0aGlzLmdseXBoKGlkKTtcbiAgICAgICAgICAgIGlmIChnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vQ2xlYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcXVpY2sgZXhpdCBpZiBzeW1ib2wgaXMgYWxyZWFkeSBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIHRoaXMgc2hvdWxkIGJlIGEgY29udGludWUgb3IgYnJlYWsgaW5zdGVhZFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmcy5zZWxlY3QoJ3N5bWJvbCMnICsgZy5pZCkuc2l6ZSgpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZnMuYXBwZW5kKCdzeW1ib2wnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCBnLmlkKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndmlld0JveCcsIGcudmIpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZCcsIGcuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZEdseXBoKGVsZW06IGFueSwgZ2x5cGhJZDogc3RyaW5nLCBzaXplOiBudW1iZXIsIG92ZXJsYXk6IGFueSwgdHJhbnM6IGFueSkge1xuICAgICAgICBjb25zdCBzeiA9IHNpemUgfHwgNDA7XG4gICAgICAgIGNvbnN0IG92ciA9ICEhb3ZlcmxheTtcbiAgICAgICAgY29uc3QgeG5zID0gdGhpcy5mcy5pc0EodHJhbnMpO1xuXG4gICAgICAgIGNvbnN0IGdseXBoVXNlID0gZWxlbVxuICAgICAgICAgICAgLmFwcGVuZCgndXNlJylcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHN6KVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHN6KVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2dseXBoJylcbiAgICAgICAgICAgIC5hdHRyKCd4bGluazpocmVmJywgJyMnICsgZ2x5cGhJZClcbiAgICAgICAgICAgIC5jbGFzc2VkKCdvdmVybGF5Jywgb3ZyKTtcblxuICAgICAgICBpZiAoeG5zKSB7XG4gICAgICAgICAgICBnbHlwaFVzZS5hdHRyKCd0cmFuc2Zvcm0nLCB0aGlzLnN1cy50cmFuc2xhdGUodHJhbnMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbHlwaFVzZTtcbiAgICB9XG59XG4iXX0=