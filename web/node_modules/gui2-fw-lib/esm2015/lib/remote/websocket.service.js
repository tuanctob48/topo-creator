/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/*
 * Copyright 2018-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable, Inject } from '@angular/core';
import { FnService } from '../util/fn.service';
import { GlyphService } from '../svg/glyph.service';
import { LogService } from '../log.service';
import { UrlFnService } from './urlfn.service';
import { WSock } from './wsock.service';
import * as i0 from "@angular/core";
import * as i1 from "../util/fn.service";
import * as i2 from "../svg/glyph.service";
import * as i3 from "../log.service";
import * as i4 from "./urlfn.service";
import * as i5 from "./wsock.service";
/**
 * Event Type structure for the WebSocketService
 * @record
 */
export function EventType() { }
if (false) {
    /** @type {?} */
    EventType.prototype.event;
    /** @type {?} */
    EventType.prototype.payload;
}
/**
 * @record
 */
export function Callback() { }
if (false) {
    /** @type {?} */
    Callback.prototype.id;
    /** @type {?} */
    Callback.prototype.error;
    /**
     * @param {?} host
     * @param {?} url
     * @return {?}
     */
    Callback.prototype.cb = function (host, url) { };
}
/**
 * @record
 */
function ClusterNode() { }
if (false) {
    /** @type {?} */
    ClusterNode.prototype.id;
    /** @type {?} */
    ClusterNode.prototype.ip;
    /** @type {?} */
    ClusterNode.prototype.m_uiAttached;
}
/**
 * @record
 */
function Glyph() { }
if (false) {
    /** @type {?} */
    Glyph.prototype.id;
    /** @type {?} */
    Glyph.prototype.viewbox;
    /** @type {?} */
    Glyph.prototype.path;
}
/**
 * @record
 */
function Bootstrap() { }
if (false) {
    /** @type {?} */
    Bootstrap.prototype.user;
    /** @type {?} */
    Bootstrap.prototype.clusterNodes;
    /** @type {?} */
    Bootstrap.prototype.glyphs;
}
/**
 * @record
 */
function ErrorData() { }
if (false) {
    /** @type {?} */
    ErrorData.prototype.message;
}
/**
 * @record
 */
export function WsOptions() { }
if (false) {
    /** @type {?} */
    WsOptions.prototype.wsport;
}
/**
 * ONOS GUI -- Remote -- Web Socket Service
 *
 * To see debug messages add ?debug=txrx to the URL
 */
export class WebSocketService {
    /**
     * @param {?} fs
     * @param {?} gs
     * @param {?} log
     * @param {?} ufs
     * @param {?} wsock
     * @param {?} window
     */
    constructor(fs, gs, log, ufs, wsock, window) {
        this.fs = fs;
        this.gs = gs;
        this.log = log;
        this.ufs = ufs;
        this.wsock = wsock;
        this.window = window;
        // web socket options
        this.ws = null; // web socket reference
        // web socket reference
        this.wsUp = false; // web socket is good to go
        // web socket is good to go
        // A map of event handler bindings - names and functions (that accept data and return void)
        this.handlers = new Map([]);
        this.pendingEvents = []; // events TX'd while socket not up
        // web socket URL
        this.clusterNodes = []; // ONOS instances data for failover
        // ONOS instances data for failover
        this.clusterIndex = -1; // the instance to which we are connected
        // the instance to which we are connected
        this.glyphs = [];
        this.connectRetries = 0; // limit our attempts at reconnecting
        // limit our attempts at reconnecting
        // A map of registered Callbacks for websocket open()
        this.openListeners = new Map([]);
        this.nextListenerId = 1; // internal ID for open listeners
        // internal ID for open listeners
        this.loggedInUser = null; // name of logged-in user
        this.log.debug(window.location.hostname);
        // Bind the boot strap event by default
        this.bindHandlers(new Map([
            ['bootstrap', (data) => this.bootstrap(data)],
            ['error', (data) => this.error(data)]
        ]));
        this.log.debug('WebSocketService constructed');
    }
    // The veil component delegate
    /**
     * built-in handler for the 'boostrap' event
     * @param {?} data
     * @return {?}
     */
    bootstrap(data) {
        this.loggedInUser = data.user;
        this.log.info('Websocket connection bootstraped', data);
        this.clusterNodes = data.clusterNodes;
        this.clusterNodes.forEach((d, i) => {
            if (d.m_uiAttached) {
                this.clusterIndex = i;
                this.log.info('Connected to cluster node ' + d.ip);
                // TODO: add connect info to masthead somewhere
            }
        });
        this.glyphs = data.glyphs;
        /** @type {?} */
        const glyphsMap = new Map([]);
        this.glyphs.forEach((d) => {
            glyphsMap.set('_' + d.id, d.viewbox);
            glyphsMap.set(d.id, d.path);
            this.gs.registerGlyphs(glyphsMap);
        });
    }
    /**
     * @param {?} data
     * @return {?}
     */
    error(data) {
        /** @type {?} */
        const m = data.message || 'error from server';
        this.log.error(m, data);
        // Unrecoverable error - throw up the veil...
        if (this.vcd) {
            this.vcd.show([
                'Oops!',
                'Server reports error...',
                m,
            ]);
        }
    }
    // ==========================
    // === Web socket callbacks
    /**
     * Called when WebSocket has just opened
     *
     * Lift the Veil if it is displayed
     * If there are any events pending, send them
     * Mark the WSS as up and inform any listeners for this open event
     * @return {?}
     */
    handleOpen() {
        this.log.info('Web socket open - ', this.url);
        // Hide the veil
        if (this.vcd) {
            this.vcd.hide();
        }
        if (this.fs.debugOn('txrx')) {
            this.log.debug('Sending ' + this.pendingEvents.length + ' pending event(s)...');
        }
        this.pendingEvents.forEach((ev) => {
            this.send(ev);
        });
        this.pendingEvents = [];
        this.connectRetries = 0;
        this.wsUp = true;
        this.informListeners(this.host, this.url);
    }
    /**
     * Function called when WebSocket send a message
     * @param {?} msgEvent
     * @return {?}
     */
    handleMessage(msgEvent) {
        /** @type {?} */
        let ev;
        /** @type {?} */
        let h;
        try {
            ev = JSON.parse(msgEvent.data);
        }
        catch (e) {
            this.log.error('Message.data is not valid JSON', msgEvent.data, e);
            return null;
        }
        if (this.fs.debugOn('txrx')) {
            this.log.debug(' << *Rx* ', ev.event, ev.payload);
        }
        h = this.handlers.get(ev.event);
        if (h) {
            try {
                h(ev.payload);
            }
            catch (e) {
                this.log.error('Problem handling event:', ev, e);
                return null;
            }
        }
        else {
            this.log.warn('Unhandled event:', ev);
        }
    }
    /**
     * Called by the WebSocket if it is closed from the server end
     *
     * If the loading component is shown, call stop() on it
     * Try to find another node in the cluster to connect to
     * If this is not possible then show the Veil Component
     * @return {?}
     */
    handleClose() {
        this.log.warn('Web socket closed');
        if (this.lcd) {
            this.lcd.stop();
        }
        this.wsUp = false;
        /** @type {?} */
        let gsucc;
        if (gsucc = this.findGuiSuccessor()) {
            this.url = this.createWebSocket(this.webSockOpts, gsucc);
        }
        else {
            // If no controllers left to contact, show the Veil...
            if (this.vcd) {
                this.vcd.show([
                    'Oops!',
                    'Web-socket connection to server closed...',
                    'Try refreshing the page.',
                ]);
            }
        }
    }
    // ==============================
    // === Private Helper Functions
    /**
     * Find the next node in the ONOS cluster.
     *
     * This is used if the WebSocket connection closes because a
     * node in the cluster ges down - fail over should be automatic
     * @return {?}
     */
    findGuiSuccessor() {
        /** @type {?} */
        const ncn = this.clusterNodes.length;
        /** @type {?} */
        let ip;
        /** @type {?} */
        let node;
        while (this.connectRetries < ncn && !ip) {
            this.connectRetries++;
            this.clusterIndex = (this.clusterIndex + 1) % ncn;
            node = this.clusterNodes[this.clusterIndex];
            ip = node && node.ip;
        }
        return ip;
    }
    /**
     * When the WebSocket is opened, inform any listeners that registered
     * for that event
     * @param {?} host
     * @param {?} url
     * @return {?}
     */
    informListeners(host, url) {
        for (const [key, cb] of this.openListeners.entries()) {
            cb.cb(host, url);
        }
    }
    /**
     * @param {?} ev
     * @return {?}
     */
    send(ev) {
        if (this.fs.debugOn('txrx')) {
            this.log.debug(' *Tx* >> ', ev.event, ev.payload);
        }
        this.ws.send(JSON.stringify(ev));
    }
    /**
     * Check if there are no WSS event handlers left
     * @param {?} handlers
     * @param {?} caller
     * @return {?}
     */
    noHandlersWarn(handlers, caller) {
        if (!handlers || handlers.size === 0) {
            this.log.warn('WSS.' + caller + '(): no event handlers');
            return true;
        }
        return false;
    }
    /* ===================
         * === API Functions
         */
    /**
     * Required for unit tests to set to known state
     * @return {?}
     */
    resetState() {
        this.webSockOpts = undefined;
        this.ws = null;
        this.wsUp = false;
        this.host = undefined;
        this.url = undefined;
        this.pendingEvents = [];
        this.handlers.clear();
        this.clusterNodes = [];
        this.clusterIndex = -1;
        this.glyphs = [];
        this.connectRetries = 0;
        this.openListeners.clear();
        this.nextListenerId = 1;
    }
    /*
         * Currently supported opts:
         *  wsport: web socket port (other than default 8181)
         *  host:   if defined, is the host address to use
         */
    /**
     * @param {?=} opts
     * @param {?=} host
     * @return {?}
     */
    createWebSocket(opts, host) {
        this.webSockOpts = opts; // preserved for future calls
        this.host = host === undefined ? this.window.location.host : host;
        this.url = this.ufs.wsUrl('core', opts === undefined ? '' : opts['wsport'].toString(), host);
        this.log.debug('Attempting to open websocket to: ' + this.url);
        this.ws = this.wsock.newWebSocket(this.url);
        if (this.ws) {
            // fat arrow => syntax means that the 'this' context passed will
            // be of WebSocketService, not the WebSocket
            this.ws.onopen = (() => this.handleOpen());
            this.ws.onmessage = ((msgEvent) => this.handleMessage(msgEvent));
            this.ws.onclose = (() => this.handleClose());
            /** @type {?} */
            const authToken = this.window['onosAuth'];
            this.log.debug('Auth Token for opening WebSocket', authToken);
            this.sendEvent('authentication', { token: authToken });
        }
        // Note: Wsock logs an error if the new WebSocket call fails
        return this.url;
    }
    /**
     * Tell the WebSocket to close - this should call the handleClose() method
     * @return {?}
     */
    closeWebSocket() {
        this.ws.close();
    }
    /**
     * Binds the message handlers to their message type (event type) as
     *  specified in the given map. Note that keys are the event IDs; values
     *  are either:
     *     * the event handler function, or
     *     * an API object which has an event handler for the key
     * @param {?} handlerMap
     * @return {?}
     */
    bindHandlers(handlerMap) {
        /** @type {?} */
        const dups = [];
        if (this.noHandlersWarn(handlerMap, 'bindHandlers')) {
            return null;
        }
        for (const [eventId, api] of handlerMap) {
            this.log.debug('Adding handler for ', eventId);
            /** @type {?} */
            const fn = this.fs.isF(api) || this.fs.isF(api[eventId]);
            if (!fn) {
                this.log.warn(eventId + ' handler not a function');
                return;
            }
            if (this.handlers.get(eventId)) {
                dups.push(eventId);
            }
            else {
                this.handlers.set(eventId, fn);
            }
        }
        if (dups.length) {
            this.log.warn('duplicate bindings ignored:', dups);
        }
    }
    /**
     * Unbinds the specified message handlers.
     *   Expected that the same map will be used, but we only care about keys
     * @param {?} handlerIds
     * @return {?}
     */
    unbindHandlers(handlerIds) {
        if (handlerIds.length === 0) {
            this.log.warn('WSS.unbindHandlers(): no event handlers');
            return null;
        }
        for (const eventId of handlerIds) {
            this.handlers.delete(eventId);
        }
    }
    /**
     * @param {?} handlerId
     * @return {?}
     */
    isHandling(handlerId) {
        return this.handlers.get(handlerId) !== undefined;
    }
    /**
     * Add a listener function for listening for WebSocket opening.
     * The function must give a host and url and return void
     * @param {?} callback
     * @return {?}
     */
    addOpenListener(callback) {
        /** @type {?} */
        const id = this.nextListenerId++;
        /** @type {?} */
        const cb = this.fs.isF(callback);
        /** @type {?} */
        const o = (/** @type {?} */ ({ id: id, cb: cb }));
        if (cb) {
            this.openListeners.set(id, o);
        }
        else {
            this.log.error('WSS.addOpenListener(): callback not a function');
            o.error = 'No callback defined';
        }
        return o;
    }
    /**
     * Remove a listener of WebSocket opening
     * @param {?} lsnr
     * @return {?}
     */
    removeOpenListener(lsnr) {
        /** @type {?} */
        const id = this.fs.isO(lsnr) && lsnr.id;
        /** @type {?} */
        let o;
        if (!id) {
            this.log.warn('WSS.removeOpenListener(): invalid listener', lsnr);
            return null;
        }
        o = this.openListeners[id];
        if (o) {
            this.openListeners.delete(id);
        }
    }
    /**
     * Formulates an event message and sends it via the web-socket.
     * If the websocket is not up yet, we store it in a pending list.
     * @param {?} evType
     * @param {?} payload
     * @return {?}
     */
    sendEvent(evType, payload) {
        /** @type {?} */
        const ev = (/** @type {?} */ ({
            event: evType,
            payload: payload
        }));
        if (this.wsUp) {
            this.send(ev);
        }
        else {
            this.pendingEvents.push(ev);
        }
    }
    /**
     * Binds the veil service as a delegate.
     * @param {?} vd
     * @return {?}
     */
    setVeilDelegate(vd) {
        this.vcd = vd;
    }
    /**
     * Binds the loading service as a delegate
     * @param {?} ld
     * @return {?}
     */
    setLoadingDelegate(ld) {
        // TODO - Investigate changing Loading Service to LoadingComponent
        this.log.debug('Loading delegate set', ld);
        this.lcd = ld;
    }
    /**
     * @return {?}
     */
    isConnected() {
        return this.wsUp;
    }
}
WebSocketService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] },
];
/** @nocollapse */
WebSocketService.ctorParameters = () => [
    { type: FnService },
    { type: GlyphService },
    { type: LogService },
    { type: UrlFnService },
    { type: WSock },
    { type: undefined, decorators: [{ type: Inject, args: ['Window',] }] }
];
/** @nocollapse */ WebSocketService.ngInjectableDef = i0.defineInjectable({ factory: function WebSocketService_Factory() { return new WebSocketService(i0.inject(i1.FnService), i0.inject(i2.GlyphService), i0.inject(i3.LogService), i0.inject(i4.UrlFnService), i0.inject(i5.WSock), i0.inject("Window")); }, token: WebSocketService, providedIn: "root" });
if (false) {
    /** @type {?} */
    WebSocketService.prototype.webSockOpts;
    /** @type {?} */
    WebSocketService.prototype.ws;
    /** @type {?} */
    WebSocketService.prototype.wsUp;
    /** @type {?} */
    WebSocketService.prototype.handlers;
    /** @type {?} */
    WebSocketService.prototype.pendingEvents;
    /** @type {?} */
    WebSocketService.prototype.host;
    /** @type {?} */
    WebSocketService.prototype.url;
    /** @type {?} */
    WebSocketService.prototype.clusterNodes;
    /** @type {?} */
    WebSocketService.prototype.clusterIndex;
    /** @type {?} */
    WebSocketService.prototype.glyphs;
    /** @type {?} */
    WebSocketService.prototype.connectRetries;
    /** @type {?} */
    WebSocketService.prototype.openListeners;
    /** @type {?} */
    WebSocketService.prototype.nextListenerId;
    /** @type {?} */
    WebSocketService.prototype.loggedInUser;
    /** @type {?} */
    WebSocketService.prototype.lcd;
    /** @type {?} */
    WebSocketService.prototype.vcd;
    /** @type {?} */
    WebSocketService.prototype.fs;
    /** @type {?} */
    WebSocketService.prototype.gs;
    /** @type {?} */
    WebSocketService.prototype.log;
    /** @type {?} */
    WebSocketService.prototype.ufs;
    /** @type {?} */
    WebSocketService.prototype.wsock;
    /** @type {?} */
    WebSocketService.prototype.window;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2Vic29ja2V0LnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9ndWkyLWZ3LWxpYi8iLCJzb3VyY2VzIjpbImxpYi9yZW1vdGUvd2Vic29ja2V0LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWVBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ25ELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUMvQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDcEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzVDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUUvQyxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0saUJBQWlCLENBQUM7Ozs7Ozs7Ozs7O0FBS3hDLCtCQUdDOzs7SUFGRywwQkFBYzs7SUFDZCw0QkFBZ0I7Ozs7O0FBR3BCLDhCQUlDOzs7SUFIRyxzQkFBVzs7SUFDWCx5QkFBYzs7Ozs7O0lBQ2QsaURBQW9DOzs7OztBQUd4QywwQkFJQzs7O0lBSEcseUJBQVc7O0lBQ1gseUJBQVc7O0lBQ1gsbUNBQXNCOzs7OztBQUcxQixvQkFJQzs7O0lBSEcsbUJBQVc7O0lBQ1gsd0JBQWdCOztJQUNoQixxQkFBYTs7Ozs7QUFHakIsd0JBSUM7OztJQUhHLHlCQUFhOztJQUNiLGlDQUE0Qjs7SUFDNUIsMkJBQWdCOzs7OztBQUdwQix3QkFFQzs7O0lBREcsNEJBQWdCOzs7OztBQUdwQiwrQkFFQzs7O0lBREcsMkJBQWU7Ozs7Ozs7QUFXbkIsTUFBTSxPQUFPLGdCQUFnQjs7Ozs7Ozs7O0lBNkR6QixZQUNZLEVBQWEsRUFDYixFQUFnQixFQUNoQixHQUFlLEVBQ2YsR0FBaUIsRUFDakIsS0FBWSxFQUNNLE1BQVc7UUFMN0IsT0FBRSxHQUFGLEVBQUUsQ0FBVztRQUNiLE9B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LEdBQUcsR0FBRyxFQUFFLENBQUM7SUFDbEIsQ0FBQzs7OztJQUVELFdBQVc7UUFDUCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDckIsQ0FBQzs7O1lBbFpKLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7OztZQXREUSxTQUFTO1lBQ1QsWUFBWTtZQUNaLFVBQVU7WUFDVixZQUFZO1lBRVosS0FBSzs0Q0FxSEwsTUFBTSxTQUFDLFFBQVE7Ozs7O0lBakVwQix1Q0FBK0I7O0lBQy9CLDhCQUE2Qjs7SUFDN0IsZ0NBQThCOztJQUc5QixvQ0FBNEQ7O0lBQzVELHlDQUF3Qzs7SUFDeEMsZ0NBQXFCOztJQUNyQiwrQkFBWTs7SUFDWix3Q0FBeUM7O0lBQ3pDLHdDQUEwQjs7SUFDMUIsa0NBQTZCOztJQUM3QiwwQ0FBbUM7O0lBR25DLHlDQUFzRDs7SUFDdEQsMENBQW1DOztJQUNuQyx3Q0FBNEI7O0lBQzVCLCtCQUFpQjs7SUFDakIsK0JBQWlCOztJQXlDYiw4QkFBcUI7O0lBQ3JCLDhCQUF3Qjs7SUFDeEIsK0JBQXVCOztJQUN2QiwrQkFBeUI7O0lBQ3pCLGlDQUFvQjs7SUFDcEIsa0NBQXFDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDE4LXByZXNlbnQgT3BlbiBOZXR3b3JraW5nIEZvdW5kYXRpb25cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm5TZXJ2aWNlIH0gZnJvbSAnLi4vdXRpbC9mbi5zZXJ2aWNlJztcbmltcG9ydCB7IEdseXBoU2VydmljZSB9IGZyb20gJy4uL3N2Zy9nbHlwaC5zZXJ2aWNlJztcbmltcG9ydCB7IExvZ1NlcnZpY2UgfSBmcm9tICcuLi9sb2cuc2VydmljZSc7XG5pbXBvcnQgeyBVcmxGblNlcnZpY2UgfSBmcm9tICcuL3VybGZuLnNlcnZpY2UnO1xuaW1wb3J0IHsgVmVpbENvbXBvbmVudCB9IGZyb20gJy4uL2xheWVyL3ZlaWwvdmVpbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgV1NvY2sgfSBmcm9tICcuL3dzb2NrLnNlcnZpY2UnO1xuXG4vKipcbiAqIEV2ZW50IFR5cGUgc3RydWN0dXJlIGZvciB0aGUgV2ViU29ja2V0U2VydmljZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50VHlwZSB7XG4gICAgZXZlbnQ6IHN0cmluZztcbiAgICBwYXlsb2FkOiBPYmplY3Q7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbGJhY2sge1xuICAgIGlkOiBudW1iZXI7XG4gICAgZXJyb3I6IHN0cmluZztcbiAgICBjYihob3N0OiBzdHJpbmcsIHVybDogc3RyaW5nKTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIENsdXN0ZXJOb2RlIHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGlwOiBzdHJpbmc7XG4gICAgbV91aUF0dGFjaGVkOiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgR2x5cGgge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgdmlld2JveDogc3RyaW5nO1xuICAgIHBhdGg6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEJvb3RzdHJhcCB7XG4gICAgdXNlcjogc3RyaW5nO1xuICAgIGNsdXN0ZXJOb2RlczogQ2x1c3Rlck5vZGVbXTtcbiAgICBnbHlwaHM6IEdseXBoW107XG59XG5cbmludGVyZmFjZSBFcnJvckRhdGEge1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXc09wdGlvbnMge1xuICAgIHdzcG9ydDogbnVtYmVyO1xufVxuXG4vKipcbiAqIE9OT1MgR1VJIC0tIFJlbW90ZSAtLSBXZWIgU29ja2V0IFNlcnZpY2VcbiAqXG4gKiBUbyBzZWUgZGVidWcgbWVzc2FnZXMgYWRkID9kZWJ1Zz10eHJ4IHRvIHRoZSBVUkxcbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIFdlYlNvY2tldFNlcnZpY2Uge1xuICAgIC8vIGludGVybmFsIHN0YXRlXG4gICAgcHJpdmF0ZSB3ZWJTb2NrT3B0czogV3NPcHRpb25zOyAvLyB3ZWIgc29ja2V0IG9wdGlvbnNcbiAgICBwcml2YXRlIHdzOiBXZWJTb2NrZXQgPSBudWxsOyAvLyB3ZWIgc29ja2V0IHJlZmVyZW5jZVxuICAgIHByaXZhdGUgd3NVcDogYm9vbGVhbiA9IGZhbHNlOyAvLyB3ZWIgc29ja2V0IGlzIGdvb2QgdG8gZ29cblxuICAgIC8vIEEgbWFwIG9mIGV2ZW50IGhhbmRsZXIgYmluZGluZ3MgLSBuYW1lcyBhbmQgZnVuY3Rpb25zICh0aGF0IGFjY2VwdCBkYXRhIGFuZCByZXR1cm4gdm9pZClcbiAgICBwcml2YXRlIGhhbmRsZXJzID0gbmV3IE1hcDxzdHJpbmcsIChkYXRhOiBhbnkpID0+IHZvaWQ+KFtdKTtcbiAgICBwcml2YXRlIHBlbmRpbmdFdmVudHM6IEV2ZW50VHlwZVtdID0gW107IC8vIGV2ZW50cyBUWCdkIHdoaWxlIHNvY2tldCBub3QgdXBcbiAgICBwcml2YXRlIGhvc3Q6IHN0cmluZzsgLy8gd2ViIHNvY2tldCBob3N0XG4gICAgcHJpdmF0ZSB1cmw7IC8vIHdlYiBzb2NrZXQgVVJMXG4gICAgcHJpdmF0ZSBjbHVzdGVyTm9kZXM6IENsdXN0ZXJOb2RlW10gPSBbXTsgLy8gT05PUyBpbnN0YW5jZXMgZGF0YSBmb3IgZmFpbG92ZXJcbiAgICBwcml2YXRlIGNsdXN0ZXJJbmRleCA9IC0xOyAvLyB0aGUgaW5zdGFuY2UgdG8gd2hpY2ggd2UgYXJlIGNvbm5lY3RlZFxuICAgIHByaXZhdGUgZ2x5cGhzOiBHbHlwaFtdID0gW107XG4gICAgcHJpdmF0ZSBjb25uZWN0UmV0cmllczogbnVtYmVyID0gMDsgLy8gbGltaXQgb3VyIGF0dGVtcHRzIGF0IHJlY29ubmVjdGluZ1xuXG4gICAgLy8gQSBtYXAgb2YgcmVnaXN0ZXJlZCBDYWxsYmFja3MgZm9yIHdlYnNvY2tldCBvcGVuKClcbiAgICBwcml2YXRlIG9wZW5MaXN0ZW5lcnMgPSBuZXcgTWFwPG51bWJlciwgQ2FsbGJhY2s+KFtdKTtcbiAgICBwcml2YXRlIG5leHRMaXN0ZW5lcklkOiBudW1iZXIgPSAxOyAvLyBpbnRlcm5hbCBJRCBmb3Igb3BlbiBsaXN0ZW5lcnNcbiAgICBwcml2YXRlIGxvZ2dlZEluVXNlciA9IG51bGw7IC8vIG5hbWUgb2YgbG9nZ2VkLWluIHVzZXJcbiAgICBwcml2YXRlIGxjZDogYW55OyAvLyBUaGUgbG9hZGluZyBjb21wb25lbnQgZGVsZWdhdGVcbiAgICBwcml2YXRlIHZjZDogYW55OyAvLyBUaGUgdmVpbCBjb21wb25lbnQgZGVsZWdhdGVcblxuICAgIC8qKlxuICAgICAqIGJ1aWx0LWluIGhhbmRsZXIgZm9yIHRoZSAnYm9vc3RyYXAnIGV2ZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSBib290c3RyYXAoZGF0YTogQm9vdHN0cmFwKSB7XG4gICAgICAgIHRoaXMubG9nZ2VkSW5Vc2VyID0gZGF0YS51c2VyO1xuICAgICAgICB0aGlzLmxvZy5pbmZvKCdXZWJzb2NrZXQgY29ubmVjdGlvbiBib290c3RyYXBlZCcsIGRhdGEpO1xuXG4gICAgICAgIHRoaXMuY2x1c3Rlck5vZGVzID0gZGF0YS5jbHVzdGVyTm9kZXM7XG4gICAgICAgIHRoaXMuY2x1c3Rlck5vZGVzLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChkLm1fdWlBdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2x1c3RlckluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5pbmZvKCdDb25uZWN0ZWQgdG8gY2x1c3RlciBub2RlICcgKyBkLmlwKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhZGQgY29ubmVjdCBpbmZvIHRvIG1hc3RoZWFkIHNvbWV3aGVyZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nbHlwaHMgPSBkYXRhLmdseXBocztcbiAgICAgICAgY29uc3QgZ2x5cGhzTWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oW10pO1xuICAgICAgICB0aGlzLmdseXBocy5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgICAgICBnbHlwaHNNYXAuc2V0KCdfJyArIGQuaWQsIGQudmlld2JveCk7XG4gICAgICAgICAgICBnbHlwaHNNYXAuc2V0KGQuaWQsIGQucGF0aCk7XG4gICAgICAgICAgICB0aGlzLmdzLnJlZ2lzdGVyR2x5cGhzKGdseXBoc01hcCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZXJyb3IoZGF0YTogRXJyb3JEYXRhKSB7XG4gICAgICAgIGNvbnN0IG06IHN0cmluZyA9IGRhdGEubWVzc2FnZSB8fCAnZXJyb3IgZnJvbSBzZXJ2ZXInO1xuICAgICAgICB0aGlzLmxvZy5lcnJvcihtLCBkYXRhKTtcblxuICAgICAgICAvLyBVbnJlY292ZXJhYmxlIGVycm9yIC0gdGhyb3cgdXAgdGhlIHZlaWwuLi5cbiAgICAgICAgaWYgKHRoaXMudmNkKSB7XG4gICAgICAgICAgICB0aGlzLnZjZC5zaG93KFtcbiAgICAgICAgICAgICAgICAnT29wcyEnLFxuICAgICAgICAgICAgICAgICdTZXJ2ZXIgcmVwb3J0cyBlcnJvci4uLicsXG4gICAgICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgZnM6IEZuU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBnczogR2x5cGhTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIGxvZzogTG9nU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSB1ZnM6IFVybEZuU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSB3c29jazogV1NvY2ssXG4gICAgICAgIEBJbmplY3QoJ1dpbmRvdycpIHByaXZhdGUgd2luZG93OiBhbnlcbiAgICApIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKTtcblxuICAgICAgICAvLyBCaW5kIHRoZSBib290IHN0cmFwIGV2ZW50IGJ5IGRlZmF1bHRcbiAgICAgICAgdGhpcy5iaW5kSGFuZGxlcnMobmV3IE1hcDxzdHJpbmcsIChkYXRhKSA9PiB2b2lkPihbXG4gICAgICAgICAgICBbJ2Jvb3RzdHJhcCcsIChkYXRhKSA9PiB0aGlzLmJvb3RzdHJhcChkYXRhKV0sXG4gICAgICAgICAgICBbJ2Vycm9yJywgKGRhdGEpID0+IHRoaXMuZXJyb3IoZGF0YSldXG4gICAgICAgIF0pKTtcblxuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnV2ViU29ja2V0U2VydmljZSBjb25zdHJ1Y3RlZCcpO1xuICAgIH1cblxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyA9PT0gV2ViIHNvY2tldCBjYWxsYmFja3NcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIFdlYlNvY2tldCBoYXMganVzdCBvcGVuZWRcbiAgICAgKlxuICAgICAqIExpZnQgdGhlIFZlaWwgaWYgaXQgaXMgZGlzcGxheWVkXG4gICAgICogSWYgdGhlcmUgYXJlIGFueSBldmVudHMgcGVuZGluZywgc2VuZCB0aGVtXG4gICAgICogTWFyayB0aGUgV1NTIGFzIHVwIGFuZCBpbmZvcm0gYW55IGxpc3RlbmVycyBmb3IgdGhpcyBvcGVuIGV2ZW50XG4gICAgICovXG4gICAgaGFuZGxlT3BlbigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2cuaW5mbygnV2ViIHNvY2tldCBvcGVuIC0gJywgdGhpcy51cmwpO1xuICAgICAgICAvLyBIaWRlIHRoZSB2ZWlsXG4gICAgICAgIGlmICh0aGlzLnZjZCkge1xuICAgICAgICAgICAgdGhpcy52Y2QuaGlkZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZnMuZGVidWdPbigndHhyeCcpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnU2VuZGluZyAnICsgdGhpcy5wZW5kaW5nRXZlbnRzLmxlbmd0aCArICcgcGVuZGluZyBldmVudChzKS4uLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ0V2ZW50cy5mb3JFYWNoKChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZW5kKGV2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGVuZGluZ0V2ZW50cyA9IFtdO1xuXG4gICAgICAgIHRoaXMuY29ubmVjdFJldHJpZXMgPSAwO1xuICAgICAgICB0aGlzLndzVXAgPSB0cnVlO1xuICAgICAgICB0aGlzLmluZm9ybUxpc3RlbmVycyh0aGlzLmhvc3QsIHRoaXMudXJsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBjYWxsZWQgd2hlbiBXZWJTb2NrZXQgc2VuZCBhIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBoYW5kbGVNZXNzYWdlKG1zZ0V2ZW50OiBNZXNzYWdlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgbGV0IGV2OiBFdmVudFR5cGU7XG4gICAgICAgIGxldCBoO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXYgPSBKU09OLnBhcnNlKG1zZ0V2ZW50LmRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignTWVzc2FnZS5kYXRhIGlzIG5vdCB2YWxpZCBKU09OJywgbXNnRXZlbnQuZGF0YSwgZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mcy5kZWJ1Z09uKCd0eHJ4JykpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCcgPDwgKlJ4KiAnLCBldi5ldmVudCwgZXYucGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgaCA9IHRoaXMuaGFuZGxlcnMuZ2V0KGV2LmV2ZW50KTtcbiAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaChldi5wYXlsb2FkKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignUHJvYmxlbSBoYW5kbGluZyBldmVudDonLCBldiwgZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdVbmhhbmRsZWQgZXZlbnQ6JywgZXYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IHRoZSBXZWJTb2NrZXQgaWYgaXQgaXMgY2xvc2VkIGZyb20gdGhlIHNlcnZlciBlbmRcbiAgICAgKlxuICAgICAqIElmIHRoZSBsb2FkaW5nIGNvbXBvbmVudCBpcyBzaG93biwgY2FsbCBzdG9wKCkgb24gaXRcbiAgICAgKiBUcnkgdG8gZmluZCBhbm90aGVyIG5vZGUgaW4gdGhlIGNsdXN0ZXIgdG8gY29ubmVjdCB0b1xuICAgICAqIElmIHRoaXMgaXMgbm90IHBvc3NpYmxlIHRoZW4gc2hvdyB0aGUgVmVpbCBDb21wb25lbnRcbiAgICAgKi9cbiAgICBoYW5kbGVDbG9zZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignV2ViIHNvY2tldCBjbG9zZWQnKTtcbiAgICAgICAgaWYgKHRoaXMubGNkKSB7XG4gICAgICAgICAgICB0aGlzLmxjZC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53c1VwID0gZmFsc2U7XG4gICAgICAgIGxldCBnc3VjYztcblxuICAgICAgICBpZiAoZ3N1Y2MgPSB0aGlzLmZpbmRHdWlTdWNjZXNzb3IoKSkge1xuICAgICAgICAgICAgdGhpcy51cmwgPSB0aGlzLmNyZWF0ZVdlYlNvY2tldCh0aGlzLndlYlNvY2tPcHRzLCBnc3VjYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBubyBjb250cm9sbGVycyBsZWZ0IHRvIGNvbnRhY3QsIHNob3cgdGhlIFZlaWwuLi5cbiAgICAgICAgICAgIGlmICh0aGlzLnZjZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmNkLnNob3coW1xuICAgICAgICAgICAgICAgICAgICAnT29wcyEnLCAgLy8gVE9ETzogTG9jYWxpemUgdGhpc1xuICAgICAgICAgICAgICAgICAgICAnV2ViLXNvY2tldCBjb25uZWN0aW9uIHRvIHNlcnZlciBjbG9zZWQuLi4nLFxuICAgICAgICAgICAgICAgICAgICAnVHJ5IHJlZnJlc2hpbmcgdGhlIHBhZ2UuJyxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vID09PSBQcml2YXRlIEhlbHBlciBGdW5jdGlvbnNcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIG5leHQgbm9kZSBpbiB0aGUgT05PUyBjbHVzdGVyLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VkIGlmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZXMgYmVjYXVzZSBhXG4gICAgICogbm9kZSBpbiB0aGUgY2x1c3RlciBnZXMgZG93biAtIGZhaWwgb3ZlciBzaG91bGQgYmUgYXV0b21hdGljXG4gICAgICovXG4gICAgZmluZEd1aVN1Y2Nlc3NvcigpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBuY24gPSB0aGlzLmNsdXN0ZXJOb2Rlcy5sZW5ndGg7XG4gICAgICAgIGxldCBpcDogc3RyaW5nO1xuICAgICAgICBsZXQgbm9kZTtcblxuICAgICAgICB3aGlsZSAodGhpcy5jb25uZWN0UmV0cmllcyA8IG5jbiAmJiAhaXApIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFJldHJpZXMrKztcbiAgICAgICAgICAgIHRoaXMuY2x1c3RlckluZGV4ID0gKHRoaXMuY2x1c3RlckluZGV4ICsgMSkgJSBuY247XG4gICAgICAgICAgICBub2RlID0gdGhpcy5jbHVzdGVyTm9kZXNbdGhpcy5jbHVzdGVySW5kZXhdO1xuICAgICAgICAgICAgaXAgPSBub2RlICYmIG5vZGUuaXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgV2ViU29ja2V0IGlzIG9wZW5lZCwgaW5mb3JtIGFueSBsaXN0ZW5lcnMgdGhhdCByZWdpc3RlcmVkXG4gICAgICogZm9yIHRoYXQgZXZlbnRcbiAgICAgKi9cbiAgICBpbmZvcm1MaXN0ZW5lcnMoaG9zdDogc3RyaW5nLCB1cmw6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGNiXSBvZiB0aGlzLm9wZW5MaXN0ZW5lcnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjYi5jYihob3N0LCB1cmwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VuZChldjogRXZlbnRUeXBlKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmZzLmRlYnVnT24oJ3R4cngnKSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJyAqVHgqID4+ICcsIGV2LmV2ZW50LCBldi5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndzLnNlbmQoSlNPTi5zdHJpbmdpZnkoZXYpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGVyZSBhcmUgbm8gV1NTIGV2ZW50IGhhbmRsZXJzIGxlZnRcbiAgICAgKi9cbiAgICBub0hhbmRsZXJzV2FybihoYW5kbGVyczogTWFwPHN0cmluZywgT2JqZWN0PiwgY2FsbGVyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKCFoYW5kbGVycyB8fCBoYW5kbGVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdXU1MuJyArIGNhbGxlciArICcoKTogbm8gZXZlbnQgaGFuZGxlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09XG4gICAgICogPT09IEFQSSBGdW5jdGlvbnNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkIGZvciB1bml0IHRlc3RzIHRvIHNldCB0byBrbm93biBzdGF0ZVxuICAgICAqL1xuICAgIHJlc2V0U3RhdGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMud2ViU29ja09wdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMud3MgPSBudWxsO1xuICAgICAgICB0aGlzLndzVXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ob3N0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnVybCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wZW5kaW5nRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuaGFuZGxlcnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5jbHVzdGVyTm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jbHVzdGVySW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5nbHlwaHMgPSBbXTtcbiAgICAgICAgdGhpcy5jb25uZWN0UmV0cmllcyA9IDA7XG4gICAgICAgIHRoaXMub3Blbkxpc3RlbmVycy5jbGVhcigpO1xuICAgICAgICB0aGlzLm5leHRMaXN0ZW5lcklkID0gMTtcblxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ3VycmVudGx5IHN1cHBvcnRlZCBvcHRzOlxuICAgICAqICB3c3BvcnQ6IHdlYiBzb2NrZXQgcG9ydCAob3RoZXIgdGhhbiBkZWZhdWx0IDgxODEpXG4gICAgICogIGhvc3Q6ICAgaWYgZGVmaW5lZCwgaXMgdGhlIGhvc3QgYWRkcmVzcyB0byB1c2VcbiAgICAgKi9cbiAgICBjcmVhdGVXZWJTb2NrZXQob3B0cz86IFdzT3B0aW9ucywgaG9zdD86IHN0cmluZykge1xuICAgICAgICB0aGlzLndlYlNvY2tPcHRzID0gb3B0czsgLy8gcHJlc2VydmVkIGZvciBmdXR1cmUgY2FsbHNcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdCA9PT0gdW5kZWZpbmVkID8gdGhpcy53aW5kb3cubG9jYXRpb24uaG9zdCA6IGhvc3Q7XG4gICAgICAgIHRoaXMudXJsID0gdGhpcy51ZnMud3NVcmwoJ2NvcmUnLCBvcHRzID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdHNbJ3dzcG9ydCddLnRvU3RyaW5nKCksIGhvc3QpO1xuXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdBdHRlbXB0aW5nIHRvIG9wZW4gd2Vic29ja2V0IHRvOiAnICsgdGhpcy51cmwpO1xuICAgICAgICB0aGlzLndzID0gdGhpcy53c29jay5uZXdXZWJTb2NrZXQodGhpcy51cmwpO1xuICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgLy8gZmF0IGFycm93ID0+IHN5bnRheCBtZWFucyB0aGF0IHRoZSAndGhpcycgY29udGV4dCBwYXNzZWQgd2lsbFxuICAgICAgICAgICAgLy8gYmUgb2YgV2ViU29ja2V0U2VydmljZSwgbm90IHRoZSBXZWJTb2NrZXRcbiAgICAgICAgICAgIHRoaXMud3Mub25vcGVuID0gKCgpID0+IHRoaXMuaGFuZGxlT3BlbigpKTtcbiAgICAgICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gKChtc2dFdmVudCkgPT4gdGhpcy5oYW5kbGVNZXNzYWdlKG1zZ0V2ZW50KSk7XG4gICAgICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSAoKCkgPT4gdGhpcy5oYW5kbGVDbG9zZSgpKTtcbiAgICAgICAgICAgIGNvbnN0IGF1dGhUb2tlbiA9IHRoaXMud2luZG93Wydvbm9zQXV0aCddO1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ0F1dGggVG9rZW4gZm9yIG9wZW5pbmcgV2ViU29ja2V0JywgYXV0aFRva2VuKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZEV2ZW50KCdhdXRoZW50aWNhdGlvbicsIHsgdG9rZW46IGF1dGhUb2tlbiB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBXc29jayBsb2dzIGFuIGVycm9yIGlmIHRoZSBuZXcgV2ViU29ja2V0IGNhbGwgZmFpbHNcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbGwgdGhlIFdlYlNvY2tldCB0byBjbG9zZSAtIHRoaXMgc2hvdWxkIGNhbGwgdGhlIGhhbmRsZUNsb3NlKCkgbWV0aG9kXG4gICAgICovXG4gICAgY2xvc2VXZWJTb2NrZXQoKSB7XG4gICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEJpbmRzIHRoZSBtZXNzYWdlIGhhbmRsZXJzIHRvIHRoZWlyIG1lc3NhZ2UgdHlwZSAoZXZlbnQgdHlwZSkgYXNcbiAgICAgKiAgc3BlY2lmaWVkIGluIHRoZSBnaXZlbiBtYXAuIE5vdGUgdGhhdCBrZXlzIGFyZSB0aGUgZXZlbnQgSURzOyB2YWx1ZXNcbiAgICAgKiAgYXJlIGVpdGhlcjpcbiAgICAgKiAgICAgKiB0aGUgZXZlbnQgaGFuZGxlciBmdW5jdGlvbiwgb3JcbiAgICAgKiAgICAgKiBhbiBBUEkgb2JqZWN0IHdoaWNoIGhhcyBhbiBldmVudCBoYW5kbGVyIGZvciB0aGUga2V5XG4gICAgICovXG4gICAgYmluZEhhbmRsZXJzKGhhbmRsZXJNYXA6IE1hcDxzdHJpbmcsIChkYXRhKSA9PiB2b2lkPik6IHZvaWQge1xuICAgICAgICBjb25zdCBkdXBzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLm5vSGFuZGxlcnNXYXJuKGhhbmRsZXJNYXAsICdiaW5kSGFuZGxlcnMnKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbZXZlbnRJZCwgYXBpXSBvZiBoYW5kbGVyTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnQWRkaW5nIGhhbmRsZXIgZm9yICcsIGV2ZW50SWQpO1xuICAgICAgICAgICAgY29uc3QgZm4gPSB0aGlzLmZzLmlzRihhcGkpIHx8IHRoaXMuZnMuaXNGKGFwaVtldmVudElkXSk7XG4gICAgICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cud2FybihldmVudElkICsgJyBoYW5kbGVyIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5oYW5kbGVycy5nZXQoZXZlbnRJZCkpIHtcbiAgICAgICAgICAgICAgICBkdXBzLnB1c2goZXZlbnRJZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMuc2V0KGV2ZW50SWQsIGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZHVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2R1cGxpY2F0ZSBiaW5kaW5ncyBpZ25vcmVkOicsIGR1cHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5iaW5kcyB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgaGFuZGxlcnMuXG4gICAgICogICBFeHBlY3RlZCB0aGF0IHRoZSBzYW1lIG1hcCB3aWxsIGJlIHVzZWQsIGJ1dCB3ZSBvbmx5IGNhcmUgYWJvdXQga2V5c1xuICAgICAqL1xuICAgIHVuYmluZEhhbmRsZXJzKGhhbmRsZXJJZHM6IHN0cmluZ1tdKTogdm9pZCB7XG4gICAgICAgIGlmICggaGFuZGxlcklkcy5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdXU1MudW5iaW5kSGFuZGxlcnMoKTogbm8gZXZlbnQgaGFuZGxlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnRJZCBvZiBoYW5kbGVySWRzKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzLmRlbGV0ZShldmVudElkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzSGFuZGxpbmcoaGFuZGxlcklkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMuZ2V0KGhhbmRsZXJJZCkgIT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBmdW5jdGlvbiBmb3IgbGlzdGVuaW5nIGZvciBXZWJTb2NrZXQgb3BlbmluZy5cbiAgICAgKiBUaGUgZnVuY3Rpb24gbXVzdCBnaXZlIGEgaG9zdCBhbmQgdXJsIGFuZCByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIGFkZE9wZW5MaXN0ZW5lcihjYWxsYmFjazogKGhvc3Q6IHN0cmluZywgdXJsOiBzdHJpbmcpID0+IHZvaWQgKTogQ2FsbGJhY2sge1xuICAgICAgICBjb25zdCBpZDogbnVtYmVyID0gdGhpcy5uZXh0TGlzdGVuZXJJZCsrO1xuICAgICAgICBjb25zdCBjYiA9IHRoaXMuZnMuaXNGKGNhbGxiYWNrKTtcbiAgICAgICAgY29uc3QgbzogQ2FsbGJhY2sgPSA8Q2FsbGJhY2s+eyBpZDogaWQsIGNiOiBjYiB9O1xuXG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgdGhpcy5vcGVuTGlzdGVuZXJzLnNldChpZCwgbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignV1NTLmFkZE9wZW5MaXN0ZW5lcigpOiBjYWxsYmFjayBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgby5lcnJvciA9ICdObyBjYWxsYmFjayBkZWZpbmVkJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBsaXN0ZW5lciBvZiBXZWJTb2NrZXQgb3BlbmluZ1xuICAgICAqL1xuICAgIHJlbW92ZU9wZW5MaXN0ZW5lcihsc25yOiBDYWxsYmFjayk6IHZvaWQge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMuZnMuaXNPKGxzbnIpICYmIGxzbnIuaWQ7XG4gICAgICAgIGxldCBvO1xuXG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ1dTUy5yZW1vdmVPcGVuTGlzdGVuZXIoKTogaW52YWxpZCBsaXN0ZW5lcicsIGxzbnIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbyA9IHRoaXMub3Blbkxpc3RlbmVyc1tpZF07XG5cbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgIHRoaXMub3Blbkxpc3RlbmVycy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybXVsYXRlcyBhbiBldmVudCBtZXNzYWdlIGFuZCBzZW5kcyBpdCB2aWEgdGhlIHdlYi1zb2NrZXQuXG4gICAgICogSWYgdGhlIHdlYnNvY2tldCBpcyBub3QgdXAgeWV0LCB3ZSBzdG9yZSBpdCBpbiBhIHBlbmRpbmcgbGlzdC5cbiAgICAgKi9cbiAgICBzZW5kRXZlbnQoZXZUeXBlOiBzdHJpbmcsIHBheWxvYWQ6IE9iamVjdCApOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZXYgPSA8RXZlbnRUeXBlPiB7XG4gICAgICAgICAgICBldmVudDogZXZUeXBlLFxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLndzVXApIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZChldik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdFdmVudHMucHVzaChldik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyB0aGUgdmVpbCBzZXJ2aWNlIGFzIGEgZGVsZWdhdGUuXG4gICAgICovXG4gICAgc2V0VmVpbERlbGVnYXRlKHZkOiBWZWlsQ29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMudmNkID0gdmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZHMgdGhlIGxvYWRpbmcgc2VydmljZSBhcyBhIGRlbGVnYXRlXG4gICAgICovXG4gICAgc2V0TG9hZGluZ0RlbGVnYXRlKGxkOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgLy8gVE9ETyAtIEludmVzdGlnYXRlIGNoYW5naW5nIExvYWRpbmcgU2VydmljZSB0byBMb2FkaW5nQ29tcG9uZW50XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdMb2FkaW5nIGRlbGVnYXRlIHNldCcsIGxkKTtcbiAgICAgICAgdGhpcy5sY2QgPSBsZDtcbiAgICB9XG5cbiAgICBpc0Nvbm5lY3RlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3NVcDtcbiAgICB9XG59XG4iXX0=